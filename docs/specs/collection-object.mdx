---
title: CollectionObject and collection manifests
description: Design spec for manifest-based huge-fanout results in DSLWorkflow with a uniform StoredObject envelope.
---

# Summary

This spec introduces a first-class `CollectionObject` variant in the `StoredObject` tagged union to represent huge collections (fanout outputs/inputs) without embedding `list[StoredObject]` in workflow history or forcing eager full materialization.

It is designed for:

- DSLWorkflow uniform envelope: workflow return values and action results are always a single `StoredObject`.
- Pure “world model”: ordinary JSON values do not unexpectedly contain `StoredObject` instances.
- Huge fanout: paging/indexed access and chunking to keep Temporal history small and avoid O(N) metadata in history.

# Goals

- `TaskResult.result` MUST remain a single `StoredObject`.
- `DSLWorkflow.run` MUST return a single `StoredObject`.
- Huge collections MUST be representable without storing N item references directly in workflow history.
- Workflow code MUST NOT perform network I/O (S3/MinIO); manifest I/O MUST happen inside activities.
- Collection access MUST support paging and single-item reads.
- Ordering MUST be stable and deterministic.

# Non-goals

- Replacing/augmenting this with a generalized Temporal PayloadCodec “large payload protocol” for externalization.
- Automatically materializing huge collections into full `list[Any]` implicitly in expression evaluation.

# Invariants

- `StoredObject` MUST appear only at explicit boundaries (task result, workflow return, trigger envelope, collection handle).
- Consumers MUST NOT be surprised by `StoredObject` values inside arbitrary JSON structures (e.g., inside `InlineObject.data`).
- If a value is not plain JSON-ish, it MUST be represented by an explicit handle type (e.g., `CollectionObject`), not smuggled into normal JSON.

# Data model

## StoredObject union

`StoredObject` is a tagged union (discriminator: `type`).

Existing:

- `InlineObject(type="inline", data: Any)`
- `ExternalObject(type="external", ref: ObjectRef)`

New:

- `CollectionObject(type="collection", ...)`

## CollectionObject (new variant)

`CollectionObject` is a small, history-safe handle to a collection manifest stored in blob storage.

Required fields (v1):

- `type: "collection"`
- `manifest_ref: ObjectRef` — reference to the manifest blob
- `count: int` — number of elements
- `chunk_size: int`
- `element_kind: "value" | "stored_object"`
- `schema_version: int = 1`

Semantics:

- `element_kind="value"` means the logical collection is `list[Any]` (pure values).
- `element_kind="stored_object"` means the logical collection is `list[StoredObject]` (handles). Materializing values requires retrieving each element.

# Manifest formats (stored in blob)

All manifest/chunk blobs are versioned and self-identifying.

## CollectionManifestV1

Stored at `.../manifest.json` (or equivalent deterministic key).

Fields:

- `kind: "tracecat.collection_manifest"`
- `version: 1`
- `count: int`
- `chunk_size: int`
- `element_kind: "value" | "stored_object"`
- `chunks: list[ObjectRef]` — chunk blob refs

## CollectionChunkV1

Stored at `.../chunks/{chunk_index}.json`.

Fields:

- `kind: "tracecat.collection_chunk"`
- `version: 1`
- `start: int` — global start index for this chunk
- `items: list[Any] | list[StoredObject]`

Notes:

- For `element_kind="stored_object"`, chunk `items` contains serialized `StoredObject` dictionaries (including `type` discriminator).
- For `element_kind="value"`, chunk `items` contains JSON-ish values.

# Storage and idempotency

## Keying

Manifest/chunk keys MUST be deterministic per workflow execution + producing node to support activity retries:

- `{wf_exec_id}/{stream_id}/{task_ref}/{collection_id}/manifest.json`
- `{wf_exec_id}/{stream_id}/{task_ref}/{collection_id}/chunks/{chunk_index}.json`

`collection_id` SHOULD be generated once in workflow code (e.g., `workflow.uuid4()`) and passed into activities.

## Externalization behavior

- Manifests and chunks MUST be stored externally (S3/MinIO) regardless of general result externalization thresholds.
- If blob storage/externalization is unavailable, the system MUST either:
  - fail fast with a clear error (“collection manifests require external storage”), OR
  - fall back to legacy behavior only under strict limits (small `count` / small bytes), producing a non-collection `StoredObject`.

# Activities (core primitives)

These are the minimal activities needed to support the protocol.

## Store a collection

`store_collection_activity(prefix, items, element_kind, chunk_size) -> CollectionObject`

- Splits items into chunks.
- Uploads each chunk blob.
- Uploads a manifest blob referencing chunk refs.
- Returns `CollectionObject` (small handle).

## Read a page

`get_collection_page_activity(collection: CollectionObject, offset: int, limit: int) -> list[Any] | list[StoredObject]`

- Fetches only the required chunk blobs and slices items.

## Read a single item

`get_collection_item_activity(collection: CollectionObject, index: int) -> Any | StoredObject`

- Fetches exactly one chunk and indexes into it.

## Explicit materialization to values (potentially expensive)

`materialize_collection_values_activity(collection: CollectionObject, offset: int = 0, limit: int | None = None) -> list[Any]`

- If `element_kind="value"`: concatenates pages of values.
- If `element_kind="stored_object"`: pages handles and retrieves each `StoredObject` to values (recursive).

This MUST NOT run inside the workflow thread; it is an activity.

## Map a collection (loop-over-manifest primitive)

`map_collection_activity(input_collection: CollectionObject, template_obj: Any, base_operand_ctx: ExecutionContext, *, chunk_size: int) -> CollectionObject`

- Reads input in pages.
- For each item:
  - patches a deterministic operand context (e.g., `var`) for that iteration,
  - evaluates `template_obj` against the patched operand,
  - writes outputs into output chunks.
- Returns an output `CollectionObject(element_kind="value")`.

This is used for “loop subflow over manifest”, “scatter over manifest”, and preparing child `trigger_inputs` at huge fanout.

# Workflow integration

## Subflow loop results

Looped child workflows return `StoredObject` per iteration. The parent MUST return a single `StoredObject` representing the collection:

- small fanout: `InlineObject(data=[...values...])` or `ExternalObject(ref=list.json)`
- huge fanout: `CollectionObject(element_kind="stored_object")` containing chunked `StoredObject` handles

## Scatter/gather

- Scatter over a large collection SHOULD use `CollectionObject(element_kind="value")` and per-item indexed access.
- Gather SHOULD return:
  - a normal list `StoredObject` for small outputs, or
  - `CollectionObject(element_kind="value")` for huge outputs.

## Expression evaluation

Expression evaluation MUST NOT implicitly expand `CollectionObject` into full lists. Any expansion/iteration MUST be performed by explicit activities (e.g., `map_collection_activity`) and/or bounded auto-materialization under strict small-collection limits.

# Errors and ordering

- Collection ordering is by global index and MUST be deterministic.
- Per-item failures MUST have an explicit representation. Options:
  - store error objects as values (recommended), or
  - store a parallel error collection and define join/partition rules.

`element_kind="stored_object"` collections MUST define how error handles are represented and surfaced when materialized.

# Configuration and limits

Recommended config knobs:

- `TRACECAT__COLLECTION_CHUNK_SIZE` (default e.g. 256–1000)
- `TRACECAT__COLLECTION_INLINE_MAX_ITEMS`
- `TRACECAT__COLLECTION_INLINE_MAX_BYTES`
- `TRACECAT__COLLECTION_AUTO_MATERIALIZE_MAX_ITEMS` (only for convenience; must remain small)
- `TRACECAT__COLLECTION_MANIFESTS_ENABLED` (feature gate)

# Backward compatibility and rollout

This design supports backward compatibility at the behavior level, but not automatically at the wire/type level.

## Behavior compatibility (same semantics as today)

`CollectionObject` is an optimization:

- When manifests are disabled and/or fanout is below thresholds, the system SHOULD emit today’s shapes:
  - `InlineObject(data=[...])`, or
  - `ExternalObject(ref=.../list.json)` containing the full list.

This preserves end-user semantics and minimizes changes in “small data” cases.

## Wire/type compatibility (schema awareness required)

Once the system emits `type: "collection"`:

- Any reader/validator/client that only knows `inline|external` will fail to validate/deserialize.
- This applies to Pydantic validators, generated OpenAPI/TS clients, and any UI code that pattern-matches only the existing variants.

Therefore, `CollectionObject` emission MUST be gated until all readers are updated.

## Rollout order (recommended)

1. Ship readers first (backend + UI + clients):
   - Extend `StoredObject` union to include `CollectionObject`.
   - Add safe handling paths (e.g., display “collection handle” and/or allow explicit paging).
2. Keep writers producing legacy shapes by default.
3. Enable `CollectionObject` emission gradually:
   - start with very large fanouts / over-threshold payloads,
   - then widen coverage as confidence grows.

## Transitional alternative (if wire compatibility is required)

If adding a new union variant is too disruptive initially, a transitional approach MAY encode manifests as an `ExternalObject` whose blob content is a manifest format (with `kind/version`) and/or a distinguishing `content_type`.

Tradeoffs:

- Pros: avoids changing the `StoredObject` union immediately.
- Cons: weaker safety/clarity; naive consumers may `retrieve()` expecting a list and instead receive a manifest document.
