---
title: Expressions
description: Powerful expression syntax and templating engine.
---

The concepts explained in this section are all very interdependent on one another, so we've added a [cheatsheet](/concepts/expressions#cheatsheet) to help you get started.

Expressions are a powerful feature in Tracecat that gives you fine-grained control over your action logic.
They are strings that can be evaluated into a value or data/object reference, prefixed with a [context](#expression-contexts) and wrapped in [template](#template-syntax) `${{ ... }}` syntax.
We use [JSONPath](https://www.ietf.org/archive/id/draft-goessner-dispatch-jsonpath-00.html) expressions (dot notation) to access data, objects, or functions inside JSON-like data structures.

In object-oriented programming terms, you can think of this as method invocation or attribute access on a specific context (analagous to a class or instance).

Some examples of expressions:

```css
${{ SECRETS.my_secret.SUPER_SECRET }}
${{ ACTIONS.my_action.result }}
${{ FNS.add(1, 2) }}
${{ INPUTS.my_input }}
${{ TRIGGER.my_trigger }}
```

<Note>
  Our convention is to use `lower_snake_case` if you need to replace whitespace
  in your paths.
</Note>

We also support **typecasting** for expressions:

```css
${{ <expression> -> <type> }}
```

Types we currently support are `int`, `str`, `bool`, and `float`.

For example, this expression will return the integer literal 3:

```css
${{ FNS.add(1, 2) -> int }}
```

### Expression Contexts

An expression context is a top-level namespace that changes the behavior of an expression.
Tracecat expression contexts are all uppercase qualifiers, e.g. `SECRETS`.

We use dot notation or JSONPath expressions to access data, objects, or functions in a particular context.
We currently support the following contexts:

| Qualifier | Expression syntax                    | Description                             |
| --------- | ------------------------------------ | --------------------------------------- |
| `SECRETS` | `SECRETS.<name>.<key>`               | Secrets manager                         |
| `ACTIONS` | `ACTIONS.<jsonpath>.result`          | The active workflow's execution results |
| `FNS`     | `FNS.<fn_name>(<arg1>, <arg2>, ...)` | Inline functions                        |
| `INPUTS`  | `INPUTS.<jsonpath>`                  | The active workflow's static inputs     |
| `TRIGGER` | `TRIGGER.<jsonpath>`                 | The active workflow's trigger inputs    |

## Template syntax

Tracecat's template syntax takes inspiration from Github Actions, so it may feel familiar to you!

A template is a string with a `${{ ... }}` pattern that wraps an expression:

```css
${{ <expression> }}
```

Templates can exist in two forms: full templates and inline templates.

### Full templates

A full template is a sstring that only contains a single template with no surrounding whitespace:

```php
"${{ ... }}"
```

The final datatype of the above expression depends on the return type of the expression and whether there is a typecast.

This expression will return integer literal `3` because `FNS.add(1, 2)` returns an integer:

```php
"${{ FNS.add(1, 2) }}"
```

In contrast, this expression will return string literal `"3"` because `FNS.add(1, 2)` was cast to a string:

```php
"${{ FNS.add(1, 2) -> str}}"
```

In YAML, by convention we omit the quotes around full template expressions:

```yaml
actions:
  - ref: my_action
    action: example.action
    args:
      value: ${{ FNS.add(1, 2) }}
```

### Inline templates

An inline template is a string where all templates are in the string body:

```php
"An inline template ${{ ... }} looks ${{ ... }} like this."
```

The final datatype of the above expression is always a string.

For example, this expression:

```php
"An inline template ${{ FNS.add(1, 2) }} looks ${{ FNS.add(1, 2) -> str }} like this."
```

will return string literal `"An inline template 3 looks 3 like this."`:

In YAML, by convention we wrap quotes around inline template expressions:

```yaml
actions:
  - ref: my_action
    action: example.action
    args:
      value: "An inline template ${{ FNS.add(1, 2) }} looks ${{ FNS.add(1, 2) -> str }} like this."
```

## Action Expressions

Action expressions are JSONPaths that target the `ACTIONS` context. It references data or objects that are returned from completed actions.

```css
${{ ACTIONS.<jsonpath>.result }}
```

For example, if you have an action that was defined with the following [UDF](/concepts/user-defined-functions) in your workflow definition:

```python
@registry.register(namespace="example", description="Adds two numbers.")
def add(lhs: int, rhs: int) -> int:
    return lhs + rhs
```

and the following snippet of YAML in your workflow definition:

```yaml
actions:
  - ref: add_two_numbers
    action: example.add
    args:
      lhs: 1
      rhs: 2
```

Then anywhere else in your workflow definition and given `add_two_numbers` has completed, you can use the `ACTIONS.add_two_numbers.result` expression to access the result of the action.

Revisiting the example above, if you added another action to the same workflow:

```yaml
actions:
  - ref: add_two_numbers
    action: example.add
    args:
      lhs: 1
      rhs: 2
  - ref: add_three_numbers
    action: example.add
    depends_on:
      - add_two_numbers
    args:
      lhs: ${{ ACTIONS.add_two_numbers.result }} # This evaluates to 3!
      rhs: 3
```

you can use upstream computations in your downstream actions.

<Tip>
  Tracecat's workflow engine doesn't enforce that actions require hierarchical
  dependencies on other actions to use their results. So long an action in the
  same workflow is completed, another action can use its result.
</Tip>

Action expressions always contain the following predefined keys:

| Key               | Description                                        |
| ----------------- | -------------------------------------------------- |
| `result`          | Contains the action's result.                      |
| `result_typename` | The Python type annotation of the action's result. |

## Input Expressions

```css
${{ INPUTS.<jsonpath> }}
```

## Trigger Expressions

## Secret Expressions

## Cheatsheet

### Terminology

| Term            | Description                                                                                          |
| --------------- | ---------------------------------------------------------------------------------------------------- |
| Context         | A top-level namespace that changes the behavior of an expression, e.g. `SECRETS` or `ACTIONS`        |
| Expression      | A string that can be evaluated into a value or data/object reference, often involving a `context`.   |
| Template        | A string holding an expression `${{ <expr> }}` that evaluates into a value or data/object reference. |
| Full template   | A string that only contains a templated expression: `"${{ <expr> }}"`                                |
| Inline template | All templated expressions are inline, e.g. `"An inline ${{ <expr> }} looks like this."`              |

### Contexts

| Qualifier | Description                                                                                                                   |
| --------- | ----------------------------------------------------------------------------------------------------------------------------- |
| `SECRETS` | Secrets manager context. The expression `SECRETS.my_secret.SUPER_SECRET` will return `my_secret.SUPER_SECRET`'s stored value. |
| `ACTIONS` | The active workflow's execution context. Lets you access results from completed actions.                                      |
| `FNS`     | Inline functions. The expression `FNS.add(1, 2)` will return `3`.                                                             |
| `INPUTS`  | The active workflow's static inputs. Lets you access static inputs from the workflow definition.                              |
| `TRIGGER` | The active workflow's trigger inputs. Lets you access dynamic inputs from a webhook.                                          |
