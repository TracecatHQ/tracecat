---
title: Custom integrations
description: Build and sync custom integrations from a private Git repository into Tracecat.
icon: code-branch
---

<Tip>
  Get started by cloning the [custom-integrations-starter-kit](https://github.com/TracecatHQ/custom-integrations-starter-kit) template repo.
</Tip>

By the end of this tutorial, you'll learn how to:

- Build custom integrations in YAML and Python
- Version control your integrations with Git
- Sync custom integrations into Tracecat
- Use custom integrations in workflows

## Prerequisites

- Access to a private Git repository (e.g. GitHub, GitLab)
- Basic knowledge of Python, [`pip`](https://pip.pypa.io/en/stable/getting-started/), and YAML

## YAML Action Templates

<Tip>
  Check out Tracecat's open source [Action Templates](https://github.com/TracecatHQ/tracecat/tree/main/registry/tracecat_registry/templates) on GitHub for examples.
  More information on when and how to build effective templates can be found in the [integrations best practices](/integrations/best-practices) docs.
</Tip>

If you find yourself using a generic action (e.g. `core.http_request`) with the same parameters in multiple workflows, we recommend creating a YAML action template.

Every **Action Template** follows the same structure:

```yaml
type: action
definition:
  title: <title>
  description: <description>
  display_group: <display_group>
  doc_url: <doc_url>
  namespace: <namespace>
  name: <name>
  secrets:  # Secrets are optional
    - name: <secret_name>
      keys:
        - <key_name>
      optional_keys:
        - <key_name>
  expects:
    <param_name>:
      type: <type>
      description: <description>
      default: <default_value>  # Optional
  steps:
    - ref: <step_id>
      action: <action_namespace>.<action_name>
      args:
        <param_name>: <param_value>
  returns: <returns>
```

<Note>
  Secrets used in templates must be defined in the `secrets` section.
  They are retrieved from Tracecat's secrets manager at runtime and garbage collected after the action is executed.
</Note>

### Actions in templates

Templates support all actions defined in the **Tracecat Registry**.
Actions, such as `core.http_request` and `tools.falconpy.call_command`, can all be used in templates by specifying the `steps.action` field.

### Expressions in templates

Templates support the following expressions:

- `inputs`: Reference inputs into the action as defined in the `expects` section.
- `steps`: Reference results from previous steps in the same template.
- `SECRETS`: Reference secrets.
- `FN`: Reference functions.

`inputs` and `steps` are expressions specific to templates.
`SECRETS` and `FN` are used in the same way as in workflows.

This means that templates have full support for Tracecat's powerful [inline functions](/quickstart/expressions).
For example:

```yaml
${{ FN.to_isoformat(inputs.start_time) }}
${{ FN.strip(FN.to_base64url(inputs.url), "=") }}
```

## Python UDFs

<Tip>
  Check out Tracecat's open source [core actions](https://github.com/TracecatHQ/tracecat/tree/main/registry/tracecat_registry/base/core)
  and [Python integrations](https://github.com/TracecatHQ/tracecat/tree/main/registry/tracecat_registry/integrations) on GitHub for examples.
</Tip>

Tracecat makes it easy to turn your Python scripts into no-code workflow actions, which we call **user-defined functions (UDFs)**.
All you need is a:
- Single Python decorator
- `from typing import Annotated`
- `from typing_extensions import Doc`

For example:

```python
from typing import Annotated
from typing_extensions import Doc

from tracecat_registry import registry, RegistrySecret, secrets


# (Optional) Define secrets used in the function
secret_name = RegistrySecret(
  name="secret_name",
  keys=["SECRET_NAME"],
  optional_keys=["OPTIONAL_SECRET_NAME"],
)


# Register the function as a Tracecat UDF
@registry.register(
    default_title="Say Goodbye Secretly",
    description="This is a function that says goodbye",
    display_group="Greetings",
    namespace="integrations.greetings",
    # (Optional) Define secrets used in the function
    secrets=[secret_name],
)
def say_goodbye_secretly(
    name: Annotated[str, Doc("The name to say goodbye to")],
):
    secret = secrets.get("SECRET_NAME")
    # We're returning the secret for demonstration only.
    # Do not do this in your own functions!
    return {"message": f"Goodbye, {name}! Secret: {secret}"}
```

<Note>
  Secrets used in UDFs must be defined as `RegistrySecret` objects in the `secrets` argument of the `@registry.register` decorator.
  They are retrieved from Tracecat's secrets manager at runtime and garbage collected after the action is executed.
</Note>

<Info>
  `Annotated` and `Doc` are used to convert your Python function arguments into Tracecat action inputs.

  They **do not affect** the function's behavior in Python.
  You can continue using the function as normal in your scripts and tests.
</Info>

### Run and test UDFs locally

You will need to install [`tracecat_registry`](https://github.com/TracecatHQ/tracecat/tree/main/registry).
The recommended way to do this is by using the [custom-integrations-starter-kit](https://github.com/TracecatHQ/custom-integrations-starter-kit).
All you need to do is specify `dev` dependencies when installing the project.

```bash
cd custom-integrations-starter-kit
pip install -e ".[dev]"
```

## Git sync tutorial

In this section, we'll walk through the process of securely syncing custom integrations into Tracecat.

<Steps>
  <Step title="Create new repo">
    Create a new repo from the [custom-integrations-starter-kit](https://github.com/TracecatHQ/custom-integrations-starter-kit) template.
    ![Custom integrations template](/img/tutorials/custom-integrations/create-new-repo.png)
  </Step>
  <Step title="Configure remote repo URL">
    Go to the `Git Repository` section in `Organization` settings and configure the remote repo URL to point to your private repository.

  </Step>
  <Step title="GitHub SSH deploy key">
    Create a SSH public / private key pair (without a passphrase) and store the public key in GitHub.
    Store the public key in GitHub.
  </Step>
  <Step title="Private key in Tracecat">
    Go to the `SSH Keys` section in `Organizations` settings and add the private key with the name `github-ssh-key`.

    <Note>
      Do not change the key name. The `github-ssh-key` key name works for both GitHub and GitLab.
    </Note>
  </Step>
  <Step title="Refresh repos in Tracecat">
    Go to the `Repositories` section in the `Registry` page and refresh the repos.
    Your custom repo should now be visible.
  </Step>
  <Step title="Sync custom repo">
    In the same `Repositories` section, select your custom repo and press the `Sync from remote`.
    Your custom integrations should now be visible in your Tracecat instance's registry.
  </Step>
  <Step title="View custom integrations">
    Go to the `Actions` view in the `Registry` page and filter by `Origin` to view synced actions.
  </Step>
  <Step title="ðŸŽ‰ That's it!">
    Feel free to add your own custom Python UDFs and YAML templates to the custom integrations repo.

    Just push to your changes to the git repo and press sync in Tracecat Registry.
    Updates and new actions will show up immediately.
  </Step>
</Steps>

## Next steps

- Join our [Discord community](https://discord.gg/n3GF4qxFU8) and meet other Tracecat users and contributors.
- Have integrations you'd like to share with the community? Open up an [issue](https://github.com/TracecatHQ/tracecat/issues) on GitHub and start contributing to open source!
- Check out [integrations best practices](/integrations/best-practices).
