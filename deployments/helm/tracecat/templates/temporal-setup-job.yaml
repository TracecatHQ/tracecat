{{- if .Values.temporal.enabled }}
apiVersion: batch/v1
kind: Job
metadata:
  name: {{ include "tracecat.fullname" . }}-temporal-setup
  labels:
    {{- include "tracecat.labels" . | nindent 4 }}
  annotations:
    "helm.sh/hook": post-install,post-upgrade
    "helm.sh/hook-weight": "0"
    "helm.sh/hook-delete-policy": before-hook-creation,hook-succeeded
spec:
  backoffLimit: 10
  activeDeadlineSeconds: 600
  template:
    metadata:
      {{- with .Values.podAnnotations }}
      annotations:
        {{- toYaml . | nindent 8 }}
      {{- end }}
    spec:
      restartPolicy: OnFailure
      serviceAccountName: {{ include "tracecat.serviceAccountName" . }}
      containers:
        - name: temporal-setup
          image: temporalio/admin-tools:1.29.1-tctl-1.18.4-cli-1.5.0
          command: ["/bin/sh", "-c"]
          args:
            - |
              set -e

              # Persistence bootstrap (DB create + schema setup/update) is handled by
              # the Temporal subchart schema job via:
              # temporal.server.config.persistence.datastores.*.sql.createDatabase/manageSchema.
              # This hook only performs setup that requires a running Temporal frontend.

              # Wait for Temporal frontend to be healthy (with exponential backoff)
              echo "Waiting for Temporal frontend to be ready..."
              MAX_RETRIES=30
              RETRY_COUNT=0
              SLEEP_TIME=2

              until temporal operator cluster health 2>/dev/null; do
                RETRY_COUNT=$((RETRY_COUNT + 1))
                if [ $RETRY_COUNT -ge $MAX_RETRIES ]; then
                  echo "Temporal frontend not ready after $MAX_RETRIES retries"
                  exit 1
                fi
                echo "Attempt $RETRY_COUNT/$MAX_RETRIES - Temporal not ready, waiting ${SLEEP_TIME}s..."
                sleep $SLEEP_TIME
                # Exponential backoff capped at 30s
                SLEEP_TIME=$((SLEEP_TIME * 2))
                [ $SLEEP_TIME -gt 30 ] && SLEEP_TIME=30
              done
              echo "Temporal frontend is healthy"

              NAMESPACE="{{ include "tracecat.temporalNamespace" . }}"
              RETENTION="{{ include "tracecat.temporalNamespaceRetention" . }}"
              HISTORY_ARCHIVAL_STATE="{{ include "tracecat.temporalNamespaceHistoryArchivalState" . }}"
              HISTORY_ARCHIVAL_URI="{{ include "tracecat.temporalNamespaceHistoryArchivalURI" . }}"
              VISIBILITY_ARCHIVAL_STATE="{{ include "tracecat.temporalNamespaceVisibilityArchivalState" . }}"
              VISIBILITY_ARCHIVAL_URI="{{ include "tracecat.temporalNamespaceVisibilityArchivalURI" . }}"

              normalize_state() {
                echo "$1" | tr '[:upper:]' '[:lower:]'
              }

              create_namespace() {
                set -- --namespace "$NAMESPACE"
                if [ -n "$RETENTION" ]; then
                  set -- "$@" --retention "$RETENTION"
                fi
                if [ -n "$HISTORY_ARCHIVAL_STATE" ]; then
                  set -- "$@" --history-archival-state "$HISTORY_ARCHIVAL_STATE"
                fi
                if [ -n "$HISTORY_ARCHIVAL_URI" ]; then
                  set -- "$@" --history-uri "$HISTORY_ARCHIVAL_URI"
                fi
                if [ -n "$VISIBILITY_ARCHIVAL_STATE" ]; then
                  set -- "$@" --visibility-archival-state "$VISIBILITY_ARCHIVAL_STATE"
                fi
                if [ -n "$VISIBILITY_ARCHIVAL_URI" ]; then
                  set -- "$@" --visibility-uri "$VISIBILITY_ARCHIVAL_URI"
                fi
                temporal operator namespace create "$@"
              }

              load_current_namespace_settings() {
                CURRENT_HISTORY_ARCHIVAL_STATE="$(printf '%s\n' "$NAMESPACE_DESC" | awk '$1=="Config.HistoryArchivalState"{print tolower($2); exit}')"
                CURRENT_VISIBILITY_ARCHIVAL_STATE="$(printf '%s\n' "$NAMESPACE_DESC" | awk '$1=="Config.VisibilityArchivalState"{print tolower($2); exit}')"
              }

              run_namespace_update() {
                if UPDATE_OUTPUT="$(temporal operator namespace update "$@" 2>&1)"; then
                  [ -n "$UPDATE_OUTPUT" ] && echo "$UPDATE_OUTPUT"
                  return 0
                fi

                echo "Namespace update command failed"
                echo "$UPDATE_OUTPUT"
                echo "Desired archival settings:"
                echo "  history: state=${HISTORY_ARCHIVAL_STATE:-<empty>} uri=${HISTORY_ARCHIVAL_URI:-<empty>}"
                echo "  visibility: state=${VISIBILITY_ARCHIVAL_STATE:-<empty>} uri=${VISIBILITY_ARCHIVAL_URI:-<empty>}"
                echo "Current archival states:"
                echo "  history: state=${CURRENT_HISTORY_ARCHIVAL_STATE:-<unknown>}"
                echo "  visibility: state=${CURRENT_VISIBILITY_ARCHIVAL_STATE:-<unknown>}"
                echo "Current namespace description:"
                temporal operator namespace describe "$NAMESPACE" || true
                echo "Hint: ensure Temporal cluster archival provider config matches namespace URI schemes (for example, s3:// requires s3 archiver support)."
                return 1
              }

              reconcile_existing_namespace() {
                set -- --namespace "$NAMESPACE"

                # Retention is applied on create only. Existing namespaces may be
                # constrained by cluster max retention settings and reject updates.
                if [ -n "$HISTORY_ARCHIVAL_STATE" ] && [ "$HISTORY_ARCHIVAL_STATE" != "$CURRENT_HISTORY_ARCHIVAL_STATE" ]; then
                  set -- "$@" --history-archival-state "$HISTORY_ARCHIVAL_STATE"
                fi
                if [ -n "$VISIBILITY_ARCHIVAL_STATE" ] && [ "$VISIBILITY_ARCHIVAL_STATE" != "$CURRENT_VISIBILITY_ARCHIVAL_STATE" ]; then
                  set -- "$@" --visibility-archival-state "$VISIBILITY_ARCHIVAL_STATE"
                fi

                # Namespace archival URIs are immutable once archival is enabled.
                # Only set URIs the first time archival is transitioned to enabled.
                if [ "$HISTORY_ARCHIVAL_STATE" = "enabled" ] && [ "$CURRENT_HISTORY_ARCHIVAL_STATE" != "enabled" ] && [ -n "$HISTORY_ARCHIVAL_URI" ]; then
                  set -- "$@" --history-uri "$HISTORY_ARCHIVAL_URI"
                fi
                if [ "$VISIBILITY_ARCHIVAL_STATE" = "enabled" ] && [ "$CURRENT_VISIBILITY_ARCHIVAL_STATE" != "enabled" ] && [ -n "$VISIBILITY_ARCHIVAL_URI" ]; then
                  set -- "$@" --visibility-uri "$VISIBILITY_ARCHIVAL_URI"
                fi

                if [ "$#" -eq 2 ]; then
                  echo "Namespace settings already match desired archival configuration"
                  return 0
                fi

                run_namespace_update "$@"
              }

              HISTORY_ARCHIVAL_STATE="$(normalize_state "$HISTORY_ARCHIVAL_STATE")"
              VISIBILITY_ARCHIVAL_STATE="$(normalize_state "$VISIBILITY_ARCHIVAL_STATE")"

              # Validate archival settings early with a clear error message.
              if [ "$HISTORY_ARCHIVAL_STATE" = "enabled" ] && [ -z "$HISTORY_ARCHIVAL_URI" ]; then
                echo "History archival is enabled but history URI is empty"
                exit 1
              fi
              if [ "$VISIBILITY_ARCHIVAL_STATE" = "enabled" ] && [ -z "$VISIBILITY_ARCHIVAL_URI" ]; then
                echo "Visibility archival is enabled but visibility URI is empty"
                exit 1
              fi

              # Reconcile namespace settings (idempotent)
              echo "Checking namespace..."
              if NAMESPACE_DESC="$(temporal operator namespace describe "$NAMESPACE" 2>/dev/null)"; then
                echo "Namespace '$NAMESPACE' already exists, reconciling settings..."
                load_current_namespace_settings
                reconcile_existing_namespace
                echo "Namespace reconciled"
              else
                echo "Creating namespace '$NAMESPACE'..."
                if CREATE_OUTPUT="$(create_namespace 2>&1)"; then
                  [ -n "$CREATE_OUTPUT" ] && echo "$CREATE_OUTPUT"
                  echo "Namespace created"
                else
                  # Handle race conditions where another setup job creates the namespace
                  # between the initial describe and this create call.
                  echo "Namespace create failed, checking if it now exists..."
                  echo "$CREATE_OUTPUT"
                  if NAMESPACE_DESC="$(temporal operator namespace describe "$NAMESPACE" 2>/dev/null)"; then
                    echo "Namespace '$NAMESPACE' already exists, reconciling settings..."
                    load_current_namespace_settings
                    reconcile_existing_namespace
                    echo "Namespace reconciled"
                  else
                    echo "Namespace create failed for an unexpected reason"
                    exit 1
                  fi
                fi
              fi

              # Add search attributes (idempotent - check each before adding)
              echo "Checking search attributes..."
              {{- range $name, $type := .Values.tracecat.temporal.searchAttributes }}
              if temporal operator search-attribute list --namespace "$NAMESPACE" 2>/dev/null | grep -q "{{ $name }}"; then
                echo "Search attribute '{{ $name }}' already exists"
              else
                echo "Adding search attribute '{{ $name }}' ({{ $type }})..."
                if CREATE_ATTR_OUTPUT="$(temporal operator search-attribute create --namespace "$NAMESPACE" --name {{ $name }} --type {{ $type }} 2>&1)"; then
                  [ -n "$CREATE_ATTR_OUTPUT" ] && echo "$CREATE_ATTR_OUTPUT"
                  echo "Search attribute '{{ $name }}' created"
                else
                  # Handle race conditions where another process creates the attribute first.
                  echo "Create failed for '{{ $name }}', checking if it now exists..."
                  echo "$CREATE_ATTR_OUTPUT"
                  if temporal operator search-attribute list --namespace "$NAMESPACE" 2>/dev/null | grep -q "{{ $name }}"; then
                    echo "Search attribute '{{ $name }}' already exists"
                  else
                    echo "Failed to create search attribute '{{ $name }}'"
                    exit 1
                  fi
                fi
              fi
              {{- end }}

              echo "Temporal setup complete!"
          env:
            - name: TEMPORAL_ADDRESS
              value: {{ include "tracecat.temporalClusterUrl" . | quote }}
{{- end }}
