from typing import Annotated, Any, Literal

import httpx
from pydantic import Field

from tracecat_registry import RegistrySecret, registry, secrets

"""Splunk API Key.

- name: `splunk`
- keys:
    - `SPLUNK_API_KEY` (API key)

Note: `SPLUNK_API_KEY` should be a valid API key for the Splunk instance.
"""
splunk_secret = RegistrySecret(
    name="splunk",
    keys=["SPLUNK_API_KEY"],
)

"""Splunk HEC Token.

- name: `splunk_hec`
- keys:
    - `SPLUNK_USERNAME` (username)
    - `SPLUNK_PASSWORD` (password)

Note: `SPLUNK_USERNAME` and `SPLUNK_PASSWORD` should be a valid username and password for the Splunk instance.
"""
splunk_hec_secret = RegistrySecret(
    name="splunk",
    keys=["SPLUNK_HEC_TOKEN"],
)


@registry.register(
    default_title="Create KV Store Collection",
    description="Create a KV Store Collection in Splunk. Uses bearer token authentication.",
    display_group="Splunk",
    doc_url="https://help.splunk.com/en/splunk-enterprise/rest-api-reference/9.4/kv-store-endpoints/kv-store-endpoint-descriptions#post-9",
    namespace="tools.splunk",
    secrets=[splunk_secret],
)
async def create_kv_store_collection(
    base_url: Annotated[
        str,
        Field(
            ...,
            description="Splunk base URL (e.g. https://localhost:8089 or https://tracecat.splunkcloud.com:8089).",
        ),
    ],
    name: Annotated[
        str,
        Field(
            ...,
            description="Name of the KV Store Collection. Must be unique and contain only alphanumeric characters, underscores, and hyphens.",
        ),
    ],
    owner: Annotated[
        str,
        Field(..., description="Owner of the KV Store Collection. Default is nobody."),
    ] = "nobody",
    app: Annotated[
        str, Field(..., description="Name of the app. Default is search.")
    ] = "search",
    verify_ssl: Annotated[
        bool, Field(..., description="Whether to verify SSL certificates.")
    ] = True,
) -> dict[str, Any]:
    """Create a KV Store Collection in Splunk."""
    api_key = secrets.get("SPLUNK_API_KEY")
    url = f"{base_url}/servicesNS/{owner}/{app}/storage/collections/config"
    headers = {
        "Authorization": f"Bearer {api_key}",
        "Content-Type": "application/json",
        "Accept": "application/json",
    }
    payload = {
        "name": name,
        "output_mode": "json",
    }
    async with httpx.AsyncClient(verify=verify_ssl) as client:
        response = await client.post(url, headers=headers, data=payload)
        response.raise_for_status()
        return response.json()


@registry.register(
    default_title="Create Entry to KV Store Collection",
    description="Create an entry in a KV Store Collection in Splunk. Uses bearer token authentication.",
    display_group="Splunk",
    doc_url="https://help.splunk.com/en/splunk-enterprise/rest-api-reference/9.4/kv-store-endpoints/kv-store-endpoint-descriptions#post-2",
    namespace="tools.splunk",
    secrets=[splunk_secret],
)
async def create_entry_to_kv_store_collection(
    base_url: Annotated[
        str,
        Field(
            ...,
            description="Splunk base URL (e.g. https://localhost:8089 or https://tracecat.splunkcloud.com:8089).",
        ),
    ],
    collection: Annotated[
        str,
        Field(
            ...,
            description="Name of the KV Store Collection you would like to create an entry in.",
        ),
    ],
    entry: Annotated[
        dict[str, Any],
        Field(
            ...,
            description="Entry to create in the KV Store Collection. Should be a dictionary of key-value pairs. Example: {'key': 'value'}. Note that _key is automatically generated by Splunk and should not be entered.",
        ),
    ],
    owner: Annotated[
        str,
        Field(..., description="Owner of the KV Store Collection. Default is nobody."),
    ] = "nobody",
    app: Annotated[
        str,
        Field(
            ...,
            description="Name of the app the KV store collection is in. Default is search.",
        ),
    ] = "search",
    verify_ssl: Annotated[
        bool, Field(..., description="Whether to verify SSL certificates.")
    ] = True,
) -> dict[str, Any]:
    """Create an entry in a KV Store Collection in Splunk."""
    api_key = secrets.get("SPLUNK_API_KEY")
    url = f"{base_url}/servicesNS/{owner}/{app}/storage/collections/data/{collection}"
    headers = {
        "Authorization": f"Bearer {api_key}",
        "Content-Type": "application/json",
        "Accept": "application/json",
    }

    async with httpx.AsyncClient(verify=verify_ssl) as client:
        response = await client.post(url, headers=headers, json=entry)
        response.raise_for_status()
        return response.json()


@registry.register(
    default_title="Get KV Store Collection",
    description="Get a KV Store Collection from Splunk. Uses bearer token authentication.",
    display_group="Splunk",
    doc_url="https://help.splunk.com/en/splunk-enterprise/rest-api-reference/9.4/kv-store-endpoints/kv-store-endpoint-descriptions#get-5",
    namespace="tools.splunk",
    secrets=[splunk_secret],
)
async def get_kv_store_collection(
    base_url: Annotated[
        str,
        Field(
            ...,
            description="Splunk base URL (e.g. https://localhost:8089 or https://tracecat.splunkcloud.com:8089).",
        ),
    ],
    collection: Annotated[
        str,
        Field(..., description="Name of the KV Store Collection."),
    ],
    owner: Annotated[
        str,
        Field(..., description="Owner of the KV Store Collection. Default is nobody."),
    ] = "nobody",
    app: Annotated[
        str, Field(..., description="Name of the app. Default is search.")
    ] = "search",
    verify_ssl: Annotated[
        bool, Field(..., description="Whether to verify SSL certificates.")
    ] = True,
) -> dict[str, Any]:
    """Get a KV Store Collection from Splunk."""
    api_key = secrets.get("SPLUNK_API_KEY")
    url = f"{base_url}/servicesNS/{owner}/{app}/storage/collections/config/{collection}"
    headers = {
        "Authorization": f"Bearer {api_key}",
        "Content-Type": "application/json",
        "Accept": "application/json",
    }
    params = {
        "output_mode": "json",
    }
    async with httpx.AsyncClient(verify=verify_ssl) as client:
        response = await client.get(url, headers=headers, params=params)
        response.raise_for_status()
        return response.json()


@registry.register(
    default_title="List KV Store Collections",
    description="List KV Store Collections from Splunk. Uses bearer token authentication.",
    display_group="Splunk",
    doc_url="https://help.splunk.com/en/splunk-enterprise/rest-api-reference/9.4/kv-store-endpoints/kv-store-endpoint-descriptions#get-4",
    namespace="tools.splunk",
    secrets=[splunk_secret],
)
async def list_kv_store_collections(
    base_url: Annotated[
        str,
        Field(
            ...,
            description="Splunk base URL (e.g. https://localhost:8089 or https://tracecat.splunkcloud.com:8089).",
        ),
    ],
    verify_ssl: Annotated[
        bool, Field(..., description="Whether to verify SSL certificates.")
    ] = True,
    owner: Annotated[
        str,
        Field(..., description="Owner of the KV Store Collections. Default is nobody."),
    ] = "nobody",
    app: Annotated[
        str, Field(..., description="Name of the app. Default is search.")
    ] = "search",
    limit: Annotated[
        int, Field(..., description="Maximum number of KV Store Collections to return.")
    ] = 100,
    offset: Annotated[
        int, Field(..., description="Number of KV Store Collections to skip.")
    ] = 0,
    sort_key: Annotated[
        str, Field(..., description="Key to sort by. Default is _key.")
    ] = "_key",
    sort_order: Annotated[
        Literal["asc", "desc"], Field(..., description="Sort order. Default is asc.")
    ] = "asc",
    search: Annotated[
        str,
        Field(
            ...,
            description="Search query to filter collections. Example: 'name=*whitelist*'",
        ),
    ] = "",
    sort_mode: Annotated[
        Literal["auto", "num", "alpha_case", "alpha"],
        Field(..., description="Sort mode. Default is auto."),
    ] = "auto",
    summarize: Annotated[
        bool,
        Field(
            ...,
            description="Summarized response, omitting some index details, providing a faster response. Default is false.",
        ),
    ] = False,
) -> dict[str, Any]:
    """List KV Store Collections from Splunk."""
    api_key = secrets.get("SPLUNK_API_KEY")
    url = f"{base_url}/servicesNS/{owner}/{app}/storage/collections/config"
    headers = {
        "Authorization": f"Bearer {api_key}",
        "Content-Type": "application/json",
        "Accept": "application/json",
    }
    params = {
        "count": limit,
        "offset": offset,
        "sort_key": sort_key,
        "sort_order": sort_order,
        "search": search,
        "sort_mode": sort_mode,
        "summarize": summarize,
        "output_mode": "json",
    }

    async with httpx.AsyncClient(verify=verify_ssl) as client:
        response = await client.get(url, headers=headers, params=params)
        response.raise_for_status()
        return response.json()


@registry.register(
    default_title="List Entries in KV Store Collection",
    description="List entries in a KV Store Collection from Splunk. Uses bearer token authentication.",
    display_group="Splunk",
    doc_url="https://help.splunk.com/en/splunk-enterprise/rest-api-reference/9.4/kv-store-endpoints/kv-store-endpoint-descriptions#get-6",
    namespace="tools.splunk",
    secrets=[splunk_secret],
)
async def list_entries_in_kv_store_collection(
    base_url: Annotated[
        str,
        Field(
            ...,
            description="Splunk base URL (e.g. https://localhost:8089 or https://tracecat.splunkcloud.com:8089).",
        ),
    ],
    collection: Annotated[
        str, Field(..., description="Name of the KV Store Collection.")
    ],
    verify_ssl: Annotated[
        bool, Field(..., description="Whether to verify SSL certificates.")
    ] = True,
    owner: Annotated[
        str,
        Field(..., description="Owner of the KV Store Collections. Default is nobody."),
    ] = "nobody",
    app: Annotated[
        str, Field(..., description="Name of the app. Default is search.")
    ] = "search",
    limit: Annotated[
        int, Field(..., description="Maximum number of entries to return.")
    ] = 100,
    offset: Annotated[int, Field(..., description="Number of entries to skip.")] = 0,
    sort: Annotated[
        str, Field(..., description="Sort order. Default is _key.")
    ] = "_key",
    skip: Annotated[
        int, Field(..., description="Number of items to skip from the start.")
    ] = 0,
    query: Annotated[
        dict[str, Any],
        Field(
            ...,
            description="""Query to filter entries.
        Conditional operators: $gt, $gte, $lt, $lte, and $ne
        Regex operators: $regex
        Logical operators: $and, $or, and ,$not (invert conditional operators)
        Examples:
          - query={"title":"Item"} (Select all documents with property title that has value Item)
          - query={"price":{"$gt":5}} (Select all documents with price greater than 5)
          - query={"ip":{"$regex":"192.168.1.*"}} (Select all documents with ip that matches 192.168.1.*)
        """,
        ),
    ] = {},
    shared: Annotated[
        bool,
        Field(
            ...,
            description="Defaults to false. Set to true to return records for the specified user as well as records for the nobody user.",
        ),
    ] = False,
) -> dict[str, Any]:
    """List entries in a KV Store Collection from Splunk."""
    api_key = secrets.get("SPLUNK_API_KEY")
    url = f"{base_url}/servicesNS/{owner}/{app}/storage/collections/data/{collection}"
    headers = {
        "Authorization": f"Bearer {api_key}",
        "Content-Type": "application/json",
        "Accept": "application/json",
    }
    params = {
        "limit": limit,
        "sort": sort,
        "skip": skip,
        "query": query,
        "shared": shared,
        "offset": offset,
        "output_mode": "json",
    }
    async with httpx.AsyncClient(verify=verify_ssl) as client:
        response = await client.get(url, headers=headers, params=params)
        response.raise_for_status()
        return response.json()


@registry.register(
    default_title="Delete KV Store Collection",
    description="Delete a KV Store Collection from Splunk. Uses bearer token authentication.",
    display_group="Splunk",
    doc_url="https://help.splunk.com/en/splunk-enterprise/rest-api-reference/9.4/kv-store-endpoints/kv-store-endpoint-descriptions#delete-0",
    namespace="tools.splunk",
    secrets=[splunk_secret],
)
async def delete_kv_store_collection(
    base_url: Annotated[
        str,
        Field(
            ...,
            description="Splunk base URL (e.g. https://localhost:8089 or https://tracecat.splunkcloud.com:8089).",
        ),
    ],
    collection: Annotated[
        str, Field(..., description="Name of the KV Store Collection.")
    ],
    verify_ssl: Annotated[
        bool, Field(..., description="Whether to verify SSL certificates.")
    ] = True,
    owner: Annotated[
        str,
        Field(..., description="Owner of the KV Store Collection. Default is nobody."),
    ] = "nobody",
    app: Annotated[
        str, Field(..., description="Name of the app. Default is search.")
    ] = "search",
) -> dict[str, Any]:
    """Delete a KV Store Collection from Splunk."""
    api_key = secrets.get("SPLUNK_API_KEY")
    url = f"{base_url}/servicesNS/{owner}/{app}/storage/collections/config/{collection}"
    headers = {
        "Authorization": f"Bearer {api_key}",
        "Content-Type": "application/json",
        "Accept": "application/json",
    }
    params = {
        "output_mode": "json",
    }
    async with httpx.AsyncClient(verify=verify_ssl) as client:
        response = await client.delete(url, headers=headers, params=params)
        response.raise_for_status()
        # if there is no error, return an dictionary with a success message
        if response.status_code == 200:
            return {"success": True}
        return {"success": False}


@registry.register(
    default_title="Delete Entry from KV Store Collection",
    description="Delete an entry from a KV Store Collection from Splunk. Uses bearer token authentication.",
    display_group="Splunk",
    doc_url="https://help.splunk.com/en/splunk-enterprise/rest-api-reference/9.4/kv-store-endpoints/kv-store-endpoint-descriptions#delete-1",
    namespace="tools.splunk",
    secrets=[splunk_secret],
)
async def delete_entry_from_kv_store_collection(
    base_url: Annotated[
        str,
        Field(
            ...,
            description="Splunk base URL (e.g. https://localhost:8089 or https://tracecat.splunkcloud.com:8089).",
        ),
    ],
    collection: Annotated[
        str, Field(..., description="Name of the KV Store Collection.")
    ],
    entry_key: Annotated[
        str,
        Field(
            ...,
            description="Key of the entry to delete from the KV Store Collection. Example: '1234567890'",
        ),
    ],
    verify_ssl: Annotated[
        bool, Field(..., description="Whether to verify SSL certificates.")
    ] = True,
    owner: Annotated[
        str,
        Field(..., description="Owner of the KV Store Collection. Default is nobody."),
    ] = "nobody",
    app: Annotated[
        str, Field(..., description="Name of the app. Default is search.")
    ] = "search",
) -> dict[str, Any]:
    """Delete an entry from a KV Store Collection from Splunk."""
    api_key = secrets.get("SPLUNK_API_KEY")
    url = f"{base_url}/servicesNS/{owner}/{app}/storage/collections/data/{collection}/{entry_key}"
    headers = {
        "Authorization": f"Bearer {api_key}",
        "Content-Type": "application/json",
        "Accept": "application/json",
    }
    params = {
        "output_mode": "json",
    }

    async with httpx.AsyncClient(verify=verify_ssl) as client:
        response = await client.delete(url, headers=headers, params=params)
        response.raise_for_status()
        # if there is no error, return an dictionary with a success message
        if response.status_code == 200:
            return {"success": True}
        return {"success": False}


@registry.register(
    default_title="Get Entry from KV Store Collection",
    description="Get an entry from a KV Store Collection from Splunk. Uses bearer token authentication.",
    display_group="Splunk",
    doc_url="https://help.splunk.com/en/splunk-enterprise/rest-api-reference/9.4/kv-store-endpoints/kv-store-endpoint-descriptions#get-7",
    namespace="tools.splunk",
    secrets=[splunk_secret],
)
async def get_entry_from_kv_store_collection(
    base_url: Annotated[
        str,
        Field(
            ...,
            description="Splunk base URL (e.g. https://localhost:8089 or https://tracecat.splunkcloud.com:8089).",
        ),
    ],
    collection: Annotated[
        str, Field(..., description="Name of the KV Store Collection.")
    ],
    entry_key: Annotated[
        str,
        Field(..., description="Key of the entry to get from the KV Store Collection."),
    ],
    verify_ssl: Annotated[
        bool, Field(..., description="Whether to verify SSL certificates.")
    ] = True,
    owner: Annotated[
        str,
        Field(..., description="Owner of the KV Store Collection. Default is nobody."),
    ] = "nobody",
    app: Annotated[
        str, Field(..., description="Name of the app. Default is search.")
    ] = "search",
) -> dict[str, Any]:
    """Get an entry from a KV Store Collection from Splunk."""
    api_key = secrets.get("SPLUNK_API_KEY")
    url = f"{base_url}/servicesNS/{owner}/{app}/storage/collections/data/{collection}/{entry_key}"
    headers = {
        "Authorization": f"Bearer {api_key}",
        "Content-Type": "application/json",
        "Accept": "application/json",
    }
    params = {
        "output_mode": "json",
    }
    async with httpx.AsyncClient(verify=verify_ssl) as client:
        response = await client.get(url, headers=headers, params=params)
        response.raise_for_status()
        return response.json()


@registry.register(
    default_title="Update Entry in KV Store Collection",
    description="Update an entry in a KV Store Collection from Splunk. Uses bearer token authentication.",
    display_group="Splunk",
    doc_url="https://help.splunk.com/en/splunk-enterprise/rest-api-reference/9.4/kv-store-endpoints/kv-store-endpoint-descriptions#post-12",
    namespace="tools.splunk",
    secrets=[splunk_secret],
)
async def update_entry_in_kv_store_collection(
    base_url: Annotated[
        str,
        Field(
            ...,
            description="Splunk base URL (e.g. https://localhost:8089 or https://tracecat.splunkcloud.com:8089).",
        ),
    ],
    collection: Annotated[
        str, Field(..., description="Name of the KV Store Collection.")
    ],
    entry_key: Annotated[
        str,
        Field(
            ..., description="Key of the entry to update in the KV Store Collection."
        ),
    ],
    fields: Annotated[
        dict[str, Any],
        Field(
            ...,
            description="Fields to update in the KV Store Collection. Example: {'name': 'John', 'age': 30}",
        ),
    ],
    verify_ssl: Annotated[
        bool, Field(..., description="Whether to verify SSL certificates.")
    ] = True,
    owner: Annotated[
        str,
        Field(..., description="Owner of the KV Store Collection. Default is nobody."),
    ] = "nobody",
    app: Annotated[
        str, Field(..., description="Name of the app. Default is search.")
    ] = "search",
) -> dict[str, Any]:
    """Update an entry in a KV Store Collection from Splunk."""
    api_key = secrets.get("SPLUNK_API_KEY")
    url = f"{base_url}/servicesNS/{owner}/{app}/storage/collections/data/{collection}/{entry_key}"
    headers = {
        "Authorization": f"Bearer {api_key}",
        "Content-Type": "application/json",
        "Accept": "application/json",
    }

    async with httpx.AsyncClient(verify=verify_ssl) as client:
        response = await client.post(url, headers=headers, json=fields)
        response.raise_for_status()
        return response.json()


@registry.register(
    default_title="Add fields to KV Store Collection",
    description="Add fields to KV Store Collections from Splunk. Uses bearer token authentication.",
    display_group="Splunk",
    doc_url="https://help.splunk.com/en/splunk-enterprise/rest-api-reference/9.4/kv-store-endpoints/kv-store-endpoint-descriptions#post-9",
    namespace="tools.splunk",
    secrets=[splunk_secret],
)
async def add_fields_to_kv_store_collection(
    base_url: Annotated[
        str,
        Field(
            ...,
            description="Splunk base URL (e.g. https://localhost:8089 or https://tracecat.splunkcloud.com:8089).",
        ),
    ],
    collection: Annotated[
        str,
        Field(
            ...,
            description="Name of the KV Store Collection. Must be unique and contain only alphanumeric characters, underscores, and hyphens.",
        ),
    ],
    fields: Annotated[
        list[dict[Literal["name", "type"], str]],
        Field(
            ...,
            description="List of fields to add. Should contain a field name and type. Type options are array, number, bool, string, cidr, time. Example: [{'name': 'first_name', 'type': 'string'}, {'name': 'age', 'type': 'number'}]",
        ),
    ],
    verify_ssl: Annotated[
        bool, Field(..., description="Whether to verify SSL certificates.")
    ] = True,
    owner: Annotated[
        str,
        Field(..., description="Owner of the KV Store Collection. Default is nobody."),
    ] = "nobody",
    app: Annotated[
        str, Field(..., description="ame of the app. Default is search.")
    ] = "search",
) -> dict[str, Any]:
    """Create a KV Store Collection in Splunk."""
    # Example Request: https://localhost:8089/servicesNS/nobody/search/storage/collections/config/test -d 'accelerated_fields.foo={"a": 1}' -d 'accelerated_fields.bar={"b": -1}' -d "field.a=number" -d "field.b=cidr"
    api_key = secrets.get("SPLUNK_API_KEY")
    url = f"{base_url}/servicesNS/{owner}/{app}/storage/collections/config/{collection}"
    headers = {
        "Authorization": f"Bearer {api_key}",
        "Content-Type": "application/json",
        "Accept": "application/json",
    }
    payload = {
        "output_mode": "json",
    }
    # Fields in Splunk are stored in field.name=type
    for field in fields:
        payload[f"field.{field['name']}"] = field["type"]

    async with httpx.AsyncClient(verify=verify_ssl) as client:
        response = await client.post(url, headers=headers, data=payload)
        response.raise_for_status()
        return response.json()


@registry.register(
    default_title="Submit Event to Splunk with HEC",
    description="Submit an event to Splunk. Uses HEC and HEC token authentication.",
    display_group="Splunk",
    doc_url="https://help.splunk.com/en/splunk-enterprise/get-data-in/get-started-with-getting-data-in/9.4/get-data-with-http-event-collector/format-events-for-http-event-collector",
    namespace="tools.splunk",
    secrets=[splunk_hec_secret],
)
async def submit_event_to_splunk(
    base_url: Annotated[
        str,
        Field(
            ...,
            description="Splunk base URL (e.g. https://localhost:8088 or https://tracecat.splunkcloud.com:8088).",
        ),
    ],
    event: Annotated[
        dict[str, Any],
        Field(
            ...,
            description="Event to push to Splunk. Example: {'title': 'Item', 'price': 5}",
        ),
    ],
    index: Annotated[
        str | None,
        Field(..., description="Index to push the event to."),
    ] = None,
    source: Annotated[
        str,
        Field(..., description="Source of the event. Default is tracecat_workflow."),
    ] = "tracecat_workflow",
    sourcetype: Annotated[
        str,
        Field(..., description="Source type of the event. Default is tracecat_log."),
    ] = "tracecat_log",
    host: Annotated[
        str,
        Field(..., description="Host of the event. Default is tracecat.com."),
    ] = "tracecat.com",
    verify_ssl: Annotated[
        bool, Field(..., description="Whether to verify SSL certificates.")
    ] = True,
) -> dict[str, Any]:
    """Push an event to Splunk over HEC."""
    # Example Request: https://localhost:8089/services/collector/event -d '{"title": "Item", "price": 5}' -d 'index=main' -d 'source=tracecat_workflow' -d 'sourcetype=tracecat_log' -d 'host=tracecat.com'
    hec_token = secrets.get("SPLUNK_HEC_TOKEN")
    url = f"{base_url}/services/collector/event"
    headers = {
        "Content-Type": "application/json",
        "Accept": "application/json",
        "Authorization": f"Splunk {hec_token}",
    }
    payload = {
        "index": index,
        "source": source,
        "sourcetype": sourcetype,
        "host": host,
        "event": event,
    }

    async with httpx.AsyncClient(verify=verify_ssl) as client:
        response = await client.post(url, headers=headers, json=payload)
        response.raise_for_status()
        return response.json()
