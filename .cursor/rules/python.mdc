---
description:
globs: *.py
alwaysApply: false
---
---
globs: *.py
---
- Always use python 3.11+ type hints. This means prefer using builtin types (e.g. `list`, `dict`, `set`) for type hints over the equivalent types from the `typing` module.
- Always follow the Google Python style guide
- Always put imports at the top of the file. Do not use scoped imports unless strictly necessary.
- **CRITICAL: tests/unit/ contains INTEGRATION TESTS, not unit tests!** These tests use real database connections and test actual service interactions. Never assume these are isolated unit tests.
- Always use `uv run` to execute python and `pytest` in the CLI.
- Always use `uv pip install` to install pip packages.

## Testing Services and Routes - Best Practices

### IMPORTANT: Integration Testing Approach
Tests in `tests/unit/` are **INTEGRATION TESTS** that:
- Use **real database connections** with transaction isolation
- Test **actual service interactions** without mocking internal components
- Run as close to production behavior as possible
- Only mock external dependencies (OAuth providers, external APIs)

### Service Testing Pattern
```python
# 1. Always mark module with database fixture
pytestmark = pytest.mark.usefixtures("db")

# 2. Create service fixture with real session and role
@pytest.fixture
async def service(session: AsyncSession, svc_role: Role) -> ServiceClass:
    return ServiceClass(session=session, role=svc_role)

# 3. Test with real database operations
@pytest.mark.anyio
class TestServiceName:
    async def test_create_and_get(self, service, create_params):
        # Create real database object
        created = await service.create_item(create_params)
        assert created.id is not None

        # Retrieve from actual database
        retrieved = await service.get_item(created.id)
        assert retrieved.field == create_params.field
```

### Required Fixtures for Service Tests
- `session: AsyncSession` - Database session with transaction isolation
- `svc_role: Role` - Service role with workspace context
- `svc_workspace: Workspace` - Test workspace
- `svc_admin_role: Role` - Admin role for elevated permission tests

### Testing Authorization
Always test that services require workspace context:
```python
async def test_init_requires_workspace(session: AsyncSession):
    role_without_workspace = Role(workspace_id=None, ...)
    with pytest.raises(TracecatAuthorizationError):
        ServiceClass(session=session, role=role_without_workspace)
```

### Route/API Testing
When to test API routes vs services:
- **Service Layer (Primary)**: Test business logic, database operations, authorization
- **API Layer (Secondary)**: Test middleware, HTTP behavior, serialization

API Route Testing Pattern:
```python
from fastapi import FastAPI
from fastapi.testclient import TestClient

@pytest.fixture
def test_app() -> FastAPI:
    app = FastAPI()
    app.add_middleware(YourMiddleware)
    # Define test routes
    return app

@pytest.fixture
def client(test_app) -> TestClient:
    return TestClient(test_app)

def test_endpoint(client: TestClient):
    response = client.get("/test")
    assert response.status_code == 200
```

Use API tests for:
- Middleware behavior (auth cache, rate limiting)
- Request/response serialization
- HTTP status codes
- Integration between middleware layers

### DO NOT:
- ❌ Mock database operations or SQLModel objects
- ❌ Mock service methods unless testing external integrations
- ❌ Use `@pytest.mark.asyncio` (use `@pytest.mark.anyio` instead)
- ❌ Create isolated "unit" tests - embrace integration testing
- ❌ Test complex business logic through API routes (test services directly)

### DO:
- ✅ Use real database with transaction rollback for isolation
- ✅ Test actual persistence and retrieval
- ✅ Create real database objects in fixtures
- ✅ Test error cases with actual database constraints
- ✅ Mock only external dependencies (OAuth, external APIs)
- ✅ Verify authorization and workspace requirements
- ✅ Test service layer for business logic
- ✅ Test API routes for middleware and HTTP behavior using TestClient
- ✅ Use FastAPI TestClient when testing endpoints directly

### Common Mistakes to Avoid
1. **Assuming tests/unit/ contains unit tests** - They are integration tests!
2. **Mocking database calls** - Use real database with transactions
3. **Testing routes directly** - Test service layer instead
4. **Forgetting workspace context** - All services need workspace_id
5. **Using wrong async decorator** - Use @pytest.mark.anyio, not asyncio
