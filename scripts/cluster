#!/usr/bin/env bash
#
# Tracecat multi-cluster management script
#
# Usage:
#   ./cluster [cluster_num] [-p profile] <command> [args...]
#
# Profiles:
#   dev     docker-compose.dev.yml (default)
#   local   docker-compose.local.yml
#   prod    docker-compose.yml
#
# Examples:
#   ./cluster up -d                # Start next available cluster (auto-selects number)
#   ./cluster down                 # Stop cluster (auto-selects if only one running)
#   ./cluster restart api          # Restart the api service
#   ./cluster 2 up -d              # Start cluster 2 explicitly
#   ./cluster 2 -p local up -d     # Start cluster 2 with local profile
#   ./cluster ps                   # Show containers (auto-selects cluster)
#   ./cluster logs api             # Show logs (auto-selects cluster)
#   ./cluster attach api           # Attach shell to api service
#   ./cluster list                 # List all running clusters
#   ./cluster 1 ports              # Show port mappings for cluster 1
#
# Port allocation (offset = (cluster_num - 1) * 100):
#   Cluster numbers are GLOBAL across all worktrees to avoid port conflicts.
#   Cluster 1: 80, 3000, 5432, 6379, 7233, 8000, 8081, 8099, 9000, 9001
#   Cluster 2: 180, 3100, 5532, 6479, 7333, 8100, 8181, 8199, 9100, 9101
#   Cluster 3: 280, 3200, 5632, 6579, 7433, 8200, 8281, 8299, 9200, 9201
#   ...

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd "${SCRIPT_DIR}/.." && pwd)"
ENV_FILE="${REPO_ROOT}/.env"

# Default profile
PROFILE="dev"

# Get worktree identifier for namespacing clusters
# Returns "main" for the main worktree, or a sanitized branch/directory name for worktrees
get_worktree_id() {
    local git_dir git_common_dir

    git_dir=$(git -C "${REPO_ROOT}" rev-parse --git-dir 2>/dev/null) || { echo "main"; return; }
    git_common_dir=$(git -C "${REPO_ROOT}" rev-parse --git-common-dir 2>/dev/null) || { echo "main"; return; }

    # Resolve to absolute paths for comparison
    git_dir=$(cd "${REPO_ROOT}" && cd "${git_dir}" && pwd)
    git_common_dir=$(cd "${REPO_ROOT}" && cd "${git_common_dir}" && pwd)

    if [[ "$git_dir" == "$git_common_dir" ]]; then
        # Main worktree
        echo "main"
    else
        # In a worktree - use branch name, sanitized
        local branch
        branch=$(git -C "${REPO_ROOT}" rev-parse --abbrev-ref HEAD 2>/dev/null) || branch="unknown"
        # Sanitize: replace slashes and special chars with dashes, lowercase
        echo "$branch" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9-]/-/g' | sed 's/--*/-/g' | sed 's/^-//;s/-$//'
    fi
}

WORKTREE_ID=$(get_worktree_id)

# Get list of running cluster numbers for this worktree (used for auto-selection)
get_running_clusters() {
    local prefix="tracecat-${WORKTREE_ID}-"

    docker compose ls --format json 2>/dev/null | jq -r '.[].Name' 2>/dev/null | while read -r project; do
        if [[ "$project" == ${prefix}* ]]; then
            local num="${project#$prefix}"
            if [[ "$num" =~ ^[0-9]+$ ]]; then
                echo "$num"
            fi
        fi
    done | sort -n
}

# Get ALL running cluster numbers across all worktrees (used for port allocation)
get_all_cluster_nums() {
    local projects
    projects=$(docker compose ls --format json 2>/dev/null | jq -r '.[].Name' 2>/dev/null)

    for project in $projects; do
        # Match any tracecat cluster: tracecat-{worktree}-{num}
        if [[ "$project" =~ ^tracecat-(.+)-([0-9]+)$ ]]; then
            echo "${BASH_REMATCH[2]}"
        fi
    done | sort -n | uniq
}

# Find next available cluster number (globally, to avoid port conflicts)
get_next_cluster_num() {
    local running
    running=$(get_all_cluster_nums)

    if [[ -z "$running" ]]; then
        echo "1"
        return
    fi

    # Find first gap or next number
    local expected=1
    while read -r num; do
        if [[ "$num" -gt "$expected" ]]; then
            echo "$expected"
            return
        fi
        expected=$((num + 1))
    done <<< "$running"

    echo "$expected"
}

# Auto-select cluster: returns the only running cluster, or errors if multiple/none
auto_select_cluster() {
    local command=$1
    local running
    running=$(get_running_clusters)

    # Count non-empty lines
    local count=0
    if [[ -n "$running" ]]; then
        count=$(echo "$running" | wc -l | tr -d ' ')
    fi

    if [[ "$count" -eq 0 ]]; then
        if [[ "$command" == "up" ]]; then
            echo "1"
        else
            echo "Error: No clusters running for worktree '${WORKTREE_ID}'" >&2
            echo "Run 'just cluster up -d' to start one" >&2
            exit 1
        fi
    elif [[ "$count" -eq 1 ]]; then
        echo "$running"
    else
        echo "Error: Multiple clusters running for worktree '${WORKTREE_ID}':" >&2
        echo "$running" | while read -r num; do
            calculate_ports "$num"
            echo "  ${num}: http://localhost:${PUBLIC_APP_PORT}" >&2
        done
        echo "Please specify a cluster number" >&2
        exit 1
    fi
}

# Base ports (cluster 1 defaults)
BASE_PUBLIC_APP_PORT=80
BASE_UI_PORT=3000
BASE_PG_PORT=5432
BASE_REDIS_PORT=6379
BASE_TEMPORAL_PORT=7233
BASE_API_PORT=8000
BASE_TEMPORAL_UI_PORT=8081
BASE_MINIO_PORT=9000
BASE_MINIO_CONSOLE_PORT=9001
BASE_MCP_PORT=8099

# Map profile to compose file
get_compose_file() {
    local profile=$1
    case "$profile" in
        dev)
            echo "${REPO_ROOT}/docker-compose.dev.yml"
            ;;
        local)
            echo "${REPO_ROOT}/docker-compose.local.yml"
            ;;
        prod)
            echo "${REPO_ROOT}/docker-compose.yml"
            ;;
        *)
            echo "Error: Unknown profile '$profile'. Valid profiles: dev, local, prod" >&2
            exit 1
            ;;
    esac
}

usage() {
    cat <<EOF
Usage: ./cluster [cluster_num] [-p profile] <command> [args...]
       ./cluster list

Cluster number is optional:
  - For 'up': auto-selects next available number
  - For other commands: auto-selects if only one cluster running

Profiles:
  dev       docker-compose.dev.yml (default)
  local     docker-compose.local.yml
  prod      docker-compose.yml

Commands:
  up [args]     Start the cluster (e.g., up -d)
                Use --seed to auto-register test@tracecat.com:password1234
  down          Stop the cluster (keeps volumes)
  rm            Remove the cluster (down + remove volumes)
  restart [svc] Restart the cluster or specific service
  ps            Show running containers
  logs [svc]    Show logs (optionally for specific service)
  attach <svc>  Attach to a running service container (e.g., attach api)
  db            Open lazysql to the cluster's PostgreSQL database
  ports         Show port mappings for the cluster
  list          List all running Tracecat clusters
  nuke [opts]   Destroy cluster and optionally volumes/images

Nuke options:
  nuke                  Stop cluster and remove volumes
  nuke --images         Also remove images
  nuke --dry-run        Show what would be deleted
  nuke <service>        Remove specific service volume (e.g., nuke minio)
  nuke volumes          List and select volumes to remove

Examples:
  ./cluster up -d                Start next available cluster
  ./cluster up -d --seed         Start cluster and register test user
  ./cluster down                 Stop cluster (keeps volumes)
  ./cluster rm                   Remove cluster and volumes
  ./cluster restart api          Restart the api service
  ./cluster 2 up -d              Start cluster 2 explicitly
  ./cluster 2 -p local up -d     Start cluster 2 with local profile
  ./cluster attach api           Attach shell to api service
  ./cluster db                   Open lazysql to the database
  ./cluster list                 List all clusters
  ./cluster nuke                 Destroy cluster and volumes (interactive)
  ./cluster nuke minio           Remove only minio volume
  ./cluster nuke --images        Destroy cluster, volumes, and images

Current worktree: ${WORKTREE_ID}
EOF
    exit 0
}

# Calculate ports for a given cluster number
calculate_ports() {
    local cluster_num=$1
    local offset=$(( (cluster_num - 1) * 100 ))

    PUBLIC_APP_PORT=$(( BASE_PUBLIC_APP_PORT + offset ))
    UI_PORT=$(( BASE_UI_PORT + offset ))
    PG_PORT=$(( BASE_PG_PORT + offset ))
    REDIS_PORT_HOST=$(( BASE_REDIS_PORT + offset ))
    TEMPORAL_PORT=$(( BASE_TEMPORAL_PORT + offset ))
    API_PORT=$(( BASE_API_PORT + offset ))
    TEMPORAL_UI_PORT=$(( BASE_TEMPORAL_UI_PORT + offset ))
    MINIO_PORT=$(( BASE_MINIO_PORT + offset ))
    MINIO_CONSOLE_PORT=$(( BASE_MINIO_CONSOLE_PORT + offset ))
    MCP_PORT=$(( BASE_MCP_PORT + offset ))
}

# Build environment variables for docker compose
build_env() {
    local cluster_num=$1
    calculate_ports "$cluster_num"

    # URLs that depend on ports (respect .env overrides)
    local PUBLIC_APP_URL="${PUBLIC_APP_URL:-http://localhost:${PUBLIC_APP_PORT}}"
    local PUBLIC_API_URL="${PUBLIC_API_URL:-${PUBLIC_APP_URL}/api}"

    # Export all variables (include worktree ID for isolation)
    export COMPOSE_PROJECT_NAME="tracecat-${WORKTREE_ID}-${cluster_num}"
    export PUBLIC_APP_PORT
    export PUBLIC_APP_URL
    export PUBLIC_API_URL
    export UI_PORT
    export PG_PORT
    export REDIS_PORT_HOST
    export TEMPORAL_PORT
    export API_PORT
    export TEMPORAL_UI_PORT
    export MINIO_PORT
    export MINIO_CONSOLE_PORT
    export MCP_PORT

    # URL variables that reference the public port (respect .env overrides)
    export TRACECAT__PUBLIC_APP_URL="${TRACECAT__PUBLIC_APP_URL:-${PUBLIC_APP_URL}}"
    export TRACECAT__PUBLIC_API_URL="${TRACECAT__PUBLIC_API_URL:-${PUBLIC_API_URL}}"
    export NEXT_PUBLIC_APP_URL="${NEXT_PUBLIC_APP_URL:-${PUBLIC_APP_URL}}"
    export NEXT_PUBLIC_API_URL="${NEXT_PUBLIC_API_URL:-${PUBLIC_APP_URL}/api}"

    # Caddy configuration
    export BASE_DOMAIN=":${PUBLIC_APP_PORT}"

    # Default to direct executor backend for development
    export TRACECAT__EXECUTOR_BACKEND="${TRACECAT__EXECUTOR_BACKEND:-direct}"

    # Enable multitenancy and all feature flags for development
    export TRACECAT__EE_MULTI_TENANT=true
    FEATURE_FLAGS=$(cd "$REPO_ROOT" && uv run python -c "from tracecat.feature_flags.enums import FeatureFlag; print(','.join(f.value for f in FeatureFlag))" 2>/dev/null) || FEATURE_FLAGS=""
    if [[ -n "$FEATURE_FLAGS" ]]; then
        export TRACECAT__FEATURE_FLAGS="$FEATURE_FLAGS"
    fi
}

# Show port mappings for a cluster
show_ports() {
    local cluster_num=$1
    calculate_ports "$cluster_num"

    cat <<EOF
Cluster ${WORKTREE_ID}-${cluster_num} port mappings:
  UI (Caddy):      http://localhost:${PUBLIC_APP_PORT}
  API:             http://localhost:${PUBLIC_APP_PORT}/api (internal: ${API_PORT})
  PostgreSQL:      localhost:${PG_PORT}
  Redis:           localhost:${REDIS_PORT_HOST}
  Temporal:        localhost:${TEMPORAL_PORT}
  Temporal UI:     http://localhost:${TEMPORAL_UI_PORT}
  MinIO:           localhost:${MINIO_PORT}
  MinIO Console:   http://localhost:${MINIO_CONSOLE_PORT}
  MCP:             http://localhost:${MCP_PORT}
EOF
}

# List all running Tracecat clusters
list_clusters() {
    echo "Running Tracecat clusters (worktree: ${WORKTREE_ID}):"
    echo ""

    local found=false
    local current_worktree_prefix="tracecat-${WORKTREE_ID}-"

    for project in $(docker compose ls --format json 2>/dev/null | jq -r '.[].Name' 2>/dev/null || docker compose ls -q 2>/dev/null); do
        # Match any tracecat cluster: tracecat-{worktree}-{num}
        if [[ "$project" =~ ^tracecat-(.+)-([0-9]+)$ ]]; then
            found=true
            local worktree="${BASH_REMATCH[1]}"
            local cluster_num="${BASH_REMATCH[2]}"
            calculate_ports "$cluster_num"
            local status
            status=$(docker compose -p "$project" ps --format json 2>/dev/null | jq -r 'if type == "array" then .[0].State else .State end' 2>/dev/null || echo "unknown")
            local marker=""
            [[ "$project" == "${current_worktree_prefix}${cluster_num}" ]] && marker=" (this worktree)"
            echo "  ${project}: http://localhost:${PUBLIC_APP_PORT}${marker}"
        fi
    done

    if [[ "$found" == "false" ]]; then
        echo "  No clusters running"
    fi
}

# Main
if [[ $# -lt 1 ]]; then
    usage
fi

# Handle 'list' command specially
if [[ "$1" == "list" ]]; then
    list_clusters
    exit 0
fi

# Check if first arg is a cluster number or a command/flag
CLUSTER_NUM=""
AUTO_SELECT=true

if [[ "$1" =~ ^[0-9]+$ ]]; then
    # First arg is a number
    CLUSTER_NUM="$1"
    AUTO_SELECT=false
    if [[ "$CLUSTER_NUM" -lt 1 ]] || [[ "$CLUSTER_NUM" -gt 99 ]]; then
        echo "Error: Cluster number must be between 1 and 99"
        exit 1
    fi
    shift
fi

if [[ $# -lt 1 ]]; then
    usage
fi

# Parse optional -p/--profile flag
if [[ "$1" == "-p" ]] || [[ "$1" == "--profile" ]]; then
    if [[ $# -lt 2 ]]; then
        echo "Error: -p/--profile requires a profile name"
        exit 1
    fi
    PROFILE="$2"
    shift 2
fi

if [[ $# -lt 1 ]]; then
    usage
fi

COMMAND="$1"
shift

# Auto-select cluster number if not specified
if [[ "$AUTO_SELECT" == "true" ]]; then
    if [[ "$COMMAND" == "up" ]]; then
        CLUSTER_NUM=$(get_next_cluster_num)
        echo "Auto-selected cluster ${CLUSTER_NUM} (global) for worktree '${WORKTREE_ID}'"
    elif [[ "$COMMAND" == "nuke" ]]; then
        # For nuke, try to find any cluster (running or with leftover volumes)
        CLUSTER_NUM=$(get_running_clusters | head -1)
        if [[ -z "$CLUSTER_NUM" ]]; then
            # No running cluster, check for orphaned volumes
            ORPHAN_VOLUME=$(docker volume ls --format "{{.Name}}" | grep "^tracecat-${WORKTREE_ID}-" | head -1 || true)
            if [[ -n "$ORPHAN_VOLUME" && "$ORPHAN_VOLUME" =~ ^tracecat-${WORKTREE_ID}-([0-9]+)_ ]]; then
                CLUSTER_NUM="${BASH_REMATCH[1]}"
                echo "Found orphaned volumes for cluster ${CLUSTER_NUM}"
            else
                CLUSTER_NUM="1"
                echo "No clusters or volumes found, defaulting to cluster 1"
            fi
        fi
    else
        CLUSTER_NUM=$(auto_select_cluster "$COMMAND")
    fi
fi

# Get compose file for profile
COMPOSE_FILE=$(get_compose_file "$PROFILE")

# Handle 'ports' command
if [[ "$COMMAND" == "ports" ]]; then
    show_ports "$CLUSTER_NUM"
    exit 0
fi

# Handle 'db' command - open TablePlus to postgres
if [[ "$COMMAND" == "db" ]]; then
    if [[ ! -d "/Applications/TablePlus.app" ]]; then
        echo "Error: TablePlus is not installed" >&2
        echo "Install from: https://tableplus.com or brew install --cask tableplus" >&2
        exit 1
    fi

    # Source .env for credentials if it exists
    if [[ -f "$ENV_FILE" ]]; then
        set -a
        # shellcheck disable=SC1090
        source "$ENV_FILE"
        set +a
    fi

    calculate_ports "$CLUSTER_NUM"
    pg_user="${TRACECAT__POSTGRES_USER:-postgres}"
    pg_pass="${TRACECAT__POSTGRES_PASSWORD:-postgres}"

    echo "Opening TablePlus for cluster ${WORKTREE_ID}-${CLUSTER_NUM} (port ${PG_PORT})..."
    open -a TablePlus "postgresql://${pg_user}:${pg_pass}@localhost:${PG_PORT}/postgres?sslmode=disable"
    exit 0
fi

# Handle 'attach' command
if [[ "$COMMAND" == "attach" ]]; then
    if [[ $# -lt 1 ]]; then
        echo "Error: attach requires a service name (e.g., attach api)"
        exit 1
    fi
    SERVICE="$1"
    shift
    build_env "$CLUSTER_NUM"

    # Try bash first, fall back to sh
    exec docker compose -f "$COMPOSE_FILE" -p "tracecat-${WORKTREE_ID}-${CLUSTER_NUM}" exec "$SERVICE" /bin/bash "$@" 2>/dev/null \
        || exec docker compose -f "$COMPOSE_FILE" -p "tracecat-${WORKTREE_ID}-${CLUSTER_NUM}" exec "$SERVICE" /bin/sh "$@"
fi

# Handle 'restart' command
if [[ "$COMMAND" == "restart" ]]; then
    build_env "$CLUSTER_NUM"
    exec docker compose -f "$COMPOSE_FILE" -p "tracecat-${WORKTREE_ID}-${CLUSTER_NUM}" restart "$@"
fi

# Handle 'rm' command - down + remove volumes
if [[ "$COMMAND" == "rm" ]]; then
    build_env "$CLUSTER_NUM"
    exec docker compose -f "$COMPOSE_FILE" -p "tracecat-${WORKTREE_ID}-${CLUSTER_NUM}" down --volumes --remove-orphans "$@"
fi

# Handle 'nuke' command - destroy cluster and optionally volumes/images
if [[ "$COMMAND" == "nuke" ]]; then
    build_env "$CLUSTER_NUM"
    PROJECT_NAME="tracecat-${WORKTREE_ID}-${CLUSTER_NUM}"

    # Parse nuke options
    NUKE_IMAGES=false
    DRY_RUN=false
    TARGET_SERVICE=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --images)
                NUKE_IMAGES=true
                shift
                ;;
            --dry-run)
                DRY_RUN=true
                shift
                ;;
            volumes)
                # List volumes for this project (exact prefix match)
                echo "Volumes for ${PROJECT_NAME}:"
                docker volume ls --filter "name=${PROJECT_NAME}" --format "{{.Name}}" | grep "^${PROJECT_NAME}_" | sed 's/^/  /' || echo "  (none)"
                exit 0
                ;;
            *)
                TARGET_SERVICE="$1"
                shift
                ;;
        esac
    done

    # Get all volumes for this project (exact prefix match to avoid cluster1 matching cluster10)
    get_project_volumes() {
        docker volume ls --filter "name=${PROJECT_NAME}" --format "{{.Name}}" | grep "^${PROJECT_NAME}_" || true
    }

    # Get volume for a specific service
    get_service_volume() {
        local service=$1
        docker volume ls --filter "name=${PROJECT_NAME}" --format "{{.Name}}" | grep "^${PROJECT_NAME}_" | grep -i "${service}" || true
    }

    if [[ -n "$TARGET_SERVICE" ]]; then
        # Nuke specific service volume
        VOLUMES=$(get_service_volume "$TARGET_SERVICE")
        if [[ -z "$VOLUMES" ]]; then
            echo "No volumes found matching '${TARGET_SERVICE}' for ${PROJECT_NAME}"
            echo ""
            echo "Available volumes:"
            get_project_volumes | sed 's/^/  /'
            exit 1
        fi

        echo "Volumes to remove:"
        echo "$VOLUMES" | sed 's/^/  /'

        if [[ "$DRY_RUN" == "true" ]]; then
            echo ""
            echo "[dry-run] Would remove the above volumes"
            exit 0
        fi

        echo ""
        read -p "Remove these volumes? [y/N] " -n 1 -r
        echo ""
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            echo "$VOLUMES" | xargs docker volume rm
            echo "Done."
        else
            echo "Aborted."
        fi
        exit 0
    fi

    # Full nuke
    echo "=== NUKE: ${PROJECT_NAME} ==="
    echo ""
    echo "This will destroy:"
    echo "  - All containers"
    echo "  - All volumes:"
    get_project_volumes | sed 's/^/      /'

    if [[ "$NUKE_IMAGES" == "true" ]]; then
        echo "  - All images (built for this project)"
    fi

    if [[ "$DRY_RUN" == "true" ]]; then
        echo ""
        echo "[dry-run] Would execute the above"
        exit 0
    fi

    echo ""
    read -p "Are you sure? This cannot be undone. [y/N] " -n 1 -r
    echo ""
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        echo "Aborted."
        exit 0
    fi

    echo ""
    echo "Stopping containers..."
    docker compose -f "$COMPOSE_FILE" -p "$PROJECT_NAME" down --remove-orphans

    echo ""
    echo "Removing volumes..."
    VOLUMES=$(get_project_volumes)
    if [[ -n "$VOLUMES" ]]; then
        echo "$VOLUMES" | xargs docker volume rm
    fi

    if [[ "$NUKE_IMAGES" == "true" ]]; then
        echo ""
        echo "Removing images..."
        # Get images built for this project (tagged with project name)
        IMAGES=$(docker images --format "{{.Repository}}:{{.Tag}}" | grep "^${PROJECT_NAME}" || true)
        if [[ -n "$IMAGES" ]]; then
            echo "$IMAGES" | xargs docker rmi -f
        else
            echo "  No project-specific images found"
        fi
    fi

    echo ""
    echo "=== NUKE COMPLETE ==="
    exit 0
fi

# Build environment and run docker compose
build_env "$CLUSTER_NUM"

# Auto-create .env from .env.example if not present
ENV_SCRIPT="${REPO_ROOT}/env.sh"
if [[ ! -f "$ENV_FILE" ]] && [[ -f "$ENV_SCRIPT" ]]; then
    echo "No .env file found. Running env.sh to create one with dev defaults..."
    # Pass dev defaults: production=n, url=localhost, ssl=n, email=test@tracecat.com
    (cd "$REPO_ROOT" && bash "$ENV_SCRIPT" <<< $'n\n\nn\ntest@tracecat.com')

    # Auto-populate all feature flags for dev environment
    FEATURE_FLAGS=$(cd "$REPO_ROOT" && uv run python -c "from tracecat.feature_flags.enums import FeatureFlag; print(','.join(f.value for f in FeatureFlag))" 2>/dev/null) || FEATURE_FLAGS=""
    if [[ -n "$FEATURE_FLAGS" ]]; then
        echo "TRACECAT__FEATURE_FLAGS=${FEATURE_FLAGS}" >> "$ENV_FILE"
        echo "Enabled all feature flags: $FEATURE_FLAGS"
    fi
fi

# Source the .env file for other variables (but our exports take precedence)
if [[ -f "$ENV_FILE" ]]; then
    set -a
    # shellcheck disable=SC1090
    source "$ENV_FILE"
    set +a
    # Re-apply our overrides (source may have overwritten them)
    build_env "$CLUSTER_NUM"
fi

# Sync dependencies before starting cluster
if [[ "$COMMAND" == "up" ]]; then
    echo "Syncing dependencies..."
    (cd "$REPO_ROOT" && uv sync --group admin --quiet)
    (cd "$REPO_ROOT" && pnpm -C frontend install > /dev/null 2>&1)
fi

# Check for --seed flag in up command
SEED_USER=false
UP_ARGS=()
if [[ "$COMMAND" == "up" ]]; then
    for arg in "$@"; do
        if [[ "$arg" == "--seed" ]]; then
            SEED_USER=true
        else
            UP_ARGS+=("$arg")
        fi
    done
    set -- ${UP_ARGS[@]+"${UP_ARGS[@]}"}
fi

# Function to seed test user after cluster starts
seed_test_user() {
    local api_url="http://localhost:${PUBLIC_APP_PORT}/api"
    local max_attempts=60
    local attempt=1

    echo "Waiting for API to be ready..."
    while [[ $attempt -le $max_attempts ]]; do
        # Use /ready endpoint which checks full startup completion (not /health which returns immediately)
        local status_code
        status_code=$(curl -s -o /dev/null -w "%{http_code}" "${api_url}/ready" 2>/dev/null || echo "000")
        if [[ "$status_code" == "200" ]]; then
            echo "API is ready"
            break
        fi
        sleep 2
        attempt=$((attempt + 1))
    done

    if [[ $attempt -gt $max_attempts ]]; then
        echo "Warning: API did not become ready in time, skipping user registration"
        return 1
    fi

    echo "Registering test user (test@tracecat.com)..."
    local response
    response=$(curl -s -w "\n%{http_code}" -X POST "${api_url}/auth/register" \
        -H "Content-Type: application/json" \
        -d '{"email": "test@tracecat.com", "password": "password1234"}')

    local http_code
    http_code=$(echo "$response" | tail -n1)
    local body
    body=$(echo "$response" | sed '$d')

    case "$http_code" in
        201)
            echo "Successfully registered test user"
            ;;
        400|409)
            echo "Test user already exists"
            ;;
        *)
            echo "Warning: Registration returned status $http_code: $body"
            ;;
    esac
}

# Run docker compose with the configured environment
if [[ "$SEED_USER" == "true" && "$COMMAND" == "up" ]]; then
    # Run in background mode for seeding, then seed
    docker compose -f "$COMPOSE_FILE" -p "tracecat-${WORKTREE_ID}-${CLUSTER_NUM}" "$COMMAND" "$@"
    seed_test_user
else
    exec docker compose -f "$COMPOSE_FILE" -p "tracecat-${WORKTREE_ID}-${CLUSTER_NUM}" "$COMMAND" "$@"
fi
