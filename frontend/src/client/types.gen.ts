// This file is auto-generated by @hey-api/openapi-ts

/**
 * Access control levels for roles.
 */
export type AccessLevel = 0 | 999

export type ActionControlFlow = {
  run_if?: string | null
  for_each?: string | Array<string> | null
  join_strategy?: JoinStrategy
  retry_policy?: ActionRetryPolicy
  /**
   * Delay before starting the action in seconds. If `wait_until` is also provided, the `wait_until` timer will take precedence.
   */
  start_delay?: number
  /**
   * Wait until a specific date and time before starting. Overrides `start_delay` if both are provided.
   */
  wait_until?: string | null
  /**
   * Override environment for this action's execution
   */
  environment?: string | null
}

export type ActionCreate = {
  workflow_id: string
  type: string
  title: string
  description?: string
  inputs?: string
  control_flow?: ActionControlFlow | null
  is_interactive?: boolean
  interaction?: ResponseInteraction | ApprovalInteraction | null
  position_x?: number
  position_y?: number
  upstream_edges?: Array<ActionEdge>
}

/**
 * Represents an incoming edge to an action.
 *
 * Stored in Action.upstream_edges to represent incoming connections.
 */
export type ActionEdge = {
  source_id: string
  source_type: "trigger" | "udf"
  source_handle?: "success" | "error"
}

export type source_type = "trigger" | "udf"

export type source_handle = "success" | "error"

/**
 * Position update for a single action.
 */
export type ActionPositionUpdate = {
  action_id: string
  position: Position
}

export type ActionRead = {
  id: string
  type: string
  title: string
  description: string
  status: string
  inputs: string
  control_flow?: ActionControlFlow
  is_interactive: boolean
  interaction?: ResponseInteraction | ApprovalInteraction | null
  position_x?: number
  position_y?: number
  upstream_edges?: Array<ActionEdge>
  readonly ref: string
}

export type ActionReadMinimal = {
  id: string
  workflow_id: string
  type: string
  title: string
  description: string
  status: string
  is_interactive: boolean
}

export type ActionRetryPolicy = {
  /**
   * Total number of execution attempts. 0 means unlimited, 1 means no retries.
   */
  max_attempts?: number
  /**
   * Timeout for the action in seconds.
   */
  timeout?: number
  /**
   * Retry until a specific condition is met.
   */
  retry_until?: string | null
}

export type ActionStatement = {
  /**
   * Unique reference for the task
   */
  ref: string
  description?: string
  /**
   * Action type. Equivalent to the UDF key.
   */
  action: string
  /**
   * Arguments for the action
   */
  args?: {
    [key: string]: unknown
  }
  /**
   * Task dependencies
   */
  depends_on?: Array<string>
  /**
   * Whether the action is interactive.
   */
  interaction?: ResponseInteraction | ApprovalInteraction | null
  /**
   * Condition to run the task
   */
  run_if?: string | null
  /**
   * Iterate over a list of items and run the task for each item.
   */
  for_each?: string | Array<string> | null
  /**
   * Retry policy for the action.
   */
  retry_policy?: ActionRetryPolicy
  /**
   * Delay before starting the action in seconds. If `wait_until` is also provided, the `wait_until` timer will take precedence.
   */
  start_delay?: number
  /**
   * Wait until a specific date and time before starting. Overrides `start_delay` if both are provided.
   */
  wait_until?: string | null
  /**
   * The strategy to use when joining on this task. By default, all branches must complete successfully before the join task can complete.
   */
  join_strategy?: JoinStrategy
  /**
   * Override environment for this action's execution. Can be a template expression.
   */
  environment?: string | null
}

export type ActionStep = {
  /**
   * The reference of the step
   */
  ref: string
  action: string
  args: {
    [key: string]: unknown
  }
}

export type ActionType = {
  component_id?: "action-type"
  multiple?: boolean
}

export type ActionUpdate = {
  title?: string | null
  description?: string | null
  status?: string | null
  inputs?: string
  control_flow?: ActionControlFlow | null
  is_interactive?: boolean | null
  interaction?: ResponseInteraction | ApprovalInteraction | null
  position_x?: number | null
  position_y?: number | null
  upstream_edges?: Array<ActionEdge> | null
}

/**
 * Result of validating a registry action's arguments.
 */
export type ActionValidationResult = {
  type?: "action"
  status: "success" | "error"
  msg?: string
  detail?: Array<ValidationDetail> | null
  ref?: string | null
  action_type: string
  validated_args?: {
    [key: string]: unknown
  } | null
}

export type status = "success" | "error"

/**
 * Admin view of a user.
 */
export type AdminUserRead = {
  id: string
  email: string
  first_name?: string | null
  last_name?: string | null
  role: UserRole
  is_active: boolean
  is_superuser: boolean
  is_verified: boolean
  last_login_at?: string | null
}

export type AgentOutput = {
  output: unknown
  message_history?: Array<ChatMessage> | null
  duration: number
  usage?: RunUsage | null
  session_id: string
}

export type AgentPreset = {
  component_id?: "agent-preset"
}

/**
 * Payload for creating a new agent preset.
 */
export type AgentPresetCreate = {
  description?: string | null
  instructions?: string | null
  model_name: string
  model_provider: string
  base_url?: string | null
  output_type?: OutputType | null
  actions?: Array<string> | null
  namespaces?: Array<string> | null
  tool_approvals?: {
    [key: string]: boolean
  } | null
  mcp_integrations?: Array<string> | null
  retries?: number
  enable_internet_access?: boolean
  name: string
  slug?: string | null
}

/**
 * API model for reading agent presets.
 */
export type AgentPresetRead = {
  description?: string | null
  instructions?: string | null
  model_name: string
  model_provider: string
  base_url?: string | null
  output_type?: OutputType | null
  actions?: Array<string> | null
  namespaces?: Array<string> | null
  tool_approvals?: {
    [key: string]: boolean
  } | null
  mcp_integrations?: Array<string> | null
  retries?: number
  enable_internet_access?: boolean
  id: string
  workspace_id: string
  name: string
  slug: string
  created_at: string
  updated_at: string
}

/**
 * Minimal API model for reading agent presets in list endpoints.
 */
export type AgentPresetReadMinimal = {
  id: string
  workspace_id: string
  name: string
  slug: string
  description: string | null
  created_at: string
  updated_at: string
}

/**
 * Payload for updating an existing agent preset.
 */
export type AgentPresetUpdate = {
  name?: string | null
  slug?: string | null
  description?: string | null
  instructions?: string | null
  model_name?: string | null
  model_provider?: string | null
  base_url?: string | null
  output_type?: OutputType | null
  actions?: Array<string> | null
  namespaces?: Array<string> | null
  tool_approvals?: {
    [key: string]: boolean
  } | null
  mcp_integrations?: Array<string> | null
  retries?: number | null
  enable_internet_access?: boolean | null
}

/**
 * Request schema for creating an agent session.
 */
export type AgentSessionCreate = {
  /**
   * Session ID. If not provided, service generates one.
   */
  id?: string | null
  /**
   * Human-readable title for the session
   */
  title?: string
  /**
   * User who created this session
   */
  created_by?: string | null
  /**
   * Type of entity this session is associated with
   */
  entity_type: AgentSessionEntity
  /**
   * ID of the associated entity
   */
  entity_id: string
  /**
   * Tools available to the agent for this session
   */
  tools?: Array<string> | null
  /**
   * Agent preset used for this session (if any)
   */
  agent_preset_id?: string | null
  /**
   * Agent harness type
   */
  harness_type?: HarnessType
}

/**
 * The type of entity associated with an agent session.
 *
 * Determines the context and behavior of the session:
 * - CASE: Chat attached to a Case entity for investigation
 * - AGENT_PRESET: Live chat testing a preset configuration
 * - AGENT_PRESET_BUILDER: Builder chat for editing/configuring a preset
 * - COPILOT: Workspace-level copilot assistant
 * - WORKFLOW: Workflow-initiated agent run (from action)
 * - APPROVAL: Inbox approval continuation (hidden from main chat list)
 */
export type AgentSessionEntity =
  | "case"
  | "agent_preset"
  | "agent_preset_builder"
  | "copilot"
  | "workflow"
  | "approval"

/**
 * Request schema for forking an agent session.
 */
export type AgentSessionForkRequest = {
  /**
   * Override entity type for the forked session. Use 'approval' for inbox forks to hide from main chat list.
   */
  entity_type?: AgentSessionEntity | null
}

/**
 * Response schema for agent session.
 */
export type AgentSessionRead = {
  id: string
  workspace_id: string
  title: string
  created_by: string | null
  entity_type: string
  entity_id: string
  tools: Array<string> | null
  agent_preset_id: string | null
  harness_type: string | null
  last_stream_id?: string | null
  parent_session_id?: string | null
  created_at: string
  updated_at: string
}

/**
 * Response schema for agent session with Vercel format messages.
 */
export type AgentSessionReadVercel = {
  id: string
  workspace_id: string
  title: string
  created_by: string | null
  entity_type: string
  entity_id: string
  tools: Array<string> | null
  agent_preset_id: string | null
  harness_type: string | null
  last_stream_id?: string | null
  parent_session_id?: string | null
  created_at: string
  updated_at: string
  /**
   * Session messages in Vercel UI format
   */
  messages?: Array<UIMessage>
}

/**
 * Response schema for agent session with message history.
 */
export type AgentSessionReadWithMessages = {
  id: string
  workspace_id: string
  title: string
  created_by: string | null
  entity_type: string
  entity_id: string
  tools: Array<string> | null
  agent_preset_id: string | null
  harness_type: string | null
  last_stream_id?: string | null
  parent_session_id?: string | null
  created_at: string
  updated_at: string
  /**
   * Session messages
   */
  messages?: Array<unknown>
}

/**
 * Request schema for updating an agent session.
 */
export type AgentSessionUpdate = {
  /**
   * Session title
   */
  title?: string | null
  /**
   * Tools available to the agent
   */
  tools?: Array<string> | null
  /**
   * Agent preset to use for this session
   */
  agent_preset_id?: string | null
  /**
   * Agent harness type
   */
  harness_type?: HarnessType | null
}

export type AgentSettingsRead = {
  agent_default_model: string | null
  agent_fixed_args: string | null
  agent_case_chat_prompt: string
  agent_case_chat_inject_content: boolean
}

export type AgentSettingsUpdate = {
  /**
   * The default AI model to use for agent operations.
   */
  agent_default_model?: string | null
  /**
   * Fixed arguments for agent tools as a JSON string. Format: {'tool_name': {'arg': 'value'}}
   */
  agent_fixed_args?: string | null
  /**
   * Additional instructions for case chat agent; prepended to UI-provided instructions.
   */
  agent_case_chat_prompt?: string
  /**
   * Whether to automatically inject case content into agent prompts when a case_id is available.
   */
  agent_case_chat_inject_content?: boolean
}

/**
 * Settings for the app.
 */
export type AppSettingsRead = {
  app_registry_validation_enabled: boolean
  app_executions_query_limit: number
  app_interactions_enabled: boolean
  app_workflow_export_enabled: boolean
  app_create_workspace_on_register: boolean
  app_editor_pill_decorations_enabled: boolean
  app_action_form_mode_enabled: boolean
}

/**
 * Settings for OAuth authentication.
 */
export type AppSettingsUpdate = {
  /**
   * Whether registry validation is enabled.
   */
  app_registry_validation_enabled?: boolean
  /**
   * The maximum number of executions to return in a single query.
   */
  app_executions_query_limit?: number
  /**
   * Whether app interactions are enabled.
   */
  app_interactions_enabled?: boolean
  /**
   * Whether workflow exports are enabled.
   */
  app_workflow_export_enabled?: boolean
  /**
   * Whether to automatically create a workspace when a user signs up.
   */
  app_create_workspace_on_register?: boolean
  /**
   * Whether to show template expression pills with decorations. When disabled, expressions show as plain text with simple highlighting.
   */
  app_editor_pill_decorations_enabled?: boolean
  /**
   * Whether to enable form mode for action inputs. When disabled, only YAML mode is available, preserving raw YAML formatting.
   */
  app_action_form_mode_enabled?: boolean
}

/**
 * Operator decision for a pending approval.
 */
export type ApprovalDecision = {
  tool_call_id: string
  action: "approve" | "override" | "deny"
  override_args?: {
    [key: string]: unknown
  } | null
  reason?: string | null
}

export type action = "approve" | "override" | "deny"

/**
 * Configuration for an approval interaction.
 */
export type ApprovalInteraction = {
  type: "approval"
  /**
   * The timeout for the interaction in seconds.
   */
  timeout?: number | null
  /**
   * Number of approvers required before the action can proceed.
   */
  required_approvers?: number
  /**
   * List of groups that are allowed to approve this action.
   */
  approver_groups?: Array<string>
  /**
   * Custom message to display to approvers.
   */
  message?: string
  /**
   * Condition to approve the action.
   */
  approve_if?: string | null
}

export type ApprovalMap = {
  [key: string]: boolean | ToolApproved | ToolDenied
}

/**
 * Response schema for approval data in chat timeline.
 */
export type ApprovalRead = {
  id: string
  tool_call_id: string
  tool_name: string
  tool_call_args?: {
    [key: string]: unknown
  } | null
  status: ApprovalStatus
  reason?: string | null
  decision?:
    | boolean
    | {
        [key: string]: unknown
      }
    | null
  approved_by?: string | null
  approved_at?: string | null
  created_at: string
}

/**
 * Possible states for a deferred tool approval.
 */
export type ApprovalStatus = "pending" | "approved" | "rejected"

/**
 * Request model for submitting approval decisions.
 */
export type ApprovalSubmission = {
  approvals: ApprovalMap
}

/**
 * Event for when a case assignee is changed.
 */
export type AssigneeChangedEventRead = {
  /**
   * The execution ID of the workflow that triggered the event.
   */
  wf_exec_id?: string | null
  type?: "assignee_changed"
  old: string | null
  new: string | null
  /**
   * The user who performed the action.
   */
  user_id?: string | null
  /**
   * The timestamp of the event.
   */
  created_at: string
}

export type AssistantMessage = {
  content: Array<TextBlock | ThinkingBlock | ToolUseBlock | ToolResultBlock>
  model: string
  parent_tool_use_id?: string | null
  error?:
    | "authentication_failed"
    | "billing_error"
    | "rate_limit"
    | "invalid_request"
    | "server_error"
    | "unknown"
    | null
}

/**
 * Event for when an attachment is created for a case.
 */
export type AttachmentCreatedEventRead = {
  /**
   * The execution ID of the workflow that triggered the event.
   */
  wf_exec_id?: string | null
  type?: "attachment_created"
  attachment_id: string
  file_name: string
  content_type: string
  size: number
  /**
   * The user who performed the action.
   */
  user_id?: string | null
  /**
   * The timestamp of the event.
   */
  created_at: string
}

/**
 * Event for when an attachment is deleted from a case.
 */
export type AttachmentDeletedEventRead = {
  /**
   * The execution ID of the workflow that triggered the event.
   */
  wf_exec_id?: string | null
  type?: "attachment_deleted"
  attachment_id: string
  file_name: string
  /**
   * The user who performed the action.
   */
  user_id?: string | null
  /**
   * The timestamp of the event.
   */
  created_at: string
}

export type AudioUrl = {
  url: string
  force_download?: boolean
  vendor_metadata?: {
    [key: string]: unknown
  } | null
  kind?: "audio-url"
  /**
   * Return the media type of the file, based on the URL or the provided `media_type`.
   */
  readonly media_type: string
  /**
   * The identifier of the file, such as a unique ID.
   *
   * This identifier can be provided to the model in a message to allow it to refer to this file in a tool call argument,
   * and the tool can look up the file in question by iterating over the message history and finding the matching `FileUrl`.
   *
   * This identifier is only automatically passed to the model when the `FileUrl` is returned by a tool.
   * If you're passing the `FileUrl` as a user message, it's up to you to include a separate text part with the identifier,
   * e.g. "This is file <identifier>:" preceding the `FileUrl`.
   *
   * It's also included in inline-text delimiters for providers that require inlining text documents, so the model can
   * distinguish multiple files.
   */
  readonly identifier: string
}

/**
 * Settings for audit logging.
 */
export type AuditSettingsRead = {
  audit_webhook_url: string | null
}

/**
 * Settings for audit logging.
 */
export type AuditSettingsUpdate = {
  /**
   * Webhook URL that receives streamed audit events. When unset, audit events are skipped.
   */
  audit_webhook_url?: string | null
}

export type AuthSettingsRead = {
  auth_basic_enabled: boolean
  auth_require_email_verification: boolean
  auth_allowed_email_domains: Array<string>
  auth_min_password_length: number
  auth_session_expire_time_seconds: number
}

export type AuthSettingsUpdate = {
  /**
   * Whether basic auth is enabled.
   */
  auth_basic_enabled?: boolean
  /**
   * Whether email verification is required for authentication.
   */
  auth_require_email_verification?: boolean
  /**
   * Allowed email domains for authentication. If empty, all domains are allowed.
   */
  auth_allowed_email_domains?: Array<string>
  /**
   * Minimum password length for authentication.
   */
  auth_min_password_length?: number
  /**
   * Session expiration time in seconds.
   */
  auth_session_expire_time_seconds?: number
}

/**
 * Batch update for action and trigger positions.
 */
export type BatchPositionUpdate = {
  actions?: Array<ActionPositionUpdate>
  trigger_position?: Position | null
}

export type BinaryContent = {
  data: Blob | File
  media_type:
    | "audio/wav"
    | "audio/mpeg"
    | "audio/ogg"
    | "audio/flac"
    | "audio/aiff"
    | "audio/aac"
    | "image/jpeg"
    | "image/png"
    | "image/gif"
    | "image/webp"
    | "application/pdf"
    | "text/plain"
    | "text/csv"
    | "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
    | "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
    | "text/html"
    | "text/markdown"
    | "application/msword"
    | "application/vnd.ms-excel"
    | string
  vendor_metadata?: {
    [key: string]: unknown
  } | null
  kind?: "binary"
  /**
   * Identifier for the binary content, such as a unique ID.
   *
   * This identifier can be provided to the model in a message to allow it to refer to this file in a tool call argument,
   * and the tool can look up the file in question by iterating over the message history and finding the matching `BinaryContent`.
   *
   * This identifier is only automatically passed to the model when the `BinaryContent` is returned by a tool.
   * If you're passing the `BinaryContent` as a user message, it's up to you to include a separate text part with the identifier,
   * e.g. "This is file <identifier>:" preceding the `BinaryContent`.
   *
   * It's also included in inline-text delimiters for providers that require inlining text documents, so the model can
   * distinguish multiple files.
   */
  readonly identifier: string
}

export type Body_auth_auth_database_login = {
  grant_type?: string | null
  username: string
  password: string
  scope?: string
  client_id?: string | null
  client_secret?: string | null
}

export type Body_auth_reset_forgot_password = {
  email: string
}

export type Body_auth_reset_reset_password = {
  token: string
  password: string
}

export type Body_auth_sso_acs = {
  saml_response: string
  relay_state: string
}

export type Body_auth_verify_request_token = {
  email: string
}

export type Body_auth_verify_verify = {
  token: string
}

export type Body_case_attachments_create_attachment = {
  file: Blob | File
}

export type Body_tables_import_csv = {
  file: Blob | File
  column_mapping: string
}

export type Body_tables_import_table_from_csv = {
  file: Blob | File
  table_name?: string | null
}

export type Body_workflows_create_workflow = {
  title?: string | null
  description?: string | null
  /**
   * Use the workflow ID if it is provided in the YAML file
   */
  use_workflow_id?: boolean
  file?: (Blob | File) | null
}

export type CachePoint = {
  kind?: "cache-point"
  ttl?: "5m" | "1h"
}

export type ttl = "5m" | "1h"

/**
 * Model for attachment download URL response.
 */
export type CaseAttachmentDownloadResponse = {
  /**
   * Pre-signed download URL
   */
  download_url: string
  /**
   * Original filename
   */
  file_name: string
  /**
   * MIME type of the file
   */
  content_type: string
}

/**
 * Model for reading a case attachment.
 */
export type CaseAttachmentRead = {
  id: string
  case_id: string
  file_id: string
  file_name: string
  content_type: string
  size: number
  sha256: string
  created_at: string
  updated_at: string
  creator_id?: string | null
  is_deleted?: boolean
}

export type CaseCommentCreate = {
  content: string
  parent_id?: string | null
}

export type CaseCommentRead = {
  id: string
  created_at: string
  updated_at: string
  content: string
  parent_id?: string | null
  user?: UserRead | null
  last_edited_at?: string | null
}

export type CaseCommentUpdate = {
  content?: string | null
  parent_id?: string | null
}

export type CaseCreate = {
  summary: string
  description: string
  status: CaseStatus
  priority: CasePriority
  severity: CaseSeverity
  fields?: {
    [key: string]: unknown
  } | null
  assignee_id?: string | null
  payload?: {
    [key: string]: unknown
  } | null
}

/**
 * Strategies for choosing which matching event should anchor a duration.
 */
export type CaseDurationAnchorSelection = "first" | "last"

/**
 * Create payload for case duration records.
 */
export type CaseDurationCreate = {
  /**
   * Identifier of the case duration definition generating this duration.
   */
  definition_id: string
  /**
   * Case event that started the duration, if available.
   */
  start_event_id?: string | null
  /**
   * Case event that ended the duration, if available.
   */
  end_event_id?: string | null
  /**
   * Timestamp when the duration began.
   */
  started_at?: string | null
  /**
   * Timestamp when the duration ended.
   */
  ended_at?: string | null
  /**
   * Total elapsed time between start and end timestamps.
   */
  duration?: string | null
}

/**
 * Create payload for case duration definitions.
 */
export type CaseDurationDefinitionCreate = {
  /**
   * Human readable name for the metric.
   */
  name: string
  /**
   * Optional description providing more context.
   */
  description?: string | null
  /**
   * Event configuration that marks the start of the duration.
   */
  start_anchor: CaseDurationEventAnchor
  /**
   * Event configuration that marks the end of the duration.
   */
  end_anchor: CaseDurationEventAnchor
}

/**
 * Read model for case duration definitions.
 */
export type CaseDurationDefinitionRead = {
  /**
   * Human readable name for the metric.
   */
  name: string
  /**
   * Optional description providing more context.
   */
  description?: string | null
  /**
   * Event configuration that marks the start of the duration.
   */
  start_anchor: CaseDurationEventAnchor
  /**
   * Event configuration that marks the end of the duration.
   */
  end_anchor: CaseDurationEventAnchor
  id: string
}

/**
 * Patch payload for case duration definitions.
 */
export type CaseDurationDefinitionUpdate = {
  name?: string | null
  description?: string | null
  start_anchor?: CaseDurationEventAnchor | null
  end_anchor?: CaseDurationEventAnchor | null
}

/**
 * Selection criteria describing an event boundary for a duration.
 */
export type CaseDurationEventAnchor = {
  /**
   * Case event type that should be matched for this anchor.
   */
  event_type: CaseEventType
  /**
   * Dot-delimited path to the timestamp field on the event. Defaults to the event creation timestamp.
   */
  timestamp_path?: string
  /**
   * Optional dot-delimited equality filters that must match on the event payload, e.g. {'data.new': 'resolved'}.
   */
  field_filters?: {
    [key: string]: unknown
  }
  /**
   * Whether to use the first or last matching event for this anchor. Defaults to the first match.
   */
  selection?: CaseDurationAnchorSelection
}

/**
 * Read model for case duration records.
 */
export type CaseDurationRead = {
  /**
   * Identifier of the case duration definition generating this duration.
   */
  definition_id: string
  /**
   * Case event that started the duration, if available.
   */
  start_event_id?: string | null
  /**
   * Case event that ended the duration, if available.
   */
  end_event_id?: string | null
  /**
   * Timestamp when the duration began.
   */
  started_at?: string | null
  /**
   * Timestamp when the duration ended.
   */
  ended_at?: string | null
  /**
   * Total elapsed time between start and end timestamps.
   */
  duration?: string | null
  id: string
  case_id: string
}

/**
 * Patch payload for case duration records.
 */
export type CaseDurationUpdate = {
  definition_id?: string | null
  start_event_id?: string | null
  end_event_id?: string | null
  started_at?: string | null
  ended_at?: string | null
  duration?: string | null
}

/**
 * Base read model for all event types.
 */
export type CaseEventRead =
  | CreatedEventRead
  | ClosedEventRead
  | ReopenedEventRead
  | CaseViewedEventRead
  | UpdatedEventRead
  | StatusChangedEventRead
  | PriorityChangedEventRead
  | SeverityChangedEventRead
  | FieldChangedEventRead
  | AssigneeChangedEventRead
  | AttachmentCreatedEventRead
  | AttachmentDeletedEventRead
  | TagAddedEventRead
  | TagRemovedEventRead
  | PayloadChangedEventRead
  | TaskCreatedEventRead
  | TaskStatusChangedEventRead
  | TaskPriorityChangedEventRead
  | TaskWorkflowChangedEventRead
  | TaskDeletedEventRead
  | TaskAssigneeChangedEventRead

/**
 * Case activity type values.
 */
export type CaseEventType =
  | "case_created"
  | "case_updated"
  | "case_closed"
  | "case_reopened"
  | "case_viewed"
  | "priority_changed"
  | "severity_changed"
  | "status_changed"
  | "fields_changed"
  | "assignee_changed"
  | "attachment_created"
  | "attachment_deleted"
  | "tag_added"
  | "tag_removed"
  | "payload_changed"
  | "task_created"
  | "task_deleted"
  | "task_status_changed"
  | "task_priority_changed"
  | "task_workflow_changed"
  | "task_assignee_changed"

export type CaseEventsWithUsers = {
  /**
   * The events for the case.
   */
  events: Array<CaseEventRead>
  /**
   * The users for the case.
   */
  users: Array<UserRead>
}

/**
 * Create a new case field.
 */
export type CaseFieldCreate = {
  /**
   * The name of the column
   */
  name: string
  /**
   * The SQL type of the column
   */
  type: SqlType
  nullable?: boolean
  default?: unknown | null
  options?: Array<string> | null
}

/**
 * Read model for a case field.
 */
export type CaseFieldRead = {
  id: string
  type: SqlType
  description: string
  nullable: boolean
  default: string | null
  reserved: boolean
  options?: Array<string> | null
  value: unknown
}

/**
 * Minimal read model for a case field.
 */
export type CaseFieldReadMinimal = {
  id: string
  type: SqlType
  description: string
  nullable: boolean
  default: string | null
  reserved: boolean
  options?: Array<string> | null
}

/**
 * Update a case field.
 */
export type CaseFieldUpdate = {
  /**
   * The name of the column
   */
  name?: string | null
  /**
   * The SQL type of the column
   */
  type?: SqlType | null
  /**
   * Whether the column can be null
   */
  nullable?: boolean | null
  /**
   * The default value of the column
   */
  default?: unknown | null
  /**
   * Whether the column is an index
   */
  is_index?: boolean | null
  options?: Array<string> | null
}

/**
 * Case priority values aligned with urgency levels.
 *
 * Values:
 * UNKNOWN (0): No priority is assigned
 * LOW (1): Application or personal procedure is unusable, where a workaround is available or a repair is possible
 * MEDIUM (2): Non-critical function or procedure is unusable or hard to use causing operational disruptions with no direct impact on a service's availability. A workaround is available
 * HIGH (3): Critical functionality or network access is interrupted, degraded or unusable, having a severe impact on services availability. No acceptable alternative is possible
 * CRITICAL (4): Interruption making a critical functionality inaccessible or a complete network interruption causing a severe impact on services availability. There is no possible alternative
 * OTHER (99): The priority is not normalized
 */
export type CasePriority =
  | "unknown"
  | "low"
  | "medium"
  | "high"
  | "critical"
  | "other"

export type CaseRead = {
  id: string
  short_id: string
  created_at: string
  updated_at: string
  summary: string
  status: CaseStatus
  priority: CasePriority
  severity: CaseSeverity
  description: string
  fields: Array<CaseFieldRead>
  assignee?: UserRead | null
  payload: {
    [key: string]: unknown
  } | null
  tags?: Array<CaseTagRead>
}

export type CaseReadMinimal = {
  id: string
  short_id: string
  created_at: string
  updated_at: string
  summary: string
  status: CaseStatus
  priority: CasePriority
  severity: CaseSeverity
  assignee?: UserRead | null
  tags?: Array<CaseTagRead>
  num_tasks_completed?: number
  num_tasks_total?: number
}

/**
 * Case severity values aligned with OCSF severity values.
 *
 * Values:
 * UNKNOWN (0): The event/finding severity is unknown
 * INFORMATIONAL (1): Informational message. No action required
 * LOW (2): The user decides if action is needed
 * MEDIUM (3): Action is required but the situation is not serious at this time
 * HIGH (4): Action is required immediately
 * CRITICAL (5): Action is required immediately and the scope is broad
 * FATAL (6): An error occurred but it is too late to take remedial action
 * OTHER (99): The event/finding severity is not mapped
 */
export type CaseSeverity =
  | "unknown"
  | "informational"
  | "low"
  | "medium"
  | "high"
  | "critical"
  | "fatal"
  | "other"

/**
 * Case status values aligned with OCSF Incident Finding status.
 */
export type CaseStatus =
  | "unknown"
  | "new"
  | "in_progress"
  | "on_hold"
  | "resolved"
  | "closed"
  | "other"

export type CaseTagCreate = {
  /**
   * Tag ID (UUID) or ref
   */
  tag_id: string
}

/**
 * Tag data.
 */
export type CaseTagRead = {
  id: string
  name: string
  ref: string
  color: string | null
}

export type CaseTaskCreate = {
  title: string
  description?: string | null
  priority?: CasePriority
  status?: CaseTaskStatus
  assignee_id?: string | null
  workflow_id?: string | null
  default_trigger_values?: {
    [key: string]: unknown
  } | null
}

export type CaseTaskRead = {
  id: string
  created_at: string
  updated_at: string
  case_id: string
  title: string
  description: string | null
  priority: CasePriority
  status: CaseTaskStatus
  assignee?: UserRead | null
  workflow_id: string | null
  default_trigger_values?: {
    [key: string]: unknown
  } | null
}

/**
 * Case task status values.
 */
export type CaseTaskStatus = "todo" | "in_progress" | "completed" | "blocked"

export type CaseTaskUpdate = {
  title?: string | null
  description?: string | null
  priority?: CasePriority | null
  status?: CaseTaskStatus | null
  assignee_id?: string | null
  workflow_id?: string | null
  default_trigger_values?: {
    [key: string]: unknown
  } | null
}

export type CaseUpdate = {
  summary?: string | null
  description?: string | null
  status?: CaseStatus | null
  priority?: CasePriority | null
  severity?: CaseSeverity | null
  fields?: {
    [key: string]: unknown
  } | null
  assignee_id?: string | null
  payload?: {
    [key: string]: unknown
  } | null
}

/**
 * Event for when a case is viewed.
 */
export type CaseViewedEventRead = {
  /**
   * The execution ID of the workflow that triggered the event.
   */
  wf_exec_id?: string | null
  type?: "case_viewed"
  /**
   * The user who performed the action.
   */
  user_id?: string | null
  /**
   * The timestamp of the event.
   */
  created_at: string
}

/**
 * Model for a chat message with typed message payload.
 *
 * This model supports both regular messages and approval bubbles:
 * - kind=CHAT_MESSAGE: Contains message field with user/assistant content
 * - kind=APPROVAL_REQUEST/APPROVAL_DECISION: Contains approval field with approval data
 */
export type ChatMessage = {
  /**
   * Unique message identifier
   */
  id: string
  /**
   * Message kind for rendering
   */
  kind?: MessageKind
  /**
   * The deserialized message (for kind=CHAT_MESSAGE)
   */
  message?:
    | unknown
    | UserMessage
    | AssistantMessage
    | SystemMessage
    | ResultMessage
    | StreamEvent
    | null
  /**
   * Approval data for approval bubble rendering (for kind=APPROVAL_REQUEST/APPROVAL_DECISION)
   */
  approval?: ApprovalRead | null
}

/**
 * Model for chat metadata with message history.
 */
export type ChatRead = {
  /**
   * Unique chat identifier
   */
  id: string
  /**
   * Human-readable title for the chat
   */
  title: string
  /**
   * ID of the user who owns the chat
   */
  user_id: string
  /**
   * Type of entity this chat is associated with
   */
  entity_type: string
  /**
   * ID of the associated entity
   */
  entity_id: string
  /**
   * Tools available to the agent
   */
  tools: Array<string>
  /**
   * Agent preset used for this chat, if any
   */
  agent_preset_id?: string | null
  /**
   * When the chat was created
   */
  created_at: string
  /**
   * When the chat was last updated
   */
  updated_at: string
  /**
   * Last processed Redis stream ID for this chat
   */
  last_stream_id?: string | null
  /**
   * Whether this chat is read-only (legacy chats cannot be modified)
   */
  is_readonly?: boolean
  /**
   * Chat messages from Redis stream
   */
  messages?: Array<ChatMessage>
}

/**
 * Model for chat metadata without messages.
 *
 * Note: Legacy Chat records are read-only (is_readonly=True).
 */
export type ChatReadMinimal = {
  /**
   * Unique chat identifier
   */
  id: string
  /**
   * Human-readable title for the chat
   */
  title: string
  /**
   * ID of the user who owns the chat
   */
  user_id: string
  /**
   * Type of entity this chat is associated with
   */
  entity_type: string
  /**
   * ID of the associated entity
   */
  entity_id: string
  /**
   * Tools available to the agent
   */
  tools: Array<string>
  /**
   * Agent preset used for this chat, if any
   */
  agent_preset_id?: string | null
  /**
   * When the chat was created
   */
  created_at: string
  /**
   * When the chat was last updated
   */
  updated_at: string
  /**
   * Last processed Redis stream ID for this chat
   */
  last_stream_id?: string | null
  /**
   * Whether this chat is read-only (legacy chats cannot be modified)
   */
  is_readonly?: boolean
}

/**
 * Model for chat metadata with message history in Vercel format.
 */
export type ChatReadVercel = {
  /**
   * Unique chat identifier
   */
  id: string
  /**
   * Human-readable title for the chat
   */
  title: string
  /**
   * ID of the user who owns the chat
   */
  user_id: string
  /**
   * Type of entity this chat is associated with
   */
  entity_type: string
  /**
   * ID of the associated entity
   */
  entity_id: string
  /**
   * Tools available to the agent
   */
  tools: Array<string>
  /**
   * Agent preset used for this chat, if any
   */
  agent_preset_id?: string | null
  /**
   * When the chat was created
   */
  created_at: string
  /**
   * When the chat was last updated
   */
  updated_at: string
  /**
   * Last processed Redis stream ID for this chat
   */
  last_stream_id?: string | null
  /**
   * Whether this chat is read-only (legacy chats cannot be modified)
   */
  is_readonly?: boolean
  /**
   * Chat messages from Redis stream
   */
  messages?: Array<UIMessage>
}

/**
 * Event for when a case is closed.
 */
export type ClosedEventRead = {
  /**
   * The execution ID of the workflow that triggered the event.
   */
  wf_exec_id?: string | null
  type?: "case_closed"
  old: CaseStatus
  new: CaseStatus
  /**
   * The user who performed the action.
   */
  user_id?: string | null
  /**
   * The timestamp of the event.
   */
  created_at: string
}

export type Code = {
  component_id?: "code"
  lang?: "yaml" | "python"
}

export type lang = "yaml" | "python"

export type CollectionObject = {
  [key: string]: unknown
}

/**
 * Payload to continue a CE run after collecting approvals.
 */
export type ContinueRunRequest = {
  kind?: "continue"
  decisions: Array<ApprovalDecision>
}

/**
 * Event for when a case is created.
 */
export type CreatedEventRead = {
  /**
   * The execution ID of the workflow that triggered the event.
   */
  wf_exec_id?: string | null
  type?: "case_created"
  /**
   * The user who performed the action.
   */
  user_id?: string | null
  /**
   * The timestamp of the event.
   */
  created_at: string
}

export type CursorPaginatedResponse_CaseReadMinimal_ = {
  items: Array<CaseReadMinimal>
  /**
   * Cursor for next page
   */
  next_cursor?: string | null
  /**
   * Cursor for previous page
   */
  prev_cursor?: string | null
  /**
   * Whether more items exist
   */
  has_more?: boolean
  /**
   * Whether previous items exist
   */
  has_previous?: boolean
  /**
   * Estimated total count from table statistics
   */
  total_estimate?: number | null
}

export type CursorPaginatedResponse_InboxItemRead_ = {
  items: Array<InboxItemRead>
  /**
   * Cursor for next page
   */
  next_cursor?: string | null
  /**
   * Cursor for previous page
   */
  prev_cursor?: string | null
  /**
   * Whether more items exist
   */
  has_more?: boolean
  /**
   * Whether previous items exist
   */
  has_previous?: boolean
  /**
   * Estimated total count from table statistics
   */
  total_estimate?: number | null
}

export type CursorPaginatedResponse_TableRowRead_ = {
  items: Array<TableRowRead>
  /**
   * Cursor for next page
   */
  next_cursor?: string | null
  /**
   * Cursor for previous page
   */
  prev_cursor?: string | null
  /**
   * Whether more items exist
   */
  has_more?: boolean
  /**
   * Whether previous items exist
   */
  has_previous?: boolean
  /**
   * Estimated total count from table statistics
   */
  total_estimate?: number | null
}

export type CursorPaginatedResponse_WorkflowReadMinimal_ = {
  items: Array<WorkflowReadMinimal>
  /**
   * Cursor for next page
   */
  next_cursor?: string | null
  /**
   * Cursor for previous page
   */
  prev_cursor?: string | null
  /**
   * Whether more items exist
   */
  has_more?: boolean
  /**
   * Whether previous items exist
   */
  has_previous?: boolean
  /**
   * Estimated total count from table statistics
   */
  total_estimate?: number | null
}

/**
 * Request payload for creating a custom OAuth provider.
 */
export type CustomOAuthProviderCreate = {
  name: string
  description?: string | null
  grant_type: OAuthGrantType
  /**
   * OAuth authorization endpoint URL
   */
  authorization_endpoint: string
  /**
   * OAuth token endpoint URL
   */
  token_endpoint: string
  /**
   * Default OAuth scopes to request
   */
  scopes?: Array<string> | null
  /**
   * Optional custom identifier for the provider
   */
  provider_id?: string | null
  /**
   * OAuth client identifier
   */
  client_id: string
  /**
   * OAuth client secret for the provider
   */
  client_secret?: string | null
}

/**
 * This is the runtime configuration for the workflow.
 *
 * Activities don't need access to this.
 */
export type DSLConfig_Input = {
  /**
   * The type of scheduler to use.
   */
  scheduler?: "static" | "dynamic"
  /**
   * The workflow's target execution environment. This is used to isolate secrets across different environments.If not provided, the default environment (default) is used.
   */
  environment?: string
  /**
   * Workflow timeout in seconds. If set to 0, the workflow has no timeout.
   */
  timeout?: number
}

/**
 * The type of scheduler to use.
 */
export type scheduler = "static" | "dynamic"

/**
 * This is the runtime configuration for the workflow.
 *
 * Activities don't need access to this.
 */
export type DSLConfig_Output = {
  /**
   * The workflow's target execution environment. This is used to isolate secrets across different environments.If not provided, the default environment (default) is used.
   */
  environment?: string
  /**
   * Workflow timeout in seconds. If set to 0, the workflow has no timeout.
   */
  timeout?: number
}

export type DSLEntrypoint = {
  /**
   * The entrypoint action ref
   */
  ref?: string | null
  /**
   * Expected trigger input schema. Use this to specify the expected shape of the trigger input.
   */
  expects?: {
    [key: string]: ExpectedField_Output
  } | null
}

/**
 * DSL Environment context. Has metadata about the workflow.
 */
export type DSLEnvironment = {
  workflow?: {
    [key: string]: unknown
  }
  environment?: string
  variables?: {
    [key: string]: unknown
  }
  registry_version?: string
}

/**
 * DSL definition for a workflow.
 *
 * The difference between this and a normal workflow engine is that here,
 * our workflow execution order is defined by the DSL itself, independent
 * of a workflow scheduler.
 *
 * With a traditional
 * This allows the execution of the workflow to be fully deterministic.
 */
export type DSLInput = {
  title: string
  description: string
  entrypoint: DSLEntrypoint
  actions: Array<ActionStatement>
  config?: DSLConfig_Output
  triggers?: Array<Trigger>
  /**
   * The action ref or value to return.
   */
  returns?: unknown | null
  /**
   * The action ref to handle errors.
   */
  error_handler?: string | null
}

export type DSLRunArgs = {
  role: Role
  dsl?: DSLInput | null
  wf_id: string
  trigger_inputs?: InlineObject | ExternalObject | CollectionObject | null
  parent_run_context?: RunContext | null
  /**
   * Runtime configuration that can be set on workflow entry. Note that this can override the default config in DSLInput.
   */
  runtime_config?: DSLConfig_Output
  /**
   * Platform activity start-to-close timeout.
   */
  timeout?: string
  /**
   * The schedule ID that triggered this workflow, if any. Auto-converts from legacy 'sch-<hex>' format.
   */
  schedule_id?: string | null
  /**
   * Execution type (draft or published). Draft executions use draft aliases for child workflows.
   */
  execution_type?: ExecutionType
  /**
   * The workflow's logical time anchor for FN.now() and related functions. If not provided, computed from TemporalScheduledStartTime (for schedules) or workflow start_time (for other triggers). Stored as UTC.
   */
  time_anchor?: string | null
  /**
   * Registry version lock for action execution. Contains origins (origin -> version) and actions (action_name -> origin) mappings.
   */
  registry_lock?: RegistryLock | null
}

/**
 * Result of validating a generic input.
 */
export type DSLValidationResult = {
  type?: "dsl"
  status: "success" | "error"
  msg?: string
  detail?: Array<ValidationDetail> | null
  ref?: string | null
}

/**
 * A custom data part, where type matches 'data-...'.
 */
export type DataUIPart = {
  type: string
  id?: string
  data: unknown
}

export type DocumentUrl = {
  url: string
  force_download?: boolean
  vendor_metadata?: {
    [key: string]: unknown
  } | null
  kind?: "document-url"
  /**
   * Return the media type of the file, based on the URL or the provided `media_type`.
   */
  readonly media_type: string
  /**
   * The identifier of the file, such as a unique ID.
   *
   * This identifier can be provided to the model in a message to allow it to refer to this file in a tool call argument,
   * and the tool can look up the file in question by iterating over the message history and finding the matching `FileUrl`.
   *
   * This identifier is only automatically passed to the model when the `FileUrl` is returned by a tool.
   * If you're passing the `FileUrl` as a user message, it's up to you to include a separate text part with the identifier,
   * e.g. "This is file <identifier>:" preceding the `FileUrl`.
   *
   * It's also included in inline-text delimiters for providers that require inlining text documents, so the model can
   * distinguish multiple files.
   */
  readonly identifier: string
}

export type DynamicToolUIPartInputAvailable = {
  type: "dynamic-tool"
  toolName: string
  toolCallId: string
  state: "input-available"
  input: unknown
  output?: null
  errorText?: null
  callProviderMetadata?: {
    [key: string]: {
      [key: string]: unknown
    }
  }
}

export type DynamicToolUIPartInputStreaming = {
  type: "dynamic-tool"
  toolName: string
  toolCallId: string
  state: "input-streaming"
  input?: unknown
  output?: null
  errorText?: null
}

export type DynamicToolUIPartOutputAvailable = {
  type: "dynamic-tool"
  toolName: string
  toolCallId: string
  state: "output-available"
  input: unknown
  output: unknown
  errorText?: null
  callProviderMetadata?: {
    [key: string]: {
      [key: string]: unknown
    }
  }
  preliminary?: boolean
}

export type DynamicToolUIPartOutputError = {
  type: "dynamic-tool"
  toolName: string
  toolCallId: string
  state: "output-error"
  input: unknown
  output?: null
  errorText: string
  callProviderMetadata?: {
    [key: string]: {
      [key: string]: unknown
    }
  }
}

export type EditorActionRead = {
  type: string
  ref: string
  description: string
}

export type EditorComponent =
  | Text
  | Code
  | Select
  | TextArea
  | Integer
  | Float
  | Toggle
  | Yaml
  | TagInput
  | ActionType
  | WorkflowAlias
  | AgentPreset

export type EditorFunctionRead = {
  name: string
  description: string
  parameters: Array<EditorParamRead>
  return_type: string
}

export type EditorParamRead = {
  name: string
  type: string
  optional: boolean
}

/**
 * TypedDict for tier entitlements stored in JSONB.
 *
 * All keys are optional (total=False) to support partial overrides.
 */
export type EntitlementsDict = {
  custom_registry?: boolean
  sso?: boolean
  git_sync?: boolean
}

export type ErrorDetails = {
  type: string
  loc: Array<number | string>
  msg: string
  input: unknown
  ctx?: {
    [key: string]: unknown
  }
  url?: string
}

export type ErrorModel = {
  detail:
    | string
    | {
        [key: string]: string
      }
}

export type EventFailure = {
  message: string
  cause?: {
    [key: string]: unknown
  } | null
}

export type EventGroup_TypeVar_ = {
  event_id: number
  udf_namespace: string
  udf_name: string
  udf_key: string
  action_id?: string | null
  action_ref?: string | null
  action_title?: string | null
  action_description?: string | null
  action_input:
    | RunActionInput
    | DSLRunArgs
    | GetWorkflowDefinitionActivityInputs
    | InteractionResult
    | InteractionInput
  action_result?: unknown | null
  current_attempt?: number | null
  retry_policy?: ActionRetryPolicy
  start_delay?: number
  join_strategy?: JoinStrategy
  related_wf_exec_id?: string | null
}

/**
 * Workflow execution context with typed fields.
 *
 * ACTIONS and TRIGGER are always present. Other fields are optional since
 * contexts may be built incrementally during workflow execution.
 */
export type ExecutionContext = {
  ACTIONS: {
    [key: string]: TaskResult
  }
  TRIGGER: InlineObject | ExternalObject | CollectionObject | null
  ENV?: DSLEnvironment
  SECRETS?: {
    [key: string]: unknown
  }
  VARS?: {
    [key: string]: unknown
  }
  var?: {
    [key: string]: unknown
  }
}

/**
 * Execution type for a workflow execution.
 *
 * Distinguishes between draft (development) and published (production) executions.
 */
export type ExecutionType = "draft" | "published"

/**
 * Schema for a field in a template action's expects definition.
 *
 * Note: The default field uses a sentinel to distinguish between
 * "no default specified" (required field) and "default is explicitly None"
 * (optional field).
 */
export type ExpectedField_Input = {
  type: string
  description?: string | null
  default?: unknown
  enum?: Array<string> | null
  optional?: boolean | null
}

export type ExpectedField_Output = {
  [key: string]: unknown
}

export type ExprType =
  | "generic"
  | "action"
  | "secret"
  | "function"
  | "input"
  | "env"
  | "local_vars"
  | "literal"
  | "typecast"
  | "iterator"
  | "ternary"
  | "trigger"
  | "template_action_step"
  | "template_action_input"
  | "variable"

/**
 * Result of visiting an expression node.
 */
export type ExprValidationResult = {
  type?: "expression"
  status: "success" | "error"
  msg?: string
  detail?: Array<ValidationDetail> | null
  ref?: string | null
  expression?: string | null
  expression_type: ExprType
}

export type ExpressionValidationRequest = {
  expression: string
}

export type ExpressionValidationResponse = {
  is_valid: boolean
  errors?: Array<ValidationError>
  tokens?: Array<SyntaxToken>
}

export type ExternalObject = {
  [key: string]: unknown
}

/**
 * Feature flag enum.
 */
export type FeatureFlag =
  | "git-sync"
  | "agent-approvals"
  | "agent-presets"
  | "case-durations"
  | "case-tasks"

/**
 * Response model for feature flags.
 */
export type FeatureFlagsRead = {
  enabled_features: Array<FeatureFlag>
}

/**
 * Event for when a case field is changed.
 */
export type FieldChangedEventRead = {
  /**
   * The execution ID of the workflow that triggered the event.
   */
  wf_exec_id?: string | null
  type?: "fields_changed"
  changes: Array<FieldDiff>
  /**
   * The user who performed the action.
   */
  user_id?: string | null
  /**
   * The timestamp of the event.
   */
  created_at: string
}

export type FieldDiff = {
  field: string
  old: unknown
  new: unknown
}

/**
 * A file part of a message.
 */
export type FileUIPart = {
  type: "file"
  mediaType: string
  url: string
  filename?: string
  providerMetadata?: {
    [key: string]: {
      [key: string]: unknown
    }
  }
}

export type Float = {
  component_id?: "float"
  min_val?: number | null
  max_val?: number | null
  step?: number
}

export type FolderDirectoryItem = {
  id: string
  name: string
  path: string
  workspace_id: string
  created_at: string
  updated_at: string
  type: "folder"
  num_items: number
}

export type GetWorkflowDefinitionActivityInputs = {
  role: Role
  workflow_id: string
  version?: number | null
  task?: ActionStatement | null
}

/**
 * Git commit information for repository management.
 */
export type GitCommitInfo = {
  /**
   * The commit SHA hash
   */
  sha: string
  /**
   * The commit message
   */
  message: string
  /**
   * The commit author name
   */
  author: string
  /**
   * The commit author email
   */
  author_email: string
  /**
   * The commit date in ISO format
   */
  date: string
  /**
   * List of tags associated with this commit
   */
  tags?: Array<string>
}

/**
 * Request to register or update GitHub App credentials.
 */
export type GitHubAppCredentialsRequest = {
  /**
   * GitHub App ID
   */
  app_id: string
  /**
   * GitHub App private key in PEM format
   */
  private_key: string
  /**
   * GitHub App webhook secret
   */
  webhook_secret?: string | null
  /**
   * GitHub App client ID
   */
  client_id?: string | null
}

/**
 * Status of GitHub App credentials.
 */
export type GitHubAppCredentialsStatus = {
  exists: boolean
  app_id?: string | null
  has_webhook_secret?: boolean
  has_client_id?: boolean
  created_at?: string | null
}

/**
 * GitHub App manifest for creating enterprise apps.
 */
export type GitHubAppManifest = {
  name: string
  url: string
  hook_attributes: GitHubWebhookAttributes
  redirect_url: string
  callback_urls: Array<string>
  setup_url: string
  description: string
  public: boolean
  default_permissions: GitHubAppPermissions
  default_events: Array<string>
}

/**
 * GitHub App manifest response.
 */
export type GitHubAppManifestResponse = {
  manifest: GitHubAppManifest
  instructions: Array<string>
}

/**
 * Type definition for GitHub App default permissions.
 */
export type GitHubAppPermissions = {
  contents: string
  metadata: string
  pull_requests: string
}

/**
 * Type definition for GitHub webhook attributes.
 */
export type GitHubWebhookAttributes = {
  url: string
  active: boolean
}

export type GitSettingsRead = {
  git_allowed_domains: Array<string>
  git_repo_url?: string | null
  git_repo_package_name?: string | null
}

export type GitSettingsUpdate = {
  /**
   * Allowed git domains for authentication.
   */
  git_allowed_domains?: Array<string>
  git_repo_url?: string | null
  git_repo_package_name?: string | null
}

/**
 * A single graph operation.
 */
export type GraphOperation = {
  type: GraphOperationType
  /**
   * Operation-specific payload
   */
  payload: {
    [key: string]: unknown
  }
}

/**
 * Graph operation types.
 */
export type GraphOperationType =
  | "add_node"
  | "update_node"
  | "delete_node"
  | "add_edge"
  | "delete_edge"
  | "move_nodes"
  | "update_trigger_position"
  | "update_viewport"

/**
 * Request for PATCH /workflows/{id}/graph.
 *
 * Applies a batch of graph operations with optimistic concurrency.
 */
export type GraphOperationsRequest = {
  /**
   * Expected current graph_version. Returns 409 if mismatched.
   */
  base_version: number
  /**
   * List of operations to apply atomically
   */
  operations: Array<GraphOperation>
}

/**
 * Response for GET /workflows/{id}/graph.
 *
 * Returns the canonical graph projection from Actions.
 */
export type GraphResponse = {
  /**
   * Graph version for optimistic concurrency
   */
  version: number
  /**
   * React Flow nodes
   */
  nodes: Array<{
    [key: string]: unknown
  }>
  /**
   * React Flow edges
   */
  edges: Array<{
    [key: string]: unknown
  }>
  viewport?: {
    [key: string]: unknown
  }
}

export type HTTPValidationError = {
  detail?: Array<ValidationError>
}

/**
 * Supported agent harnesses.
 */
export type HarnessType = "pydantic-ai" | "claude_code"

export type HealthResponse = {
  status: string
}

export type ImageUrl = {
  url: string
  force_download?: boolean
  vendor_metadata?: {
    [key: string]: unknown
  } | null
  kind?: "image-url"
  /**
   * Return the media type of the file, based on the URL or the provided `media_type`.
   */
  readonly media_type: string
  /**
   * The identifier of the file, such as a unique ID.
   *
   * This identifier can be provided to the model in a message to allow it to refer to this file in a tool call argument,
   * and the tool can look up the file in question by iterating over the message history and finding the matching `FileUrl`.
   *
   * This identifier is only automatically passed to the model when the `FileUrl` is returned by a tool.
   * If you're passing the `FileUrl` as a user message, it's up to you to include a separate text part with the identifier,
   * e.g. "This is file <identifier>:" preceding the `FileUrl`.
   *
   * It's also included in inline-text delimiters for providers that require inlining text documents, so the model can
   * distinguish multiple files.
   */
  readonly identifier: string
}

/**
 * Read model for inbox items.
 */
export type InboxItemRead = {
  /**
   * Unique inbox item ID
   */
  id: string
  /**
   * Type of inbox item
   */
  type: InboxItemType
  /**
   * Display title
   */
  title: string
  /**
   * Preview text
   */
  preview: string
  /**
   * Item status
   */
  status: InboxItemStatus
  /**
   * Whether the item is unread
   */
  unread: boolean
  /**
   * Creation timestamp
   */
  created_at: string
  /**
   * Last update timestamp
   */
  updated_at: string
  /**
   * Associated workflow
   */
  workflow?: WorkflowSummary | null
  /**
   * ID of the source entity
   */
  source_id: string
  /**
   * Type of source entity (e.g., agent_session)
   */
  source_type: string
  /**
   * Type-specific metadata
   */
  metadata?: {
    [key: string]: unknown
  } | null
}

/**
 * Status of inbox items.
 */
export type InboxItemStatus = "pending" | "completed" | "failed"

/**
 * Types of inbox items.
 */
export type InboxItemType = "approval"

/**
 * Inferred column mapping between CSV headers and table columns.
 */
export type InferredColumn = {
  /**
   * Original column header in the CSV file
   */
  csv_header: string
  /**
   * Column name created in Tracecat
   */
  field_name: string
  /**
   * Inferred SQL type for the column
   */
  field_type: SqlType
}

export type InlineObject = {
  [key: string]: unknown
}

export type Integer = {
  component_id?: "integer"
  min_val?: number | null
  max_val?: number | null
  step?: number
}

/**
 * Response for OAuth callback.
 */
export type IntegrationOAuthCallback = {
  /**
   * The status of the OAuth callback
   */
  status?: string
  /**
   * The provider that the user connected to
   */
  provider_id: string
  /**
   * The URL to redirect to after the OAuth callback
   */
  redirect_url: string
}

/**
 * Request model for connecting an integration.
 */
export type IntegrationOAuthConnect = {
  /**
   * The URL to redirect to for OAuth authentication
   */
  auth_url: string
  /**
   * The provider that the user connected to
   */
  provider_id: string
}

/**
 * Response model for user integration.
 */
export type IntegrationRead = {
  id: string
  created_at: string
  updated_at: string
  user_id?: string | null
  provider_id: string
  /**
   * OAuth authorization endpoint configured for this integration.
   */
  authorization_endpoint?: string | null
  /**
   * OAuth token endpoint configured for this integration.
   */
  token_endpoint?: string | null
  token_type: string
  expires_at: string | null
  /**
   * OAuth client ID for the provider
   */
  client_id?: string | null
  /**
   * OAuth scopes granted for this integration
   */
  granted_scopes?: Array<string> | null
  /**
   * OAuth scopes requested by user for this integration
   */
  requested_scopes?: Array<string> | null
  status: IntegrationStatus
  is_expired: boolean
}

/**
 * Response model for user integration.
 */
export type IntegrationReadMinimal = {
  id: string
  provider_id: string
  status: IntegrationStatus
  is_expired: boolean
}

/**
 * Status of an integration.
 */
export type IntegrationStatus = "not_configured" | "configured" | "connected"

/**
 * Response for testing integration connection.
 */
export type IntegrationTestConnectionResponse = {
  /**
   * Whether the connection test was successful
   */
  success: boolean
  /**
   * The provider that was tested
   */
  provider_id: string
  /**
   * Message describing the test result
   */
  message: string
  /**
   * Error message if the test failed
   */
  error?: string | null
}

/**
 * Request model for updating an integration.
 */
export type IntegrationUpdate = {
  /**
   * OAuth grant type for this integration
   */
  grant_type: OAuthGrantType
  /**
   * OAuth client ID for the provider
   */
  client_id?: string | null
  /**
   * OAuth client secret for the provider
   */
  client_secret?: string | null
  /**
   * OAuth authorization endpoint URL. Overrides provider defaults when set.
   */
  authorization_endpoint?: string | null
  /**
   * OAuth token endpoint URL. Overrides provider defaults when set.
   */
  token_endpoint?: string | null
  /**
   * OAuth scopes to request for this integration
   */
  scopes?: Array<string> | null
}

export type InteractionCategory = "slack"

/**
 * The context of the interaction.
 */
export type InteractionContext = {
  interaction_id: string
  execution_id: string
  action_ref: string
}

/**
 * Input for the workflow interaction handler. This is used on the client side.
 */
export type InteractionInput = {
  interaction_id: string
  execution_id: string
  action_ref: string
  data: {
    [key: string]: unknown
  }
}

/**
 * Model for reading an interaction.
 */
export type InteractionRead = {
  id: string
  created_at: string
  updated_at: string
  type: InteractionType
  status: InteractionStatus
  request_payload: {
    [key: string]: unknown
  } | null
  response_payload: {
    [key: string]: unknown
  } | null
  expires_at?: string | null
  wf_exec_id: string
  actor: string | null
  action_ref: string
  action_type: string
}

/**
 * Output for the workflow interaction handler. This is used on the client side.
 */
export type InteractionResult = {
  message: string
  detail?: unknown | null
}

export type InteractionStatus =
  | "idle"
  | "pending"
  | "error"
  | "timed_out"
  | "completed"

export type InteractionType = "approval" | "response"

/**
 * Invitation lifecycle status.
 */
export type InvitationStatus = "pending" | "accepted" | "revoked"

export type JoinStrategy = "any" | "all"

/**
 * Authentication type for MCP integrations.
 */
export type MCPAuthType = "OAUTH2" | "CUSTOM" | "NONE"

/**
 * Request model for creating an MCP integration.
 */
export type MCPIntegrationCreate = {
  /**
   * MCP integration name
   */
  name: string
  /**
   * Optional description
   */
  description?: string | null
  /**
   * MCP server endpoint URL
   */
  server_uri: string
  /**
   * Authentication type
   */
  auth_type: MCPAuthType
  /**
   * OAuth integration ID (required for oauth2 auth_type)
   */
  oauth_integration_id?: string | null
  /**
   * Custom credentials (API key, bearer token, or JSON headers) for custom auth_type
   */
  custom_credentials?: string | null
}

/**
 * Response model for MCP integration.
 */
export type MCPIntegrationRead = {
  id: string
  workspace_id: string
  name: string
  description: string | null
  slug: string
  server_uri: string
  auth_type: MCPAuthType
  oauth_integration_id: string | null
  created_at: string
  updated_at: string
}

/**
 * Request model for updating an MCP integration.
 */
export type MCPIntegrationUpdate = {
  name?: string | null
  description?: string | null
  server_uri?: string | null
  auth_type?: MCPAuthType | null
  oauth_integration_id?: string | null
  /**
   * Custom credentials (API key, bearer token, or JSON headers) for custom auth_type
   */
  custom_credentials?: string | null
}

/**
 * Configuration for a user-defined MCP server.
 *
 * Users can connect custom MCP servers to their agents - whether running as
 * Docker containers, local processes, or remote services. The server must
 * expose an HTTP or SSE endpoint.
 *
 * Example:
 * {
 * "name": "internal-tools",
 * "url": "http://host.docker.internal:8080",
 * "transport": "http",
 * "headers": {"Authorization": "Bearer ${{ SECRETS.internal.API_KEY }}"}
 * }
 */
export type MCPServerConfig = {
  name: string
  url: string
  headers?: {
    [key: string]: string
  }
  transport?: "http" | "sse"
}

export type transport = "http" | "sse"

/**
 * The type/kind of message stored in the chat.
 */
export type MessageKind =
  | "chat-message"
  | "approval-request"
  | "approval-decision"
  | "internal"

export type ModelConfig = {
  /**
   * The name of the model. This is used to identify the model in the system.
   */
  name: string
  /**
   * The provider of the model. This is used to determine which organization secret to use for this model.
   */
  provider: string
  /**
   * The name of the organization secret to use for this model. This secret must be configured in the organization settings.
   */
  org_secret_name: string
  /**
   * The secrets to use for this model. This is used to determine which organization secret to use for this model.
   */
  secrets: ModelSecretConfig
}

/**
 * Model for creating model credentials.
 */
export type ModelCredentialCreate = {
  provider: string
  /**
   * Provider-specific credentials (e.g., api_key)
   */
  credentials: {
    [key: string]: string
  }
}

/**
 * Model for updating model credentials.
 */
export type ModelCredentialUpdate = {
  /**
   * Provider-specific credentials to update
   */
  credentials: {
    [key: string]: string
  }
}

export type ModelSecretConfig = {
  required?: Array<string>
  optional?: Array<string>
}

export type OAuth2AuthorizeResponse = {
  authorization_url: string
}

/**
 * Grant type for OAuth 2.0.
 */
export type OAuthGrantType = "authorization_code" | "client_credentials"

/**
 * Settings for OAuth authentication.
 */
export type OAuthSettingsRead = {
  oauth_google_enabled: boolean
}

/**
 * Settings for OAuth authentication.
 */
export type OAuthSettingsUpdate = {
  /**
   * Whether OAuth is enabled.
   */
  oauth_google_enabled?: boolean
}

/**
 * Create organization request.
 */
export type OrgCreate = {
  name: string
  slug: string
}

/**
 * Request body for accepting an organization invitation via token.
 */
export type OrgInvitationAccept = {
  token: string
}

/**
 * Request body for creating an organization invitation.
 */
export type OrgInvitationCreate = {
  email: string
  role?: OrgRole
}

/**
 * Response model for organization invitation.
 */
export type OrgInvitationRead = {
  id: string
  organization_id: string
  email: string
  role: OrgRole
  status: InvitationStatus
  invited_by: string | null
  expires_at: string
  created_at: string
  accepted_at: string | null
}

/**
 * Minimal response for public token-based invitation lookup.
 *
 * Excludes sensitive fields like email, invited_by, and timestamps
 * to reduce information disclosure when querying by token.
 */
export type OrgInvitationReadMinimal = {
  organization_id: string
  role: OrgRole
  status: InvitationStatus
  expires_at: string
}

export type OrgMemberRead = {
  user_id: string
  first_name: string | null
  last_name: string | null
  email: string
  role: UserRole
  is_active: boolean
  is_superuser: boolean
  is_verified: boolean
  last_login_at: string | null
}

/**
 * Organization response.
 */
export type OrgRead = {
  id: string
  name: string
  slug: string
  is_active: boolean
  created_at: string
  updated_at?: string | null
}

/**
 * Organization registry repository response.
 */
export type OrgRegistryRepositoryRead = {
  id: string
  origin: string
  last_synced_at?: string | null
  commit_sha?: string | null
  current_version_id?: string | null
}

/**
 * Organization registry sync request.
 */
export type OrgRegistrySyncRequest = {
  /**
   * Force sync by deleting the existing version first
   */
  force?: boolean
}

/**
 * Organization registry sync response.
 */
export type OrgRegistrySyncResponse = {
  success: boolean
  repository_id: string
  origin: string
  version?: string | null
  commit_sha?: string | null
  actions_count?: number | null
  forced?: boolean
  skipped?: boolean
  message?: string | null
}

/**
 * Response from promoting an organization registry version.
 */
export type OrgRegistryVersionPromoteResponse = {
  repository_id: string
  origin: string
  previous_version_id: string | null
  previous_version: string | null
  current_version_id: string
  current_version: string
}

/**
 * Organization registry version response.
 */
export type OrgRegistryVersionRead = {
  id: string
  repository_id: string
  version: string
  commit_sha?: string | null
  tarball_uri?: string | null
  created_at: string
}

/**
 * Organization-level roles.
 */
export type OrgRole = "member" | "admin" | "owner"

/**
 * Update organization request.
 */
export type OrgUpdate = {
  name?: string | null
  slug?: string | null
  is_active?: boolean | null
}

/**
 * Read schema for organization-scoped secrets.
 */
export type OrganizationSecretRead = {
  id: string
  type: SecretType
  name: string
  description?: string | null
  encrypted_keys: Blob | File
  environment: string
  tags?: {
    [key: string]: string
  } | null
  created_at: string
  updated_at: string
  organization_id: string
}

/**
 * Organization tier assignment response.
 */
export type OrganizationTierRead = {
  id: string
  organization_id: string
  tier_id: string
  max_concurrent_workflows: number | null
  max_action_executions_per_workflow: number | null
  max_concurrent_actions: number | null
  api_rate_limit: number | null
  api_burst_capacity: number | null
  entitlement_overrides: EntitlementsDict | null
  stripe_customer_id: string | null
  stripe_subscription_id: string | null
  expires_at: string | null
  created_at: string
  updated_at: string
  tier?: TierRead | null
}

/**
 * Update organization tier assignment request.
 */
export type OrganizationTierUpdate = {
  tier_id?: string | null
  max_concurrent_workflows?: number | null
  max_action_executions_per_workflow?: number | null
  max_concurrent_actions?: number | null
  api_rate_limit?: number | null
  api_burst_capacity?: number | null
  entitlement_overrides?: EntitlementsDict | null
  stripe_customer_id?: string | null
  stripe_subscription_id?: string | null
  expires_at?: string | null
}

export type OutputType =
  | "bool"
  | "float"
  | "int"
  | "str"
  | "list[bool]"
  | "list[float]"
  | "list[int]"
  | "list[str]"
  | {
      [key: string]: unknown
    }

/**
 * Event for when a case payload is changed.
 */
export type PayloadChangedEventRead = {
  /**
   * The execution ID of the workflow that triggered the event.
   */
  wf_exec_id?: string | null
  type?: "payload_changed"
  /**
   * The user who performed the action.
   */
  user_id?: string | null
  /**
   * The timestamp of the event.
   */
  created_at: string
}

/**
 * Platform registry settings response.
 */
export type PlatformRegistrySettingsRead = {
  git_repo_url?: string | null
  git_repo_package_name?: string | null
  git_allowed_domains?: Array<string> | null
}

/**
 * Update platform registry settings.
 */
export type PlatformRegistrySettingsUpdate = {
  git_repo_url?: string | null
  git_repo_package_name?: string | null
  git_allowed_domains?: Array<string> | null
}

export type Position = {
  x?: number
  y?: number
}

/**
 * Event for when a case priority is changed.
 */
export type PriorityChangedEventRead = {
  /**
   * The execution ID of the workflow that triggered the event.
   */
  wf_exec_id?: string | null
  type?: "priority_changed"
  old: CasePriority
  new: CasePriority
  /**
   * The user who performed the action.
   */
  user_id?: string | null
  /**
   * The timestamp of the event.
   */
  created_at: string
}

/**
 * Model for provider credential configuration.
 */
export type ProviderCredentialConfig = {
  /**
   * The provider name
   */
  provider: string
  /**
   * Human-readable label for the provider
   */
  label: string
  /**
   * Required credential fields
   */
  fields: Array<ProviderCredentialField>
}

/**
 * Model for defining credential fields required by a provider.
 */
export type ProviderCredentialField = {
  /**
   * The environment variable key for this credential
   */
  key: string
  /**
   * Human-readable label for the field
   */
  label: string
  /**
   * Input type: 'text' or 'password'
   */
  type: "text" | "password"
  /**
   * Help text describing this credential
   */
  description: string
  /**
   * Whether this field is required
   */
  required?: boolean
}

/**
 * Input type: 'text' or 'password'
 */
export type type = "text" | "password"

/**
 * Metadata for a provider.
 */
export type ProviderMetadata = {
  /**
   * Provider identifier
   */
  id: string
  /**
   * Human-readable provider name
   */
  name: string
  /**
   * Provider description
   */
  description: string
  /**
   * URL to provider logo
   */
  logo_url?: string | null
  /**
   * Setup instructions for the provider
   */
  setup_instructions?: string | null
  /**
   * Whether this provider requires additional configuration
   */
  requires_config?: boolean
  /**
   * Whether this provider is available for use
   */
  enabled?: boolean
  /**
   * URL to API documentation
   */
  api_docs_url?: string | null
  /**
   * URL to setup guide
   */
  setup_guide_url?: string | null
  /**
   * URL to troubleshooting documentation
   */
  troubleshooting_url?: string | null
}

export type ProviderRead = {
  grant_type: OAuthGrantType
  metadata: ProviderMetadata
  scopes: ProviderScopes
  config_schema: ProviderSchema
  integration_status: IntegrationStatus
  default_authorization_endpoint?: string | null
  default_token_endpoint?: string | null
  authorization_endpoint_help?: string | Array<string> | null
  token_endpoint_help?: string | Array<string> | null
  redirect_uri?: string | null
}

export type ProviderReadMinimal = {
  id: string
  name: string
  description: string
  requires_config: boolean
  integration_status: IntegrationStatus
  enabled: boolean
  grant_type: OAuthGrantType
}

/**
 * Schema for a provider.
 */
export type ProviderSchema = {
  json_schema: {
    [key: string]: unknown
  }
}

/**
 * Scope metadata for a provider.
 */
export type ProviderScopes = {
  /**
   * Default scopes for this provider.
   */
  default: Array<string>
}

export type PullDiagnostic = {
  workflow_path: string
  workflow_title: string | null
  error_type:
    | "conflict"
    | "validation"
    | "dependency"
    | "parse"
    | "github"
    | "system"
    | "transaction"
  message: string
  details: {
    [key: string]: unknown
  }
}

export type error_type =
  | "conflict"
  | "validation"
  | "dependency"
  | "parse"
  | "github"
  | "system"
  | "transaction"

export type PullResult = {
  success: boolean
  commit_sha: string
  workflows_found: number
  workflows_imported: number
  diagnostics: Array<PullDiagnostic>
  message: string
}

export type ReadinessResponse = {
  status: string
  registry: RegistryStatus
}

/**
 * A reasoning part of a message.
 */
export type ReasoningUIPart = {
  type: "reasoning"
  text: string
  state?: "streaming" | "done"
  providerMetadata?: {
    [key: string]: {
      [key: string]: unknown
    }
  }
}

export type state = "streaming" | "done"

export type ReceiveInteractionResponse = {
  message: string
}

/**
 * API create model for a registered action.
 */
export type RegistryActionCreate = {
  /**
   * The name of the action
   */
  name: string
  /**
   * The description of the action
   */
  description: string
  /**
   * The namespace of the action
   */
  namespace: string
  /**
   * The type of the action
   */
  type: "udf" | "template"
  /**
   * The origin of the action as a url
   */
  origin: string
  /**
   * The secrets required by the action
   */
  secrets?: Array<RegistrySecretType_Input> | null
  interface: RegistryActionInterface
  implementation: RegistryActionTemplateImpl_Input | RegistryActionUDFImpl
  /**
   * The default title of the action
   */
  default_title?: string | null
  /**
   * The presentation group of the action
   */
  display_group?: string | null
  /**
   * Link to documentation
   */
  doc_url?: string | null
  /**
   * Author of the action
   */
  author?: string | null
  /**
   * Marks action as deprecated along with message
   */
  deprecated?: string | null
  /**
   * The options for the action
   */
  options?: RegistryActionOptions
  /**
   * The repository id
   */
  repository_id: string
}

/**
 * The type of the action
 */
export type type2 = "udf" | "template"

export type RegistryActionInterface = {
  expects: {
    [key: string]: unknown
  }
  returns: unknown
}

export type RegistryActionOptions = {
  include_in_schema?: boolean
  requires_approval?: boolean
}

/**
 * API read model for a registered action.
 */
export type RegistryActionRead = {
  /**
   * The name of the action
   */
  name: string
  /**
   * The description of the action
   */
  description: string
  /**
   * The namespace of the action
   */
  namespace: string
  /**
   * The type of the action
   */
  type: "udf" | "template"
  /**
   * The origin of the action as a url
   */
  origin: string
  /**
   * The secrets required by the action
   */
  secrets?: Array<RegistrySecretType_Output> | null
  interface: RegistryActionInterface
  implementation: RegistryActionTemplateImpl_Output | RegistryActionUDFImpl
  /**
   * The default title of the action
   */
  default_title?: string | null
  /**
   * The presentation group of the action
   */
  display_group?: string | null
  /**
   * Link to documentation
   */
  doc_url?: string | null
  /**
   * Author of the action
   */
  author?: string | null
  /**
   * Marks action as deprecated along with message
   */
  deprecated?: string | null
  /**
   * The options for the action
   */
  options?: RegistryActionOptions
  /**
   * The repository id
   */
  repository_id: string
  /**
   * The registry action id
   */
  id: string
  /**
   * The full action identifier.
   */
  readonly action: string
  /**
   * Whether the action is a template.
   */
  readonly is_template: boolean
}

/**
 * API minimal read model for a registered action.
 */
export type RegistryActionReadMinimal = {
  /**
   * The registry action id
   */
  id: string
  /**
   * The name of the action
   */
  name: string
  /**
   * The description of the action
   */
  description: string
  /**
   * The namespace of the action
   */
  namespace: string
  /**
   * The type of the action
   */
  type: "udf" | "template"
  /**
   * The origin of the action as a url
   */
  origin: string
  /**
   * The default title of the action
   */
  default_title?: string | null
  /**
   * The presentation group of the action
   */
  display_group?: string | null
  /**
   * The full action identifier.
   */
  readonly action: string
}

export type RegistryActionTemplateImpl_Input = {
  type?: "template"
  /**
   * The template action
   */
  template_action: TemplateAction_Input
}

export type RegistryActionTemplateImpl_Output = {
  type?: "template"
  /**
   * The template action
   */
  template_action: TemplateAction_Output
}

export type RegistryActionUDFImpl = {
  type?: "udf"
  /**
   * The package url
   */
  url: string
  /**
   * The module name
   */
  module: string
  /**
   * The name of the UDF function name
   */
  name: string
}

/**
 * API update model for a registered action.
 */
export type RegistryActionUpdate = {
  /**
   * Update the name of the action
   */
  name?: string | null
  /**
   * Update the description of the action
   */
  description?: string | null
  /**
   * Update the secrets of the action
   */
  secrets?: Array<RegistrySecretType_Input> | null
  /**
   * Update the interface of the action
   */
  interface?: RegistryActionInterface | null
  /**
   * Update the implementation of the action
   */
  implementation?:
    | RegistryActionTemplateImpl_Input
    | RegistryActionUDFImpl
    | null
  /**
   * Update the default title of the action
   */
  default_title?: string | null
  /**
   * Update the display group of the action
   */
  display_group?: string | null
  /**
   * Update the doc url of the action
   */
  doc_url?: string | null
  /**
   * Update the author of the action
   */
  author?: string | null
  /**
   * Update the deprecation message of the action
   */
  deprecated?: string | null
  /**
   * Update the options of the action
   */
  options?: RegistryActionOptions | null
}

export type RegistryActionValidationErrorInfo = {
  type: TemplateActionValidationErrorType
  details: Array<string>
  is_template: boolean
  loc_primary: string
  loc_secondary?: string | null
}

/**
 * Registry version lock with action-level bindings for O(1) resolution.
 *
 * Attributes:
 * origins: Maps repository origin to pinned version string.
 * Example: {"tracecat_registry": "2024.12.10.123456"}
 * actions: Maps action name to its source origin.
 * Example: {"core.transform.reshape": "tracecat_registry"}
 */
export type RegistryLock = {
  origins: {
    [key: string]: string
  }
  actions: {
    [key: string]: string
  }
}

/**
 * OAuth secret for a provider.
 */
export type RegistryOAuthSecret_Input = {
  type?: "oauth"
  provider_id: string
  grant_type: "authorization_code" | "client_credentials"
  optional?: boolean
}

export type grant_type = "authorization_code" | "client_credentials"

/**
 * OAuth secret for a provider.
 */
export type RegistryOAuthSecret_Output = {
  type?: "oauth"
  provider_id: string
  grant_type: "authorization_code" | "client_credentials"
  optional?: boolean
  readonly name: string
}

export type RegistryRepositoryCreate = {
  /**
   * The origin of the repository
   */
  origin: string
}

/**
 * Error response model for registry sync failures.
 */
export type RegistryRepositoryErrorDetail = {
  id: string
  origin: string
  message: string
  errors: {
    [key: string]: Array<RegistryActionValidationErrorInfo>
  }
}

export type RegistryRepositoryRead = {
  id: string
  origin: string
  last_synced_at: string | null
  commit_sha: string | null
  current_version_id?: string | null
  actions: Array<RegistryActionRead>
}

export type RegistryRepositoryReadMinimal = {
  id: string
  origin: string
  last_synced_at: string | null
  commit_sha: string | null
  current_version_id?: string | null
}

/**
 * Parameters for syncing a repository to a specific commit.
 */
export type RegistryRepositorySync = {
  /**
   * The specific commit SHA to sync to. If None, syncs to HEAD.
   */
  target_commit_sha?: string | null
  /**
   * Force sync by deleting the existing version first, allowing re-sync.
   */
  force?: boolean
}

export type RegistryRepositoryUpdate = {
  last_synced_at?: string | null
  /**
   * The commit SHA of the repository
   */
  commit_sha?: string | null
  /**
   * The origin of the repository
   */
  origin?: string | null
}

export type RegistrySecret = {
  type?: "custom"
  name: string
  keys?: Array<string> | null
  optional_keys?: Array<string> | null
  optional?: boolean
}

export type RegistrySecretType_Input =
  | RegistrySecret
  | RegistryOAuthSecret_Input

export type RegistrySecretType_Output =
  | RegistrySecret
  | RegistryOAuthSecret_Output

export type RegistryStatus = {
  synced: boolean
  expected_version: string
  current_version: string | null
}

/**
 * Registry health status.
 */
export type RegistryStatusResponse = {
  total_repositories: number
  last_sync_at: string | null
  repositories: Array<RepositoryStatus>
}

/**
 * Event for when a case is reopened.
 */
export type ReopenedEventRead = {
  /**
   * The execution ID of the workflow that triggered the event.
   */
  wf_exec_id?: string | null
  type?: "case_reopened"
  old: CaseStatus
  new: CaseStatus
  /**
   * The user who performed the action.
   */
  user_id?: string | null
  /**
   * The timestamp of the event.
   */
  created_at: string
}

/**
 * Status of a single repository.
 */
export type RepositoryStatus = {
  id: string
  name: string
  origin: string
  last_synced_at: string | null
  commit_sha: string | null
  current_version_id?: string | null
}

/**
 * Result of syncing a single repository.
 */
export type RepositorySyncResult = {
  repository_id: string
  repository_name: string
  success: boolean
  error?: string | null
  version?: string | null
  actions_count?: number | null
}

/**
 * Configuration for a response interaction.
 */
export type ResponseInteraction = {
  type: "response"
  /**
   * The timeout for the interaction in seconds.
   */
  timeout?: number | null
}

export type ResultMessage = {
  subtype: string
  duration_ms: number
  duration_api_ms: number
  is_error: boolean
  num_turns: number
  session_id: string
  total_cost_usd?: number | null
  usage?: {
    [key: string]: unknown
  } | null
  result?: string | null
  structured_output?: unknown
}

export type RetryPromptPart = {
  content: Array<ErrorDetails> | string
  tool_name?: string | null
  tool_call_id?: string
  timestamp?: string
  part_kind?: "retry-prompt"
}

/**
 * The identity and authorization of a user or service.
 *
 * Params
 * ------
 * type : Literal["user", "service"]
 * The type of role.
 * user_id : UUID | None
 * The user's ID, or the service's user_id.
 * This can be None for internal services, or when a user hasn't been set for the role.
 * service_id : str | None = None
 * The service's role name, or None if the role is a user.
 *
 *
 * User roles
 * ----------
 * - User roles are authenticated via JWT.
 * - The `user_id` is the user's JWT 'sub' claim.
 * - User roles do not have an associated `service_id`, this must be None.
 *
 * Service roles
 * -------------
 * - Service roles are authenticated via API key.
 * - Used for internal services to authenticate with the API.
 * - A service's `user_id` is the user it's acting on behalf of. This can be None for internal services.
 */
export type Role = {
  type: "user" | "service"
  workspace_id?: string | null
  organization_id?: string
  workspace_role?: WorkspaceRole | null
  org_role?: OrgRole | null
  user_id?: string | null
  access_level?: AccessLevel
  service_id:
    | "tracecat-api"
    | "tracecat-bootstrap"
    | "tracecat-cli"
    | "tracecat-executor"
    | "tracecat-agent-executor"
    | "tracecat-llm-gateway"
    | "tracecat-mcp"
    | "tracecat-runner"
    | "tracecat-schedule-runner"
    | "tracecat-service"
    | "tracecat-ui"
}

export type type3 = "user" | "service"

export type service_id =
  | "tracecat-api"
  | "tracecat-bootstrap"
  | "tracecat-cli"
  | "tracecat-executor"
  | "tracecat-agent-executor"
  | "tracecat-llm-gateway"
  | "tracecat-mcp"
  | "tracecat-runner"
  | "tracecat-schedule-runner"
  | "tracecat-service"
  | "tracecat-ui"

/**
 * This object contains all the information needed to execute an action.
 */
export type RunActionInput = {
  task: ActionStatement
  exec_context: ExecutionContext
  run_context: RunContext
  interaction_context?: InteractionContext | null
  stream_id?: string
  session_id?: string | null
  registry_lock: RegistryLock
}

/**
 * This is the runtime context model for a workflow run. Passed into activities.
 */
export type RunContext = {
  wf_id: string
  wf_exec_id: string
  wf_run_id: string
  environment: string
  logical_time: string
}

/**
 * LLM usage associated with an agent run.
 */
export type RunUsage = {
  requests?: number
  tool_calls?: number
  input_tokens?: number
  output_tokens?: number
}

export type SAMLDatabaseLoginResponse = {
  redirect_url: string
}

export type SAMLSettingsRead = {
  saml_enabled: boolean
  saml_enforced: boolean
  saml_idp_metadata_url?: string | null
  saml_sp_acs_url: string
}

export type SAMLSettingsUpdate = {
  /**
   * Whether SAML is enabled.
   */
  saml_enabled?: boolean
  /**
   * Whether SAML is enforced. If true, users can only use SAML to authenticate. Requires SAML to be enabled.
   */
  saml_enforced?: boolean
  saml_idp_metadata_url?: string | null
}

export type ScheduleCreate = {
  workflow_id: string
  inputs?: {
    [key: string]: unknown
  } | null
  cron?: string | null
  /**
   * ISO 8601 duration string
   */
  every?: string | null
  /**
   * ISO 8601 duration string
   */
  offset?: string | null
  /**
   * ISO 8601 datetime string
   */
  start_at?: string | null
  /**
   * ISO 8601 datetime string
   */
  end_at?: string | null
  status?: "online" | "offline"
  /**
   * The maximum number of seconds to wait for the workflow to complete
   */
  timeout?: number
}

export type status2 = "online" | "offline"

export type ScheduleRead = {
  id: string
  workspace_id: string
  created_at: string
  updated_at: string
  workflow_id: string
  inputs?: {
    [key: string]: unknown
  } | null
  cron?: string | null
  every?: string | null
  offset?: string | null
  start_at?: string | null
  end_at?: string | null
  timeout?: number | null
  status: "online" | "offline"
}

export type ScheduleSearch = {
  workflow_id?: string | null
  limit?: number
  order_by?: string
  query?: string | null
  group_by?: Array<string> | null
  agg?: string | null
}

export type ScheduleUpdate = {
  inputs?: {
    [key: string]: unknown
  } | null
  cron?: string | null
  /**
   * ISO 8601 duration string
   */
  every?: string | null
  /**
   * ISO 8601 duration string
   */
  offset?: string | null
  /**
   * ISO 8601 datetime string
   */
  start_at?: string | null
  /**
   * ISO 8601 datetime string
   */
  end_at?: string | null
  status?: "online" | "offline" | null
}

/**
 * Create a new secret.
 *
 * Secret types
 * ------------
 * - `custom`: Arbitrary user-defined types
 * - `token`: A token, e.g. API Key, JWT Token (TBC)
 * - `oauth2`: OAuth2 Client Credentials (TBC)
 * - `mtls`: TLS client certificate and key
 * - `ca-cert`: Certificate authority bundle
 */
export type SecretCreate = {
  type?: SecretType
  name: string
  description?: string | null
  keys: Array<SecretKeyValue>
  tags?: {
    [key: string]: string
  } | null
  environment?: string
}

/**
 * Aggregated secret definition from registry actions.
 */
export type SecretDefinition = {
  name: string
  keys: Array<string>
  optional_keys?: Array<string> | null
  optional?: boolean
  actions: Array<string>
  action_count: number
}

export type SecretKeyValue = {
  key: string
  value: string
}

/**
 * Read schema for workspace-scoped secrets.
 */
export type SecretRead = {
  id: string
  type: SecretType
  name: string
  description?: string | null
  encrypted_keys: Blob | File
  environment: string
  tags?: {
    [key: string]: string
  } | null
  created_at: string
  updated_at: string
  workspace_id: string
}

export type SecretReadMinimal = {
  id: string
  type: SecretType
  name: string
  description?: string | null
  keys: Array<string>
  environment: string
}

/**
 * The type of a secret.
 */
export type SecretType =
  | "custom"
  | "ssh-key"
  | "mtls"
  | "ca-cert"
  | "github-app"

/**
 * Update a secret.
 *
 * Secret types
 * ------------
 * - `custom`: Arbitrary user-defined types
 * - `token`: A token, e.g. API Key, JWT Token (TBC)
 * - `oauth2`: OAuth2 Client Credentials (TBC)
 * - `mtls`: TLS client certificate and key
 * - `ca-cert`: Certificate authority bundle
 */
export type SecretUpdate = {
  type?: SecretType | null
  name?: string | null
  description?: string | null
  keys?: Array<SecretKeyValue> | null
  tags?: {
    [key: string]: string
  } | null
  environment?: string | null
}

/**
 * Detail of a secret validation result.
 */
export type SecretValidationDetail = {
  environment: string
  secret_name: string
}

/**
 * Result of validating credentials.
 */
export type SecretValidationResult = {
  type?: "secret"
  status: "success" | "error"
  msg?: string
  detail?: SecretValidationDetail | null
  ref?: string | null
}

export type Select = {
  component_id?: "select"
  options?: Array<string> | null
  multiple?: boolean
}

export type SessionRead = {
  id: string
  created_at: string
  user_id: string
  user_email: string
}

export type Session_Any_ = {
  id: string
  /**
   * The events in the session.
   */
  events?: Array<unknown> | null
}

/**
 * Event for when a case severity is changed.
 */
export type SeverityChangedEventRead = {
  /**
   * The execution ID of the workflow that triggered the event.
   */
  wf_exec_id?: string | null
  type?: "severity_changed"
  old: CaseSeverity
  new: CaseSeverity
  /**
   * The user who performed the action.
   */
  user_id?: string | null
  /**
   * The timestamp of the event.
   */
  created_at: string
}

/**
 * A document source part of a message.
 */
export type SourceDocumentUIPart = {
  type: "source-document"
  sourceId: string
  mediaType: string
  title: string
  filename?: string
  providerMetadata?: {
    [key: string]: {
      [key: string]: unknown
    }
  }
}

/**
 * A source URL part of a message.
 */
export type SourceUrlUIPart = {
  type: "source-url"
  sourceId: string
  url: string
  title?: string
  providerMetadata?: {
    [key: string]: {
      [key: string]: unknown
    }
  }
}

/**
 * A sentinel user ID that represents the current user.
 */
export type SpecialUserID = "current"

/**
 * Supported SQL types.
 */
export type SqlType =
  | "TEXT"
  | "INTEGER"
  | "NUMERIC"
  | "DATE"
  | "BOOLEAN"
  | "TIMESTAMP"
  | "TIMESTAMPTZ"
  | "JSONB"
  | "UUID"
  | "SELECT"
  | "MULTI_SELECT"

/**
 * Event for when a case status is changed.
 */
export type StatusChangedEventRead = {
  /**
   * The execution ID of the workflow that triggered the event.
   */
  wf_exec_id?: string | null
  type?: "status_changed"
  old: CaseStatus
  new: CaseStatus
  /**
   * The user who performed the action.
   */
  user_id?: string | null
  /**
   * The timestamp of the event.
   */
  created_at: string
}

/**
 * A step boundary part of a message.
 */
export type StepStartUIPart = {
  type: "step-start"
}

export type StreamEvent = {
  uuid: string
  session_id: string
  event: {
    [key: string]: unknown
  }
  parent_tool_use_id?: string | null
}

export type SyntaxToken = {
  type: string
  value: string
  start: number
  end: number
}

export type SystemMessage = {
  subtype: string
  data: {
    [key: string]: unknown
  }
}

/**
 * Create model for a table column.
 */
export type TableColumnCreate = {
  /**
   * The name of the column
   */
  name: string
  /**
   * The SQL type of the column
   */
  type: SqlType
  nullable?: boolean
  default?: unknown | null
  options?: Array<string> | null
}

/**
 * Definition for a table column.
 */
export type TableColumnRead = {
  id: string
  name: string
  type: SqlType
  nullable?: boolean
  default?: unknown | null
  is_index?: boolean
  options?: Array<string> | null
}

/**
 * Update model for a table column.
 */
export type TableColumnUpdate = {
  /**
   * The name of the column
   */
  name?: string | null
  /**
   * The SQL type of the column
   */
  type?: SqlType | null
  /**
   * Whether the column can be null
   */
  nullable?: boolean | null
  /**
   * The default value of the column
   */
  default?: unknown | null
  /**
   * Whether the column is an index
   */
  is_index?: boolean | null
  options?: Array<string> | null
}

/**
 * Create model for a table.
 */
export type TableCreate = {
  /**
   * The name of the table
   */
  name: string
  /**
   * The columns of the table
   */
  columns?: Array<TableColumnCreate>
}

/**
 * Response model for importing a table from CSV.
 */
export type TableImportResponse = {
  table: TableRead
  rows_inserted: number
  column_mapping: Array<InferredColumn>
}

/**
 * Read model for a table.
 */
export type TableRead = {
  id: string
  name: string
  columns: Array<TableColumnRead>
}

/**
 * Read model for a table.
 */
export type TableReadMinimal = {
  id: string
  name: string
}

/**
 * Insert model for a table row.
 */
export type TableRowInsert = {
  data: {
    [key: string]: unknown
  }
  upsert?: boolean
}

/**
 * Request body for batch inserting rows.
 */
export type TableRowInsertBatch = {
  rows: Array<{
    [key: string]: unknown
  }>
  upsert?: boolean
}

/**
 * Response for batch insert operation.
 */
export type TableRowInsertBatchResponse = {
  rows_inserted: number
}

/**
 * Read model for a table row.
 */
export type TableRowRead = {
  id: string
  created_at: string
  updated_at: string
  [key: string]: unknown | string
}

/**
 * Update model for a table.
 */
export type TableUpdate = {
  /**
   * The name of the table
   */
  name?: string | null
}

/**
 * Event for when a tag is added to a case.
 */
export type TagAddedEventRead = {
  /**
   * The execution ID of the workflow that triggered the event.
   */
  wf_exec_id?: string | null
  type?: "tag_added"
  tag_id: string
  tag_ref: string
  tag_name: string
  /**
   * The user who performed the action.
   */
  user_id?: string | null
  /**
   * The timestamp of the event.
   */
  created_at: string
}

/**
 * Model for creating new tags with validation.
 */
export type TagCreate = {
  name: string
  /**
   * Hex color code
   */
  color?: string | null
}

export type TagInput = {
  component_id?: "tag-input"
}

/**
 * Model for reading tag data with validation.
 */
export type TagRead = {
  id: string
  name: string
  /**
   * Slug-like identifier derived from name, used for API lookups
   */
  ref: string
  /**
   * Hex color code
   */
  color?: string | null
}

/**
 * Event for when a tag is removed from a case.
 */
export type TagRemovedEventRead = {
  /**
   * The execution ID of the workflow that triggered the event.
   */
  wf_exec_id?: string | null
  type?: "tag_removed"
  tag_id: string
  tag_ref: string
  tag_name: string
  /**
   * The user who performed the action.
   */
  user_id?: string | null
  /**
   * The timestamp of the event.
   */
  created_at: string
}

/**
 * Model for updating existing tags with validation.
 */
export type TagUpdate = {
  name?: string | null
  /**
   * Hex color code
   */
  color?: string | null
}

/**
 * Event for when a task assignee is changed.
 */
export type TaskAssigneeChangedEventRead = {
  /**
   * The execution ID of the workflow that triggered the event.
   */
  wf_exec_id?: string | null
  type?: "task_assignee_changed"
  task_id: string
  title: string
  old: string | null
  new: string | null
  /**
   * The user who performed the action.
   */
  user_id?: string | null
  /**
   * The timestamp of the event.
   */
  created_at: string
}

/**
 * Event for when a task is created for a case.
 */
export type TaskCreatedEventRead = {
  /**
   * The execution ID of the workflow that triggered the event.
   */
  wf_exec_id?: string | null
  type?: "task_created"
  task_id: string
  title: string
  /**
   * The user who performed the action.
   */
  user_id?: string | null
  /**
   * The timestamp of the event.
   */
  created_at: string
}

/**
 * Event for when a task is deleted for a case.
 */
export type TaskDeletedEventRead = {
  /**
   * The execution ID of the workflow that triggered the event.
   */
  wf_exec_id?: string | null
  type?: "task_deleted"
  task_id: string
  title?: string | null
  /**
   * The user who performed the action.
   */
  user_id?: string | null
  /**
   * The timestamp of the event.
   */
  created_at: string
}

/**
 * Event for when a task priority is changed.
 */
export type TaskPriorityChangedEventRead = {
  /**
   * The execution ID of the workflow that triggered the event.
   */
  wf_exec_id?: string | null
  type?: "task_priority_changed"
  task_id: string
  title: string
  old: CasePriority
  new: CasePriority
  /**
   * The user who performed the action.
   */
  user_id?: string | null
  /**
   * The timestamp of the event.
   */
  created_at: string
}

/**
 * Result of executing a DSL node.
 *
 * With uniform envelope design, `result` is always a StoredObject:
 * - InlineObject when data is small or externalization is disabled
 * - ExternalObject when data is large and externalization is enabled
 */
export type TaskResult = {
  result: InlineObject | ExternalObject | CollectionObject
  result_typename: string
  error?: unknown | null
  error_typename?: string | null
  interaction?: unknown | null
  interaction_id?: string | null
  interaction_type?: string | null
  collection_index?: number | null
}

/**
 * Event for when a task status is changed.
 */
export type TaskStatusChangedEventRead = {
  /**
   * The execution ID of the workflow that triggered the event.
   */
  wf_exec_id?: string | null
  type?: "task_status_changed"
  task_id: string
  title: string
  old: CaseTaskStatus
  new: CaseTaskStatus
  /**
   * The user who performed the action.
   */
  user_id?: string | null
  /**
   * The timestamp of the event.
   */
  created_at: string
}

/**
 * Event for when a task workflow is changed.
 */
export type TaskWorkflowChangedEventRead = {
  /**
   * The execution ID of the workflow that triggered the event.
   */
  wf_exec_id?: string | null
  type?: "task_workflow_changed"
  task_id: string
  title: string
  old: string | null
  new: string | null
  /**
   * The user who performed the action.
   */
  user_id?: string | null
  /**
   * The timestamp of the event.
   */
  created_at: string
}

export type TemplateAction_Input = {
  type?: "action"
  definition: TemplateActionDefinition_Input
}

export type TemplateAction_Output = {
  type?: "action"
  definition: TemplateActionDefinition_Output
}

export type TemplateActionDefinition_Input = {
  /**
   * The action name
   */
  name: string
  /**
   * The namespace of the action
   */
  namespace: string
  /**
   * The title of the action
   */
  title: string
  /**
   * The description of the action
   */
  description?: string
  /**
   * The display group of the action
   */
  display_group: string
  /**
   * Link to documentation
   */
  doc_url?: string | null
  /**
   * Author of the action
   */
  author?: string | null
  /**
   * Marks action as deprecated along with message
   */
  deprecated?: string | null
  /**
   * The secrets to pass to the action
   */
  secrets?: Array<RegistrySecretType_Input> | null
  /**
   * The arguments to pass to the action
   */
  expects: {
    [key: string]: ExpectedField_Input
  }
  /**
   * The sequence of steps for the action
   */
  steps: Array<ActionStep>
  /**
   * The result of the action
   */
  returns:
    | string
    | Array<string>
    | {
        [key: string]: unknown
      }
}

export type TemplateActionDefinition_Output = {
  /**
   * The action name
   */
  name: string
  /**
   * The namespace of the action
   */
  namespace: string
  /**
   * The title of the action
   */
  title: string
  /**
   * The description of the action
   */
  description?: string
  /**
   * The display group of the action
   */
  display_group: string
  /**
   * Link to documentation
   */
  doc_url?: string | null
  /**
   * Author of the action
   */
  author?: string | null
  /**
   * Marks action as deprecated along with message
   */
  deprecated?: string | null
  /**
   * The secrets to pass to the action
   */
  secrets?: Array<RegistrySecretType_Output> | null
  /**
   * The arguments to pass to the action
   */
  expects: {
    [key: string]: ExpectedField_Output
  }
  /**
   * The sequence of steps for the action
   */
  steps: Array<ActionStep>
  /**
   * The result of the action
   */
  returns:
    | string
    | Array<string>
    | {
        [key: string]: unknown
      }
}

/**
 * Result of visiting an expression node.
 */
export type TemplateActionExprValidationResult = {
  type?: "action_template"
  status: "success" | "error"
  msg?: string
  detail?: Array<ValidationDetail> | null
  ref?: string | null
  expression?: string | null
  expression_type: ExprType
  loc: Array<string | number>
}

export type TemplateActionValidationErrorType =
  | "ACTION_NOT_FOUND"
  | "ACTION_NAME_CONFLICT"
  | "STEP_VALIDATION_ERROR"
  | "EXPRESSION_VALIDATION_ERROR"
  | "SERIALIZATION_ERROR"

export type Text = {
  component_id?: "text"
}

export type TextArea = {
  component_id?: "text-area"
  rows?: number
  placeholder?: string
}

export type TextBlock = {
  text: string
}

/**
 * A text part of a message.
 */
export type TextUIPart = {
  type: "text"
  text: string
  state?: "streaming" | "done"
  providerMetadata?: {
    [key: string]: {
      [key: string]: unknown
    }
  }
}

export type ThinkingBlock = {
  thinking: string
  signature: string
}

/**
 * Create tier request.
 */
export type TierCreate = {
  display_name: string
  max_concurrent_workflows?: number | null
  max_action_executions_per_workflow?: number | null
  max_concurrent_actions?: number | null
  api_rate_limit?: number | null
  api_burst_capacity?: number | null
  entitlements?: EntitlementsDict
  is_default?: boolean
  sort_order?: number
}

/**
 * Tier response schema.
 */
export type TierRead = {
  id: string
  display_name: string
  max_concurrent_workflows: number | null
  max_action_executions_per_workflow: number | null
  max_concurrent_actions: number | null
  api_rate_limit: number | null
  api_burst_capacity: number | null
  entitlements: EntitlementsDict
  is_default: boolean
  sort_order: number
  is_active: boolean
  created_at: string
  updated_at: string
}

/**
 * Update tier request.
 */
export type TierUpdate = {
  display_name?: string | null
  max_concurrent_workflows?: number | null
  max_action_executions_per_workflow?: number | null
  max_concurrent_actions?: number | null
  api_rate_limit?: number | null
  api_burst_capacity?: number | null
  entitlements?: EntitlementsDict | null
  is_default?: boolean | null
  sort_order?: number | null
  is_active?: boolean | null
}

export type Toggle = {
  label_on?: string
  label_off?: string
  component_id?: "toggle"
}

export type ToolApproved = {
  override_args?: {
    [key: string]: unknown
  } | null
  kind?: "tool-approved"
}

export type ToolDenied = {
  message?: string
  kind?: "tool-denied"
}

export type ToolResultBlock = {
  tool_use_id: string
  content?:
    | string
    | Array<{
        [key: string]: unknown
      }>
    | null
  is_error?: boolean | null
}

export type ToolReturn = {
  return_value: unknown
  content?:
    | string
    | Array<
        | string
        | ImageUrl
        | AudioUrl
        | DocumentUrl
        | VideoUrl
        | BinaryContent
        | CachePoint
      >
    | null
  metadata?: unknown
  kind?: "tool-return"
}

export type ToolUIPartInputAvailable = {
  type: string
  toolCallId: string
  state: "input-available"
  input: unknown
  providerExecuted?: boolean
  output?: null
  errorText?: null
  callProviderMetadata?: {
    [key: string]: {
      [key: string]: unknown
    }
  }
}

export type ToolUIPartInputStreaming = {
  type: string
  toolCallId: string
  state: "input-streaming"
  input?: unknown
  providerExecuted?: boolean
  output?: null
  errorText?: null
}

export type ToolUIPartOutputAvailable = {
  type: string
  toolCallId: string
  state: "output-available"
  input: unknown
  output: unknown
  errorText?: null
  providerExecuted?: boolean
  callProviderMetadata?: {
    [key: string]: {
      [key: string]: unknown
    }
  }
  preliminary?: boolean
}

export type ToolUIPartOutputError = {
  type: string
  toolCallId: string
  state: "output-error"
  input?: unknown
  rawInput?: unknown
  output?: null
  errorText: string
  providerExecuted?: boolean
  callProviderMetadata?: {
    [key: string]: {
      [key: string]: unknown
    }
  }
}

export type ToolUseBlock = {
  id: string
  name: string
  input: {
    [key: string]: unknown
  }
}

export type Trigger = {
  type: "schedule" | "webhook"
  ref: string
  args?: {
    [key: string]: unknown
  }
}

export type type4 = "schedule" | "webhook"

/**
 * Trigger type for a workflow execution.
 */
export type TriggerType = "manual" | "scheduled" | "webhook"

/**
 * Pydantic model for AI SDK UI Messages, used for validation between
 * frontend and backend.
 */
export type UIMessage = {
  id: string
  role: "system" | "user" | "assistant"
  metadata?: unknown | null
  parts: Array<
    | TextUIPart
    | ReasoningUIPart
    | SourceUrlUIPart
    | SourceDocumentUIPart
    | FileUIPart
    | StepStartUIPart
    | DynamicToolUIPartInputStreaming
    | DynamicToolUIPartInputAvailable
    | DynamicToolUIPartOutputAvailable
    | DynamicToolUIPartOutputError
    | ToolUIPartInputStreaming
    | ToolUIPartInputAvailable
    | ToolUIPartOutputAvailable
    | ToolUIPartOutputError
    | DataUIPart
  >
}

export type role = "system" | "user" | "assistant"

/**
 * Event for when a case is updated.
 */
export type UpdatedEventRead = {
  /**
   * The execution ID of the workflow that triggered the event.
   */
  wf_exec_id?: string | null
  type?: "case_updated"
  field: "summary"
  old: string | null
  new: string | null
  /**
   * The user who performed the action.
   */
  user_id?: string | null
  /**
   * The timestamp of the event.
   */
  created_at: string
}

export type UserCreate = {
  email: string
  password: string
  is_active?: boolean | null
  is_superuser?: boolean | null
  is_verified?: boolean | null
  first_name?: string | null
  last_name?: string | null
}

export type UserMessage = {
  content:
    | string
    | Array<TextBlock | ThinkingBlock | ToolUseBlock | ToolResultBlock>
  uuid?: string | null
  parent_tool_use_id?: string | null
}

export type UserRead = {
  id: string
  email: string
  is_active?: boolean
  is_superuser?: boolean
  is_verified?: boolean
  role: UserRole
  first_name?: string | null
  last_name?: string | null
  settings: {
    [key: string]: unknown
  }
}

export type UserRole = "basic" | "admin"

export type UserUpdate = {
  password?: string | null
  email?: string | null
  is_active?: boolean | null
  is_superuser?: boolean | null
  is_verified?: boolean | null
  role?: UserRole | null
  first_name?: string | null
  last_name?: string | null
  settings?: {
    [key: string]: unknown
  } | null
}

export type ValidationDetail = {
  type: string
  msg: string
  loc?: Array<number | string> | null
}

export type ValidationError = {
  loc: Array<string | number>
  msg: string
  type: string
}

export type ValidationResult =
  | DSLValidationResult
  | SecretValidationResult
  | ExprValidationResult
  | TemplateActionExprValidationResult
  | ActionValidationResult

export type VariableCreate = {
  name: string
  description?: string | null
  values: {
    [key: string]: unknown
  }
  tags?: {
    [key: string]: string
  } | null
  environment?: string
}

export type VariableRead = {
  id: string
  name: string
  description: string | null
  values: {
    [key: string]: unknown
  }
  environment: string
  tags: {
    [key: string]: string
  } | null
  workspace_id: string
  created_at: string
  updated_at: string
}

export type VariableReadMinimal = {
  id: string
  name: string
  description: string | null
  values: {
    [key: string]: unknown
  }
  environment: string
}

export type VariableUpdate = {
  name?: string | null
  description?: string | null
  values?: {
    [key: string]: unknown
  } | null
  tags?: {
    [key: string]: string
  } | null
  environment?: string | null
}

/**
 * Vercel AI SDK format request with structured UI messages.
 */
export type VercelChatRequest = {
  kind?: "vercel"
  /**
   * User message in Vercel UI format
   */
  message: UIMessage
  /**
   * AI model to use
   */
  model?: string
  /**
   * AI model provider
   */
  model_provider?: string
  /**
   * Optional base URL for the model provider
   */
  base_url?: string | null
}

export type VideoUrl = {
  url: string
  force_download?: boolean
  vendor_metadata?: {
    [key: string]: unknown
  } | null
  kind?: "video-url"
  /**
   * Return the media type of the file, based on the URL or the provided `media_type`.
   */
  readonly media_type: string
  /**
   * The identifier of the file, such as a unique ID.
   *
   * This identifier can be provided to the model in a message to allow it to refer to this file in a tool call argument,
   * and the tool can look up the file in question by iterating over the message history and finding the matching `FileUrl`.
   *
   * This identifier is only automatically passed to the model when the `FileUrl` is returned by a tool.
   * If you're passing the `FileUrl` as a user message, it's up to you to include a separate text part with the identifier,
   * e.g. "This is file <identifier>:" preceding the `FileUrl`.
   *
   * It's also included in inline-text delimiters for providers that require inlining text documents, so the model can
   * distinguish multiple files.
   */
  readonly identifier: string
}

export type WaitStrategy = "wait" | "detach"

export type WebhookApiKeyGenerateResponse = {
  api_key: string
  preview: string
  created_at: string
}

export type WebhookApiKeyRead = {
  preview: string
  created_at: string
  last_used_at?: string | null
  revoked_at?: string | null
  is_active?: boolean
}

export type WebhookCreate = {
  status?: WebhookStatus
  /**
   * Methods to allow
   */
  methods?: Array<WebhookMethod>
  entrypoint_ref?: string | null
  allowlisted_cidrs?: Array<string>
}

export type WebhookMethod = "GET" | "POST"

export type WebhookRead = {
  id: string
  secret: string
  status: WebhookStatus
  entrypoint_ref?: string | null
  allowlisted_cidrs?: Array<string>
  filters?: {
    [key: string]: unknown
  }
  /**
   * Methods to allow
   */
  methods?: Array<WebhookMethod>
  workflow_id: string
  url: string
  api_key?: WebhookApiKeyRead | null
}

export type WebhookStatus = "online" | "offline"

export type WebhookUpdate = {
  status?: WebhookStatus | null
  methods?: Array<WebhookMethod> | null
  entrypoint_ref?: string | null
  allowlisted_cidrs?: Array<string> | null
}

export type WorkflowAlias = {
  component_id?: "workflow-alias"
}

export type WorkflowCommitResponse = {
  workflow_id: string
  status: "success" | "failure"
  message: string
  errors?: Array<ValidationResult> | null
  metadata?: {
    [key: string]: unknown
  } | null
}

export type status3 = "success" | "failure"

/**
 * API response model for persisted workflow definitions.
 */
export type WorkflowDefinitionRead = {
  id: string
  workflow_id: string | null
  workspace_id: string
  version: number
  content?: {
    [key: string]: unknown
  } | null
  created_at: string
  updated_at: string
}

export type WorkflowDefinitionReadMinimal = {
  id: string
  version: number
  created_at: string
}

export type WorkflowDirectoryItem = {
  id: string
  title: string
  description: string
  status: string
  icon_url: string | null
  created_at: string
  updated_at: string
  version: number | null
  tags?: Array<TagRead> | null
  alias?: string | null
  error_handler?: string | null
  latest_definition?: WorkflowDefinitionReadMinimal | null
  folder_id?: string | null
  type: "workflow"
}

export type WorkflowDslPublish = {
  message?: string | null
}

export type WorkflowEntrypointValidationRequest = {
  expects?: {
    [key: string]: ExpectedField_Input
  } | null
}

export type WorkflowEntrypointValidationResponse = {
  valid: boolean
  errors?: Array<ValidationResult>
}

/**
 * The event types we care about.
 */
export type WorkflowEventType =
  | "WORKFLOW_EXECUTION_STARTED"
  | "WORKFLOW_EXECUTION_COMPLETED"
  | "WORKFLOW_EXECUTION_FAILED"
  | "WORKFLOW_EXECUTION_TERMINATED"
  | "WORKFLOW_EXECUTION_CANCELED"
  | "WORKFLOW_EXECUTION_CONTINUED_AS_NEW"
  | "WORKFLOW_EXECUTION_TIMED_OUT"
  | "ACTIVITY_TASK_SCHEDULED"
  | "ACTIVITY_TASK_STARTED"
  | "ACTIVITY_TASK_COMPLETED"
  | "ACTIVITY_TASK_FAILED"
  | "ACTIVITY_TASK_TIMED_OUT"
  | "ACTIVITY_TASK_CANCELED"
  | "CHILD_WORKFLOW_EXECUTION_STARTED"
  | "CHILD_WORKFLOW_EXECUTION_COMPLETED"
  | "CHILD_WORKFLOW_EXECUTION_FAILED"
  | "CHILD_WORKFLOW_EXECUTION_CANCELED"
  | "CHILD_WORKFLOW_EXECUTION_TERMINATED"
  | "START_CHILD_WORKFLOW_EXECUTION_INITIATED"
  | "CHILD_WORKFLOW_EXECUTION_TIMED_OUT"
  | "WORKFLOW_EXECUTION_SIGNALED"
  | "WORKFLOW_EXECUTION_UPDATE_ACCEPTED"
  | "WORKFLOW_EXECUTION_UPDATE_REJECTED"
  | "WORKFLOW_EXECUTION_UPDATE_COMPLETED"

export type WorkflowExecutionCreate = {
  workflow_id: string
  inputs?: unknown | null
  /**
   * Override the workflow's time anchor for FN.now() and related functions. If not provided, computed from TemporalScheduledStartTime (for schedules) or workflow start_time (for other triggers).
   */
  time_anchor?: string | null
}

export type WorkflowExecutionCreateResponse = {
  message: string
  wf_id: string
  wf_exec_id: string
  payload?: unknown
}

export type WorkflowExecutionEvent = {
  event_id: number
  event_time: string
  event_type: WorkflowEventType
  task_id: number
  /**
   * The action group of the event. We use this to keep track of what events are related to each other.
   */
  event_group?: EventGroup_TypeVar_ | null
  failure?: EventFailure | null
  result?: unknown | null
  role?: Role | null
  parent_wf_exec_id?: string | null
  workflow_timeout?: number | null
}

export type WorkflowExecutionEventCompact_Any__Union_AgentOutput__Any___Any_ = {
  source_event_id: number
  schedule_time: string
  start_time?: string | null
  close_time?: string | null
  curr_event_type: WorkflowEventType
  status: WorkflowExecutionEventStatus
  action_name: string
  action_ref: string
  action_input?: unknown
  action_result?: AgentOutput | unknown | null
  action_error?: EventFailure | null
  stream_id?: string
  child_wf_exec_id?: string | null
  child_wf_count?: number
  loop_index?: number | null
  child_wf_wait_strategy?: WaitStrategy | null
  session?: Session_Any_ | null
}

export type WorkflowExecutionEventStatus =
  | "SCHEDULED"
  | "STARTED"
  | "COMPLETED"
  | "FAILED"
  | "CANCELED"
  | "TERMINATED"
  | "TIMED_OUT"
  | "UNKNOWN"
  | "DETACHED"

export type WorkflowExecutionRead = {
  /**
   * The ID of the workflow execution
   */
  id: string
  /**
   * The run ID of the workflow execution
   */
  run_id: string
  /**
   * The start time of the workflow execution
   */
  start_time: string
  /**
   * When this workflow run started or should start.
   */
  execution_time?: string | null
  /**
   * When the workflow was closed if closed.
   */
  close_time?: string | null
  status:
    | "RUNNING"
    | "COMPLETED"
    | "FAILED"
    | "CANCELED"
    | "TERMINATED"
    | "CONTINUED_AS_NEW"
    | "TIMED_OUT"
  workflow_type: string
  task_queue: string
  /**
   * Number of events in the history
   */
  history_length: number
  parent_wf_exec_id?: string | null
  trigger_type: TriggerType
  /**
   * Execution type (draft or published). Draft uses the draft workflow graph.
   */
  execution_type?: ExecutionType
  /**
   * The events in the workflow execution
   */
  events: Array<WorkflowExecutionEvent>
  /**
   * The interactions in the workflow execution
   */
  interactions?: Array<InteractionRead>
}

export type status4 =
  | "RUNNING"
  | "COMPLETED"
  | "FAILED"
  | "CANCELED"
  | "TERMINATED"
  | "CONTINUED_AS_NEW"
  | "TIMED_OUT"

export type WorkflowExecutionReadCompact_Any__Union_AgentOutput__Any___Any_ = {
  /**
   * The ID of the workflow execution
   */
  id: string
  /**
   * The run ID of the workflow execution
   */
  run_id: string
  /**
   * The start time of the workflow execution
   */
  start_time: string
  /**
   * When this workflow run started or should start.
   */
  execution_time?: string | null
  /**
   * When the workflow was closed if closed.
   */
  close_time?: string | null
  status:
    | "RUNNING"
    | "COMPLETED"
    | "FAILED"
    | "CANCELED"
    | "TERMINATED"
    | "CONTINUED_AS_NEW"
    | "TIMED_OUT"
  workflow_type: string
  task_queue: string
  /**
   * Number of events in the history
   */
  history_length: number
  parent_wf_exec_id?: string | null
  trigger_type: TriggerType
  /**
   * Execution type (draft or published). Draft uses the draft workflow graph.
   */
  execution_type?: ExecutionType
  /**
   * Compact events in the workflow execution
   */
  events: Array<WorkflowExecutionEventCompact_Any__Union_AgentOutput__Any___Any_>
  /**
   * The interactions in the workflow execution
   */
  interactions?: Array<InteractionRead>
}

export type WorkflowExecutionReadMinimal = {
  /**
   * The ID of the workflow execution
   */
  id: string
  /**
   * The run ID of the workflow execution
   */
  run_id: string
  /**
   * The start time of the workflow execution
   */
  start_time: string
  /**
   * When this workflow run started or should start.
   */
  execution_time?: string | null
  /**
   * When the workflow was closed if closed.
   */
  close_time?: string | null
  status:
    | "RUNNING"
    | "COMPLETED"
    | "FAILED"
    | "CANCELED"
    | "TERMINATED"
    | "CONTINUED_AS_NEW"
    | "TIMED_OUT"
  workflow_type: string
  task_queue: string
  /**
   * Number of events in the history
   */
  history_length: number
  parent_wf_exec_id?: string | null
  trigger_type: TriggerType
  /**
   * Execution type (draft or published). Draft uses the draft workflow graph.
   */
  execution_type?: ExecutionType
}

/**
 * Status of a workflow execution.
 *
 * See :py:class:`temporalio.api.enums.v1.WorkflowExecutionStatus`.
 */
export type WorkflowExecutionStatus = 1 | 2 | 3 | 4 | 5 | 6 | 7

export type WorkflowExecutionTerminate = {
  reason?: string | null
}

export type WorkflowFolderCreate = {
  name: string
  parent_path?: string
}

export type WorkflowFolderDelete = {
  recursive?: boolean
}

export type WorkflowFolderMove = {
  new_parent_path?: string | null
}

export type WorkflowFolderRead = {
  id: string
  name: string
  path: string
  workspace_id: string
  created_at: string
  updated_at: string
}

export type WorkflowFolderUpdate = {
  name?: string | null
}

export type WorkflowMoveToFolder = {
  folder_path?: string | null
}

export type WorkflowRead = {
  id: string
  title: string
  description: string
  status: string
  actions: {
    [key: string]: ActionRead
  }
  workspace_id: string
  version?: number | null
  webhook: WebhookRead
  schedules: Array<ScheduleRead>
  entrypoint: string | null
  expects?: {
    [key: string]: ExpectedField_Output
  } | null
  expects_schema?: {
    [key: string]: unknown
  } | null
  returns: unknown
  config: DSLConfig_Output | null
  alias?: string | null
  error_handler?: string | null
  trigger_position_x?: number
  trigger_position_y?: number
  graph_version?: number
}

/**
 * Minimal version of WorkflowRead model for list endpoints.
 */
export type WorkflowReadMinimal = {
  id: string
  title: string
  description: string
  status: string
  icon_url: string | null
  created_at: string
  updated_at: string
  version: number | null
  tags?: Array<TagRead> | null
  alias?: string | null
  error_handler?: string | null
  latest_definition?: WorkflowDefinitionReadMinimal | null
  folder_id?: string | null
}

/**
 * Summary of a workflow for inbox item context.
 */
export type WorkflowSummary = {
  /**
   * Workflow ID
   */
  id: string
  /**
   * Workflow title
   */
  title: string
  /**
   * Workflow alias
   */
  alias?: string | null
}

/**
 * Request model for pulling workflows from a Git repository.
 */
export type WorkflowSyncPullRequest = {
  /**
   * Specific commit SHA to pull from
   */
  commit_sha: string
  /**
   * Validate only, don't perform actual import
   */
  dry_run?: boolean
}

export type WorkflowTagCreate = {
  tag_id: string
}

export type WorkflowUpdate = {
  /**
   * Workflow title, between 3 and 100 characters
   */
  title?: string | null
  /**
   * Optional workflow description, up to 1000 characters
   */
  description?: string | null
  status?: "online" | "offline" | null
  version?: number | null
  entrypoint?: string | null
  icon_url?: string | null
  expects?: {
    [key: string]: ExpectedField_Input
  } | null
  returns?: unknown | null
  config?: DSLConfig_Input | null
  alias?: string | null
  error_handler?: string | null
}

export type WorkspaceCreate = {
  name: string
  settings?: WorkspaceSettingsUpdate | null
  organization_id?: string | null
}

export type WorkspaceMember = {
  user_id: string
  first_name: string | null
  last_name: string | null
  email: string
  org_role: UserRole
  workspace_role: WorkspaceRole
}

export type WorkspaceMembershipCreate = {
  user_id: string
  role?: WorkspaceRole
}

export type WorkspaceMembershipRead = {
  user_id: string
  workspace_id: string
  role: WorkspaceRole
}

export type WorkspaceMembershipUpdate = {
  role?: WorkspaceRole | null
}

export type WorkspaceRead = {
  id: string
  name: string
  settings?: WorkspaceSettingsRead | null
  organization_id: string
}

export type WorkspaceReadMinimal = {
  id: string
  name: string
}

export type WorkspaceRole = "editor" | "admin"

export type WorkspaceSettingsRead = {
  git_repo_url?: string | null
  workflow_unlimited_timeout_enabled?: boolean | null
  workflow_default_timeout_seconds?: number | null
  allowed_attachment_extensions?: Array<string> | null
  allowed_attachment_mime_types?: Array<string> | null
  validate_attachment_magic_number?: boolean | null
  /**
   * Returns workspace-specific extensions if set, otherwise system defaults.
   */
  readonly effective_allowed_attachment_extensions: Array<string>
  /**
   * Returns workspace-specific MIME types if set, otherwise system defaults.
   */
  readonly effective_allowed_attachment_mime_types: Array<string>
}

export type WorkspaceSettingsUpdate = {
  git_repo_url?: string | null
  /**
   * Allow workflows to run indefinitely without timeout constraints. When enabled, individual workflow timeout settings are ignored.
   */
  workflow_unlimited_timeout_enabled?: boolean | null
  /**
   * Default timeout in seconds for workflows in this workspace. Must be greater than or equal to 0.
   */
  workflow_default_timeout_seconds?: number | null
  /**
   * Allowed file extensions for attachments (e.g., ['.pdf', '.docx']). Overrides global defaults.
   */
  allowed_attachment_extensions?: Array<string> | null
  /**
   * Allowed MIME types for attachments (e.g., ['application/pdf', 'image/jpeg']). Overrides global defaults.
   */
  allowed_attachment_mime_types?: Array<string> | null
  /**
   * Whether to validate file content matches declared MIME type using magic number detection. Defaults to true for security.
   */
  validate_attachment_magic_number?: boolean | null
}

export type WorkspaceUpdate = {
  name?: string | null
  settings?: WorkspaceSettingsUpdate | null
}

export type Yaml = {
  component_id?: "yaml"
}

/**
 * Response model for registry sync operation.
 */
export type tracecat__registry__repositories__schemas__RegistrySyncResponse = {
  success: boolean
  repository_id: string
  origin: string
  version?: string | null
  commit_sha?: string | null
  actions_count?: number | null
  forced?: boolean
}

/**
 * Response model for version promotion.
 */
export type tracecat__registry__repositories__schemas__RegistryVersionPromoteResponse =
  {
    repository_id: string
    origin: string
    previous_version_id: string | null
    current_version_id: string
    version: string
  }

/**
 * Response model for reading a registry version.
 */
export type tracecat__registry__repositories__schemas__RegistryVersionRead = {
  id: string
  repository_id: string
  version: string
  commit_sha: string | null
  tarball_uri: string | null
  created_at: string
}

/**
 * Response from sync operation.
 */
export type tracecat_ee__admin__registry__schemas__RegistrySyncResponse = {
  success: boolean
  synced_at: string
  repositories: Array<RepositorySyncResult>
}

/**
 * Response from promoting a registry version.
 */
export type tracecat_ee__admin__registry__schemas__RegistryVersionPromoteResponse =
  {
    repository_id: string
    origin: string
    previous_version_id: string | null
    current_version_id: string
    version: string
  }

/**
 * Registry version details.
 */
export type tracecat_ee__admin__registry__schemas__RegistryVersionRead = {
  id: string
  repository_id: string
  version: string
  commit_sha: string | null
  tarball_uri: string | null
  created_at: string
}

export type PublicIncomingWebhookPostData = {
  contentType?: string | null
  /**
   * Echo back to the caller
   */
  echo?: boolean
  /**
   * Return an empty response. Assumes `echo` to be `True`.
   */
  emptyEcho?: boolean
  secret: string
  /**
   * Vendor specific webhook verification. Supported vendors: `okta`.
   */
  vendor?: string | null
  workflowId: string
}

export type PublicIncomingWebhookPostResponse = unknown

export type PublicIncomingWebhookGetData = {
  contentType?: string | null
  /**
   * Echo back to the caller
   */
  echo?: boolean
  /**
   * Return an empty response. Assumes `echo` to be `True`.
   */
  emptyEcho?: boolean
  secret: string
  /**
   * Vendor specific webhook verification. Supported vendors: `okta`.
   */
  vendor?: string | null
  workflowId: string
}

export type PublicIncomingWebhookGetResponse = unknown

export type PublicIncomingWebhookWaitData = {
  contentType?: string | null
  secret: string
  workflowId: string
}

export type PublicIncomingWebhookWaitResponse = unknown

export type PublicIncomingWebhookDraftData = {
  contentType?: string | null
  secret: string
  workflowId: string
}

export type PublicIncomingWebhookDraftResponse = unknown

export type PublicReceiveInteractionData = {
  category: InteractionCategory
  contentType?: string | null
  secret: string
  workflowId: string
}

export type PublicReceiveInteractionResponse = ReceiveInteractionResponse

export type WorkspacesListWorkspacesResponse = Array<WorkspaceReadMinimal>

export type WorkspacesCreateWorkspaceData = {
  requestBody: WorkspaceCreate
}

export type WorkspacesCreateWorkspaceResponse = WorkspaceReadMinimal

export type WorkspacesSearchWorkspacesData = {
  name?: string | null
}

export type WorkspacesSearchWorkspacesResponse = Array<WorkspaceReadMinimal>

export type WorkspacesGetWorkspaceData = {
  workspaceId: string
}

export type WorkspacesGetWorkspaceResponse = WorkspaceRead

export type WorkspacesUpdateWorkspaceData = {
  requestBody: WorkspaceUpdate
  workspaceId: string
}

export type WorkspacesUpdateWorkspaceResponse = void

export type WorkspacesDeleteWorkspaceData = {
  workspaceId: string
}

export type WorkspacesDeleteWorkspaceResponse = void

export type WorkspacesListWorkspaceMembersData = {
  workspaceId: string
}

export type WorkspacesListWorkspaceMembersResponse = Array<WorkspaceMember>

export type WorkspacesListWorkspaceMembershipsData = {
  workspaceId: string
}

export type WorkspacesListWorkspaceMembershipsResponse =
  Array<WorkspaceMembershipRead>

export type WorkspacesCreateWorkspaceMembershipData = {
  requestBody: WorkspaceMembershipCreate
  workspaceId: string
}

export type WorkspacesCreateWorkspaceMembershipResponse = unknown

export type WorkspacesUpdateWorkspaceMembershipData = {
  requestBody: WorkspaceMembershipUpdate
  userId: string
  workspaceId: string
}

export type WorkspacesUpdateWorkspaceMembershipResponse = void

export type WorkspacesGetWorkspaceMembershipData = {
  userId: string
  workspaceId: string
}

export type WorkspacesGetWorkspaceMembershipResponse = WorkspaceMembershipRead

export type WorkspacesDeleteWorkspaceMembershipData = {
  userId: string
  workspaceId: string
}

export type WorkspacesDeleteWorkspaceMembershipResponse = void

export type WorkflowsListWorkflowsData = {
  cursor?: string | null
  limit?: number
  reverse?: boolean
  /**
   * Filter workflows by tags
   */
  tag?: Array<string> | null
  workspaceId: string
}

export type WorkflowsListWorkflowsResponse =
  CursorPaginatedResponse_WorkflowReadMinimal_

export type WorkflowsCreateWorkflowData = {
  formData?: Body_workflows_create_workflow
  workspaceId: string
}

export type WorkflowsCreateWorkflowResponse = WorkflowReadMinimal

export type WorkflowsValidateWorkflowEntrypointData = {
  requestBody: WorkflowEntrypointValidationRequest
  workspaceId: string
}

export type WorkflowsValidateWorkflowEntrypointResponse =
  WorkflowEntrypointValidationResponse

export type WorkflowsGetWorkflowData = {
  workflowId: string
  workspaceId: string
}

export type WorkflowsGetWorkflowResponse = WorkflowRead

export type WorkflowsUpdateWorkflowData = {
  requestBody: WorkflowUpdate
  workflowId: string
  workspaceId: string
}

export type WorkflowsUpdateWorkflowResponse = void

export type WorkflowsDeleteWorkflowData = {
  workflowId: string
  workspaceId: string
}

export type WorkflowsDeleteWorkflowResponse = void

export type WorkflowsCommitWorkflowData = {
  workflowId: string
  workspaceId: string
}

export type WorkflowsCommitWorkflowResponse = WorkflowCommitResponse

export type WorkflowsExportWorkflowData = {
  /**
   * Export current draft state instead of saved definition.
   */
  draft?: boolean
  /**
   * Export format: 'json' or 'yaml'
   */
  format?: "json" | "yaml"
  /**
   * Workflow definition version. If not provided, the latest version is exported.
   */
  version?: number | null
  workflowId: string
  workspaceId: string
}

export type WorkflowsExportWorkflowResponse = unknown

export type WorkflowsListWorkflowDefinitionsData = {
  workflowId: string
  workspaceId: string
}

export type WorkflowsListWorkflowDefinitionsResponse =
  Array<WorkflowDefinitionRead>

export type WorkflowsGetWorkflowDefinitionData = {
  version?: number | null
  workflowId: string
  workspaceId: string
}

export type WorkflowsGetWorkflowDefinitionResponse = WorkflowDefinitionRead

export type WorkflowsCreateWorkflowDefinitionData = {
  workflowId: string
  workspaceId: string
}

export type WorkflowsCreateWorkflowDefinitionResponse = WorkflowDefinitionRead

export type TriggersCreateWebhookData = {
  requestBody: WebhookCreate
  workflowId: string
  workspaceId: string
}

export type TriggersCreateWebhookResponse = unknown

export type TriggersGetWebhookData = {
  workflowId: string
  workspaceId: string
}

export type TriggersGetWebhookResponse = WebhookRead

export type TriggersUpdateWebhookData = {
  requestBody: WebhookUpdate
  workflowId: string
  workspaceId: string
}

export type TriggersUpdateWebhookResponse = void

export type TriggersGenerateWebhookApiKeyData = {
  workflowId: string
  workspaceId: string
}

export type TriggersGenerateWebhookApiKeyResponse =
  WebhookApiKeyGenerateResponse

export type TriggersDeleteWebhookApiKeyData = {
  workflowId: string
  workspaceId: string
}

export type TriggersDeleteWebhookApiKeyResponse = void

export type TriggersRevokeWebhookApiKeyData = {
  workflowId: string
  workspaceId: string
}

export type TriggersRevokeWebhookApiKeyResponse = void

export type WorkflowsMoveWorkflowToFolderData = {
  requestBody: WorkflowMoveToFolder
  workflowId: string
  workspaceId: string
}

export type WorkflowsMoveWorkflowToFolderResponse = void

export type GraphGetGraphData = {
  workflowId: string
  workspaceId: string
}

export type GraphGetGraphResponse = GraphResponse

export type GraphApplyGraphOperationsData = {
  requestBody: GraphOperationsRequest
  workflowId: string
  workspaceId: string
}

export type GraphApplyGraphOperationsResponse = GraphResponse

export type WorkflowExecutionsListWorkflowExecutionsData = {
  limit?: number | null
  trigger?: Array<TriggerType> | null
  userId?: string | SpecialUserID | null
  workflowId?: string | null
  workspaceId: string
}

export type WorkflowExecutionsListWorkflowExecutionsResponse =
  Array<WorkflowExecutionReadMinimal>

export type WorkflowExecutionsCreateWorkflowExecutionData = {
  requestBody: WorkflowExecutionCreate
  workspaceId: string
}

export type WorkflowExecutionsCreateWorkflowExecutionResponse =
  WorkflowExecutionCreateResponse

export type WorkflowExecutionsGetWorkflowExecutionData = {
  executionId: string
  workspaceId: string
}

export type WorkflowExecutionsGetWorkflowExecutionResponse =
  WorkflowExecutionRead

export type WorkflowExecutionsGetWorkflowExecutionCompactData = {
  executionId: string
  workspaceId: string
}

export type WorkflowExecutionsGetWorkflowExecutionCompactResponse =
  WorkflowExecutionReadCompact_Any__Union_AgentOutput__Any___Any_

export type WorkflowExecutionsCreateDraftWorkflowExecutionData = {
  requestBody: WorkflowExecutionCreate
  workspaceId: string
}

export type WorkflowExecutionsCreateDraftWorkflowExecutionResponse =
  WorkflowExecutionCreateResponse

export type WorkflowExecutionsCancelWorkflowExecutionData = {
  executionId: string
  workspaceId: string
}

export type WorkflowExecutionsCancelWorkflowExecutionResponse = void

export type WorkflowExecutionsTerminateWorkflowExecutionData = {
  executionId: string
  requestBody: WorkflowExecutionTerminate
  workspaceId: string
}

export type WorkflowExecutionsTerminateWorkflowExecutionResponse = void

export type ActionsBatchUpdatePositionsData = {
  requestBody: BatchPositionUpdate
  workflowId: string
  workspaceId: string
}

export type ActionsBatchUpdatePositionsResponse = void

export type ActionsListActionsData = {
  workflowId: string
  workspaceId: string
}

export type ActionsListActionsResponse = Array<ActionReadMinimal>

export type ActionsCreateActionData = {
  requestBody: ActionCreate
  workspaceId: string
}

export type ActionsCreateActionResponse = ActionReadMinimal

export type ActionsGetActionData = {
  actionId: string
  workflowId: string
  workspaceId: string
}

export type ActionsGetActionResponse = ActionRead

export type ActionsUpdateActionData = {
  actionId: string
  requestBody: ActionUpdate
  workflowId: string
  workspaceId: string
}

export type ActionsUpdateActionResponse = ActionRead

export type ActionsDeleteActionData = {
  actionId: string
  workflowId: string
  workspaceId: string
}

export type ActionsDeleteActionResponse = void

export type WorkflowsListTagsData = {
  workflowId: string
  workspaceId: string
}

export type WorkflowsListTagsResponse = Array<TagRead>

export type WorkflowsAddTagData = {
  requestBody: WorkflowTagCreate
  workflowId: string
  workspaceId: string
}

export type WorkflowsAddTagResponse = unknown

export type WorkflowsRemoveTagData = {
  tagId: string
  workflowId: string
  workspaceId: string
}

export type WorkflowsRemoveTagResponse = void

export type WorkflowsPublishWorkflowData = {
  requestBody: WorkflowDslPublish
  workflowId: string
  workspaceId: string
}

export type WorkflowsPublishWorkflowResponse = void

export type WorkflowsListWorkflowCommitsData = {
  /**
   * Branch name to fetch commits from
   */
  branch?: string
  /**
   * Maximum number of commits to return
   */
  limit?: number
  workspaceId: string
}

export type WorkflowsListWorkflowCommitsResponse = Array<GitCommitInfo>

export type WorkflowsPullWorkflowsData = {
  requestBody: WorkflowSyncPullRequest
  workspaceId: string
}

export type WorkflowsPullWorkflowsResponse = PullResult

export type SecretsSearchSecretsData = {
  environment: string
  /**
   * Filter by secret ID
   */
  id?: Array<string> | null
  /**
   * Filter by secret name
   */
  name?: Array<string> | null
  /**
   * Filter by secret type
   */
  type?: Array<SecretType> | null
  workspaceId: string
}

export type SecretsSearchSecretsResponse = Array<SecretRead>

export type SecretsListSecretsData = {
  /**
   * Filter by secret type
   */
  type?: Array<SecretType> | null
  workspaceId: string
}

export type SecretsListSecretsResponse = Array<SecretReadMinimal>

export type SecretsCreateSecretData = {
  requestBody: SecretCreate
  workspaceId: string
}

export type SecretsCreateSecretResponse = unknown

export type SecretsListSecretDefinitionsData = {
  workspaceId: string
}

export type SecretsListSecretDefinitionsResponse = Array<SecretDefinition>

export type SecretsGetSecretByNameData = {
  secretName: string
  workspaceId: string
}

export type SecretsGetSecretByNameResponse = SecretRead

export type SecretsUpdateSecretByIdData = {
  requestBody: SecretUpdate
  secretId: string
  workspaceId: string
}

export type SecretsUpdateSecretByIdResponse = void

export type SecretsDeleteSecretByIdData = {
  secretId: string
  workspaceId: string
}

export type SecretsDeleteSecretByIdResponse = void

export type VariablesSearchVariablesData = {
  environment?: string | null
  /**
   * Filter by variable ID
   */
  id?: Array<string> | null
  /**
   * Filter by variable name
   */
  name?: Array<string> | null
  workspaceId: string
}

export type VariablesSearchVariablesResponse = Array<VariableRead>

export type VariablesListVariablesData = {
  environment?: string | null
  workspaceId: string
}

export type VariablesListVariablesResponse = Array<VariableReadMinimal>

export type VariablesCreateVariableData = {
  requestBody: VariableCreate
  workspaceId: string
}

export type VariablesCreateVariableResponse = VariableRead

export type VariablesGetVariableByNameData = {
  environment?: string | null
  variableName: string
  workspaceId: string
}

export type VariablesGetVariableByNameResponse = VariableRead

export type VariablesUpdateVariableByIdData = {
  requestBody: VariableUpdate
  variableId: string
  workspaceId: string
}

export type VariablesUpdateVariableByIdResponse = VariableRead

export type VariablesDeleteVariableByIdData = {
  variableId: string
  workspaceId: string
}

export type VariablesDeleteVariableByIdResponse = void

export type SchedulesListSchedulesData = {
  workflowId?: string | null
  workspaceId: string
}

export type SchedulesListSchedulesResponse = Array<ScheduleRead>

export type SchedulesCreateScheduleData = {
  requestBody: ScheduleCreate
  workspaceId: string
}

export type SchedulesCreateScheduleResponse = ScheduleRead

export type SchedulesGetScheduleData = {
  scheduleId: string
  workspaceId: string
}

export type SchedulesGetScheduleResponse = ScheduleRead

export type SchedulesUpdateScheduleData = {
  requestBody: ScheduleUpdate
  scheduleId: string
  workspaceId: string
}

export type SchedulesUpdateScheduleResponse = ScheduleRead

export type SchedulesDeleteScheduleData = {
  scheduleId: string
  workspaceId: string
}

export type SchedulesDeleteScheduleResponse = void

export type SchedulesSearchSchedulesData = {
  requestBody: ScheduleSearch
  workspaceId: string
}

export type SchedulesSearchSchedulesResponse = Array<ScheduleRead>

export type TagsListTagsData = {
  workspaceId: string
}

export type TagsListTagsResponse = Array<TagRead>

export type TagsCreateTagData = {
  requestBody: TagCreate
  workspaceId: string
}

export type TagsCreateTagResponse = TagRead

export type TagsGetTagData = {
  tagId: string
  workspaceId: string
}

export type TagsGetTagResponse = TagRead

export type TagsUpdateTagData = {
  requestBody: TagUpdate
  tagId: string
  workspaceId: string
}

export type TagsUpdateTagResponse = TagRead

export type TagsDeleteTagData = {
  tagId: string
  workspaceId: string
}

export type TagsDeleteTagResponse = unknown

export type UsersSearchUserData = {
  email?: string | null
  workspaceId?: string | null
}

export type UsersSearchUserResponse = UserRead

export type OrganizationListOrgMembersResponse = Array<OrgMemberRead>

export type OrganizationDeleteOrgMemberData = {
  userId: string
}

export type OrganizationDeleteOrgMemberResponse = void

export type OrganizationUpdateOrgMemberData = {
  requestBody: UserUpdate
  userId: string
}

export type OrganizationUpdateOrgMemberResponse = OrgMemberRead

export type OrganizationListSessionsResponse = Array<SessionRead>

export type OrganizationDeleteSessionData = {
  sessionId: string
}

export type OrganizationDeleteSessionResponse = void

export type OrganizationCreateInvitationData = {
  requestBody: OrgInvitationCreate
}

export type OrganizationCreateInvitationResponse = OrgInvitationRead

export type OrganizationListInvitationsData = {
  status?: InvitationStatus | null
}

export type OrganizationListInvitationsResponse = Array<OrgInvitationRead>

export type OrganizationRevokeInvitationData = {
  invitationId: string
}

export type OrganizationRevokeInvitationResponse = void

export type OrganizationAcceptInvitationData = {
  requestBody: OrgInvitationAccept
}

export type OrganizationAcceptInvitationResponse = {
  [key: string]: string
}

export type OrganizationGetInvitationByTokenData = {
  token: string
}

export type OrganizationGetInvitationByTokenResponse = OrgInvitationReadMinimal

export type AgentListModelsResponse = {
  [key: string]: ModelConfig
}

export type AgentListProvidersResponse = Array<string>

export type AgentGetProvidersStatusResponse = {
  [key: string]: boolean
}

export type AgentListProviderCredentialConfigsResponse =
  Array<ProviderCredentialConfig>

export type AgentGetProviderCredentialConfigData = {
  provider: string
}

export type AgentGetProviderCredentialConfigResponse = ProviderCredentialConfig

export type AgentCreateProviderCredentialsData = {
  requestBody: ModelCredentialCreate
}

export type AgentCreateProviderCredentialsResponse = {
  [key: string]: string
}

export type AgentUpdateProviderCredentialsData = {
  provider: string
  requestBody: ModelCredentialUpdate
}

export type AgentUpdateProviderCredentialsResponse = {
  [key: string]: string
}

export type AgentDeleteProviderCredentialsData = {
  provider: string
}

export type AgentDeleteProviderCredentialsResponse = {
  [key: string]: string
}

export type AgentGetDefaultModelResponse = string | null

export type AgentSetDefaultModelData = {
  modelName: string
}

export type AgentSetDefaultModelResponse = {
  [key: string]: string
}

export type AgentGetWorkspaceProvidersStatusData = {
  workspaceId: string
}

export type AgentGetWorkspaceProvidersStatusResponse = {
  [key: string]: boolean
}

export type AgentPresetsListAgentPresetsData = {
  workspaceId: string
}

export type AgentPresetsListAgentPresetsResponse = Array<AgentPresetReadMinimal>

export type AgentPresetsCreateAgentPresetData = {
  requestBody: AgentPresetCreate
  workspaceId: string
}

export type AgentPresetsCreateAgentPresetResponse = AgentPresetRead

export type AgentPresetsGetAgentPresetData = {
  presetId: string
  workspaceId: string
}

export type AgentPresetsGetAgentPresetResponse = AgentPresetRead

export type AgentPresetsUpdateAgentPresetData = {
  presetId: string
  requestBody: AgentPresetUpdate
  workspaceId: string
}

export type AgentPresetsUpdateAgentPresetResponse = AgentPresetRead

export type AgentPresetsDeleteAgentPresetData = {
  presetId: string
  workspaceId: string
}

export type AgentPresetsDeleteAgentPresetResponse = void

export type AgentPresetsGetAgentPresetBySlugData = {
  slug: string
  workspaceId: string
}

export type AgentPresetsGetAgentPresetBySlugResponse = AgentPresetRead

export type AgentSessionsCreateSessionData = {
  requestBody: AgentSessionCreate
  workspaceId: string
}

export type AgentSessionsCreateSessionResponse = AgentSessionRead

export type AgentSessionsListSessionsData = {
  /**
   * Filter by entity ID
   */
  entityId?: string | null
  /**
   * Filter by entity type
   */
  entityType?: AgentSessionEntity | null
  /**
   * Entity types to exclude from results
   */
  excludeEntityTypes?: Array<AgentSessionEntity> | null
  /**
   * Maximum number of sessions to return
   */
  limit?: number
  /**
   * Filter by parent session ID (for finding forked sessions)
   */
  parentSessionId?: string | null
  workspaceId: string
}

export type AgentSessionsListSessionsResponse = Array<
  AgentSessionRead | ChatReadMinimal
>

export type AgentSessionsGetSessionData = {
  sessionId: string
  workspaceId: string
}

export type AgentSessionsGetSessionResponse =
  | AgentSessionReadWithMessages
  | ChatRead

export type AgentSessionsUpdateSessionData = {
  requestBody: AgentSessionUpdate
  sessionId: string
  workspaceId: string
}

export type AgentSessionsUpdateSessionResponse = AgentSessionRead

export type AgentSessionsDeleteSessionData = {
  sessionId: string
  workspaceId: string
}

export type AgentSessionsDeleteSessionResponse = void

export type AgentSessionsGetSessionVercelData = {
  sessionId: string
  workspaceId: string
}

export type AgentSessionsGetSessionVercelResponse =
  | AgentSessionReadVercel
  | ChatReadVercel

export type AgentSessionsSendMessageData = {
  requestBody: VercelChatRequest | ContinueRunRequest
  sessionId: string
  workspaceId: string
}

export type AgentSessionsSendMessageResponse = unknown

export type AgentSessionsStreamSessionEventsData = {
  /**
   * Streaming format (e.g. 'vercel')
   */
  format?: "vercel" | "basic"
  sessionId: string
  workspaceId: string
}

export type AgentSessionsStreamSessionEventsResponse = unknown

export type AgentSessionsForkSessionData = {
  requestBody?: AgentSessionForkRequest | null
  sessionId: string
  workspaceId: string
}

export type AgentSessionsForkSessionResponse = AgentSessionRead

export type ApprovalsSubmitApprovalsData = {
  requestBody: ApprovalSubmission
  sessionId: string
  workspaceId: string
}

export type ApprovalsSubmitApprovalsResponse = void

export type AdminListOrganizationsResponse = Array<OrgRead>

export type AdminCreateOrganizationData = {
  requestBody: OrgCreate
}

export type AdminCreateOrganizationResponse = OrgRead

export type AdminGetOrganizationData = {
  orgId: string
}

export type AdminGetOrganizationResponse = OrgRead

export type AdminUpdateOrganizationData = {
  orgId: string
  requestBody: OrgUpdate
}

export type AdminUpdateOrganizationResponse = OrgRead

export type AdminDeleteOrganizationData = {
  orgId: string
}

export type AdminDeleteOrganizationResponse = void

export type AdminListOrgRepositoriesData = {
  orgId: string
}

export type AdminListOrgRepositoriesResponse = Array<OrgRegistryRepositoryRead>

export type AdminListOrgRepositoryVersionsData = {
  orgId: string
  repositoryId: string
}

export type AdminListOrgRepositoryVersionsResponse =
  Array<OrgRegistryVersionRead>

export type AdminSyncOrgRepositoryData = {
  orgId: string
  repositoryId: string
  requestBody?: OrgRegistrySyncRequest | null
}

export type AdminSyncOrgRepositoryResponse = OrgRegistrySyncResponse

export type AdminPromoteOrgRepositoryVersionData = {
  orgId: string
  repositoryId: string
  versionId: string
}

export type AdminPromoteOrgRepositoryVersionResponse =
  OrgRegistryVersionPromoteResponse

export type AdminSyncAllRepositoriesData = {
  /**
   * Force sync by deleting existing version
   */
  force?: boolean
}

export type AdminSyncAllRepositoriesResponse =
  tracecat_ee__admin__registry__schemas__RegistrySyncResponse

export type AdminSyncRepositoryData = {
  /**
   * Force sync by deleting existing version
   */
  force?: boolean
  repositoryId: string
}

export type AdminSyncRepositoryResponse =
  tracecat_ee__admin__registry__schemas__RegistrySyncResponse

export type AdminGetRegistryStatusResponse = RegistryStatusResponse

export type AdminListRegistryVersionsData = {
  limit?: number
  repositoryId?: string | null
}

export type AdminListRegistryVersionsResponse =
  Array<tracecat_ee__admin__registry__schemas__RegistryVersionRead>

export type AdminPromoteRegistryVersionData = {
  repositoryId: string
  versionId: string
}

export type AdminPromoteRegistryVersionResponse =
  tracecat_ee__admin__registry__schemas__RegistryVersionPromoteResponse

export type AdminGetRegistrySettingsResponse = PlatformRegistrySettingsRead

export type AdminUpdateRegistrySettingsData = {
  requestBody: PlatformRegistrySettingsUpdate
}

export type AdminUpdateRegistrySettingsResponse = PlatformRegistrySettingsRead

export type AdminListTiersData = {
  /**
   * Include inactive tiers in results
   */
  includeInactive?: boolean
}

export type AdminListTiersResponse = Array<TierRead>

export type AdminCreateTierData = {
  requestBody: TierCreate
}

export type AdminCreateTierResponse = TierRead

export type AdminGetTierData = {
  tierId: string
}

export type AdminGetTierResponse = TierRead

export type AdminUpdateTierData = {
  requestBody: TierUpdate
  tierId: string
}

export type AdminUpdateTierResponse = TierRead

export type AdminDeleteTierData = {
  tierId: string
}

export type AdminDeleteTierResponse = void

export type AdminGetOrgTierData = {
  orgId: string
}

export type AdminGetOrgTierResponse = OrganizationTierRead

export type AdminUpdateOrgTierData = {
  orgId: string
  requestBody: OrganizationTierUpdate
}

export type AdminUpdateOrgTierResponse = OrganizationTierRead

export type AdminListUsersResponse = Array<AdminUserRead>

export type AdminGetUserData = {
  userId: string
}

export type AdminGetUserResponse = AdminUserRead

export type AdminPromoteToSuperuserData = {
  userId: string
}

export type AdminPromoteToSuperuserResponse = AdminUserRead

export type AdminDemoteFromSuperuserData = {
  userId: string
}

export type AdminDemoteFromSuperuserResponse = AdminUserRead

export type InboxListItemsData = {
  limit?: number
  offset?: number
  workspaceId: string
}

export type InboxListItemsResponse = Array<InboxItemRead>

export type InboxListItemsPaginatedData = {
  cursor?: string | null
  limit?: number
  /**
   * Column name to order by (created_at, updated_at, status)
   */
  orderBy?: string | null
  reverse?: boolean
  /**
   * Sort direction (asc or desc)
   */
  sort?: "asc" | "desc" | null
  workspaceId: string
}

export type InboxListItemsPaginatedResponse =
  CursorPaginatedResponse_InboxItemRead_

export type EditorListFunctionsData = {
  workspaceId: string
}

export type EditorListFunctionsResponse = Array<EditorFunctionRead>

export type EditorListActionsData = {
  workflowId: string
  workspaceId: string
}

export type EditorListActionsResponse = Array<EditorActionRead>

export type EditorValidateExpressionData = {
  requestBody: ExpressionValidationRequest
  workspaceId: string
}

export type EditorValidateExpressionResponse = ExpressionValidationResponse

export type EditorFieldSchemaResponse = EditorComponent

export type RegistryRepositoriesReloadRegistryRepositoriesResponse = void

export type RegistryRepositoriesSyncRegistryRepositoryData = {
  repositoryId: string
  requestBody?: RegistryRepositorySync | null
}

export type RegistryRepositoriesSyncRegistryRepositoryResponse =
  tracecat__registry__repositories__schemas__RegistrySyncResponse

export type RegistryRepositoriesListRepositoryVersionsData = {
  repositoryId: string
}

export type RegistryRepositoriesListRepositoryVersionsResponse =
  Array<tracecat__registry__repositories__schemas__RegistryVersionRead>

export type RegistryRepositoriesListRegistryRepositoriesResponse =
  Array<RegistryRepositoryReadMinimal>

export type RegistryRepositoriesCreateRegistryRepositoryData = {
  requestBody: RegistryRepositoryCreate
}

export type RegistryRepositoriesCreateRegistryRepositoryResponse =
  RegistryRepositoryRead

export type RegistryRepositoriesGetRegistryRepositoryData = {
  repositoryId: string
}

export type RegistryRepositoriesGetRegistryRepositoryResponse =
  RegistryRepositoryRead

export type RegistryRepositoriesUpdateRegistryRepositoryData = {
  repositoryId: string
  requestBody: RegistryRepositoryUpdate
}

export type RegistryRepositoriesUpdateRegistryRepositoryResponse =
  RegistryRepositoryRead

export type RegistryRepositoriesDeleteRegistryRepositoryData = {
  repositoryId: string
}

export type RegistryRepositoriesDeleteRegistryRepositoryResponse = void

export type RegistryRepositoriesListRepositoryCommitsData = {
  branch?: string
  limit?: number
  repositoryId: string
}

export type RegistryRepositoriesListRepositoryCommitsResponse =
  Array<GitCommitInfo>

export type RegistryRepositoriesPromoteRegistryVersionData = {
  repositoryId: string
  versionId: string
}

export type RegistryRepositoriesPromoteRegistryVersionResponse =
  tracecat__registry__repositories__schemas__RegistryVersionPromoteResponse

export type RegistryActionsListRegistryActionsResponse =
  Array<RegistryActionReadMinimal>

export type RegistryActionsCreateRegistryActionData = {
  requestBody: RegistryActionCreate
}

export type RegistryActionsCreateRegistryActionResponse = RegistryActionRead

export type RegistryActionsGetRegistryActionData = {
  actionName: string
}

export type RegistryActionsGetRegistryActionResponse = RegistryActionRead

export type RegistryActionsUpdateRegistryActionData = {
  actionName: string
  requestBody: RegistryActionUpdate
}

export type RegistryActionsUpdateRegistryActionResponse = void

export type RegistryActionsDeleteRegistryActionData = {
  actionName: string
}

export type RegistryActionsDeleteRegistryActionResponse = void

export type SettingsGetGitSettingsResponse = GitSettingsRead

export type SettingsUpdateGitSettingsData = {
  requestBody: GitSettingsUpdate
}

export type SettingsUpdateGitSettingsResponse = void

export type SettingsGetSamlSettingsResponse = SAMLSettingsRead

export type SettingsUpdateSamlSettingsData = {
  requestBody: SAMLSettingsUpdate
}

export type SettingsUpdateSamlSettingsResponse = void

export type SettingsGetAuthSettingsResponse = AuthSettingsRead

export type SettingsUpdateAuthSettingsData = {
  requestBody: AuthSettingsUpdate
}

export type SettingsUpdateAuthSettingsResponse = void

export type SettingsGetOauthSettingsResponse = OAuthSettingsRead

export type SettingsUpdateOauthSettingsData = {
  requestBody: OAuthSettingsUpdate
}

export type SettingsUpdateOauthSettingsResponse = void

export type SettingsGetAppSettingsResponse = AppSettingsRead

export type SettingsUpdateAppSettingsData = {
  requestBody: AppSettingsUpdate
}

export type SettingsUpdateAppSettingsResponse = void

export type SettingsGetAuditSettingsResponse = AuditSettingsRead

export type SettingsUpdateAuditSettingsData = {
  requestBody: AuditSettingsUpdate
}

export type SettingsUpdateAuditSettingsResponse = void

export type SettingsGetAgentSettingsResponse = AgentSettingsRead

export type SettingsUpdateAgentSettingsData = {
  requestBody: AgentSettingsUpdate
}

export type SettingsUpdateAgentSettingsResponse = void

export type OrganizationSecretsListOrgSecretsData = {
  /**
   * Filter by secret type
   */
  type?: Array<SecretType> | null
}

export type OrganizationSecretsListOrgSecretsResponse = Array<SecretReadMinimal>

export type OrganizationSecretsCreateOrgSecretData = {
  requestBody: SecretCreate
}

export type OrganizationSecretsCreateOrgSecretResponse = unknown

export type OrganizationSecretsGetOrgSecretByNameData = {
  environment?: string | null
  secretName: string
}

export type OrganizationSecretsGetOrgSecretByNameResponse =
  OrganizationSecretRead

export type OrganizationSecretsUpdateOrgSecretByIdData = {
  requestBody: SecretUpdate
  secretId: string
}

export type OrganizationSecretsUpdateOrgSecretByIdResponse = void

export type OrganizationSecretsDeleteOrgSecretByIdData = {
  secretId: string
}

export type OrganizationSecretsDeleteOrgSecretByIdResponse = void

export type TablesListTablesData = {
  workspaceId: string
}

export type TablesListTablesResponse = Array<TableReadMinimal>

export type TablesCreateTableData = {
  requestBody: TableCreate
  workspaceId: string
}

export type TablesCreateTableResponse = unknown

export type TablesGetTableData = {
  tableId: string
  workspaceId: string
}

export type TablesGetTableResponse = TableRead

export type TablesUpdateTableData = {
  requestBody: TableUpdate
  tableId: string
  workspaceId: string
}

export type TablesUpdateTableResponse = void

export type TablesDeleteTableData = {
  tableId: string
  workspaceId: string
}

export type TablesDeleteTableResponse = void

export type TablesCreateColumnData = {
  requestBody: TableColumnCreate
  tableId: string
  workspaceId: string
}

export type TablesCreateColumnResponse = unknown

export type TablesUpdateColumnData = {
  columnId: string
  requestBody: TableColumnUpdate
  tableId: string
  workspaceId: string
}

export type TablesUpdateColumnResponse = void

export type TablesDeleteColumnData = {
  columnId: string
  tableId: string
  workspaceId: string
}

export type TablesDeleteColumnResponse = void

export type TablesListRowsData = {
  cursor?: string | null
  limit?: number
  /**
   * Column name to order by
   */
  orderBy?: string | null
  reverse?: boolean
  /**
   * Sort direction (asc or desc)
   */
  sort?: "asc" | "desc" | null
  tableId: string
  workspaceId: string
}

export type TablesListRowsResponse = CursorPaginatedResponse_TableRowRead_

export type TablesInsertRowData = {
  requestBody: TableRowInsert
  tableId: string
  workspaceId: string
}

export type TablesInsertRowResponse = unknown

export type TablesGetRowData = {
  rowId: string
  tableId: string
  workspaceId: string
}

export type TablesGetRowResponse = unknown

export type TablesDeleteRowData = {
  rowId: string
  tableId: string
  workspaceId: string
}

export type TablesDeleteRowResponse = void

export type TablesBatchInsertRowsData = {
  requestBody: TableRowInsertBatch
  tableId: string
  workspaceId: string
}

export type TablesBatchInsertRowsResponse = TableRowInsertBatchResponse

export type TablesImportTableFromCsvData = {
  formData: Body_tables_import_table_from_csv
  workspaceId: string
}

export type TablesImportTableFromCsvResponse = TableImportResponse

export type TablesImportCsvData = {
  formData: Body_tables_import_csv
  tableId: string
  workspaceId: string
}

export type TablesImportCsvResponse = TableRowInsertBatchResponse

export type CasesListCasesData = {
  /**
   * Filter by assignee ID or 'unassigned'
   */
  assigneeId?: Array<string> | null
  /**
   * Cursor for pagination
   */
  cursor?: string | null
  /**
   * Maximum items per page
   */
  limit?: number
  /**
   * Column name to order by (e.g. created_at, updated_at, priority, severity, status, tasks). Default: created_at
   */
  orderBy?:
    | "created_at"
    | "updated_at"
    | "priority"
    | "severity"
    | "status"
    | "tasks"
    | null
  /**
   * Filter by case priority
   */
  priority?: Array<CasePriority> | null
  /**
   * Reverse pagination direction
   */
  reverse?: boolean
  /**
   * Text to search for in case summary, description, or short ID
   */
  searchTerm?: string | null
  /**
   * Filter by case severity
   */
  severity?: Array<CaseSeverity> | null
  /**
   * Direction to sort (asc or desc)
   */
  sort?: "asc" | "desc" | null
  /**
   * Filter by case status
   */
  status?: Array<CaseStatus> | null
  /**
   * Filter by tag IDs or slugs (AND logic)
   */
  tags?: Array<string> | null
  workspaceId: string
}

export type CasesListCasesResponse = CursorPaginatedResponse_CaseReadMinimal_

export type CasesCreateCaseData = {
  requestBody: CaseCreate
  workspaceId: string
}

export type CasesCreateCaseResponse = unknown

export type CasesSearchCasesData = {
  /**
   * Return cases created at or before this timestamp
   */
  endTime?: string | null
  /**
   * Maximum number of cases to return
   */
  limit?: number | null
  /**
   * Column name to order by (e.g. created_at, updated_at, priority, severity, status). Default: created_at
   */
  orderBy?:
    | "created_at"
    | "updated_at"
    | "priority"
    | "severity"
    | "status"
    | null
  /**
   * Filter by case priority
   */
  priority?: Array<CasePriority> | null
  /**
   * Text to search for in case summary, description, or short ID
   */
  searchTerm?: string | null
  /**
   * Filter by case severity
   */
  severity?: Array<CaseSeverity> | null
  /**
   * Direction to sort (asc or desc)
   */
  sort?: "asc" | "desc" | null
  /**
   * Return cases created at or after this timestamp
   */
  startTime?: string | null
  /**
   * Filter by case status
   */
  status?: Array<CaseStatus> | null
  /**
   * Filter by tag IDs or slugs (AND logic)
   */
  tags?: Array<string> | null
  /**
   * Return cases updated at or after this timestamp
   */
  updatedAfter?: string | null
  /**
   * Return cases updated at or before this timestamp
   */
  updatedBefore?: string | null
  workspaceId: string
}

export type CasesSearchCasesResponse = Array<CaseReadMinimal>

export type CasesGetCaseData = {
  caseId: string
  workspaceId: string
}

export type CasesGetCaseResponse = CaseRead

export type CasesUpdateCaseData = {
  caseId: string
  requestBody: CaseUpdate
  workspaceId: string
}

export type CasesUpdateCaseResponse = void

export type CasesDeleteCaseData = {
  caseId: string
  workspaceId: string
}

export type CasesDeleteCaseResponse = void

export type CasesListCommentsData = {
  caseId: string
  workspaceId: string
}

export type CasesListCommentsResponse = Array<CaseCommentRead>

export type CasesCreateCommentData = {
  caseId: string
  requestBody: CaseCommentCreate
  workspaceId: string
}

export type CasesCreateCommentResponse = unknown

export type CasesUpdateCommentData = {
  caseId: string
  commentId: string
  requestBody: CaseCommentUpdate
  workspaceId: string
}

export type CasesUpdateCommentResponse = void

export type CasesDeleteCommentData = {
  caseId: string
  commentId: string
  workspaceId: string
}

export type CasesDeleteCommentResponse = void

export type CasesListEventsWithUsersData = {
  caseId: string
  workspaceId: string
}

export type CasesListEventsWithUsersResponse = CaseEventsWithUsers

export type CasesListTasksData = {
  caseId: string
  workspaceId: string
}

export type CasesListTasksResponse = Array<CaseTaskRead>

export type CasesCreateTaskData = {
  caseId: string
  requestBody: CaseTaskCreate
  workspaceId: string
}

export type CasesCreateTaskResponse = CaseTaskRead

export type CasesUpdateTaskData = {
  caseId: string
  requestBody: CaseTaskUpdate
  taskId: string
  workspaceId: string
}

export type CasesUpdateTaskResponse = CaseTaskRead

export type CasesDeleteTaskData = {
  caseId: string
  taskId: string
  workspaceId: string
}

export type CasesDeleteTaskResponse = void

export type CasesListFieldsData = {
  workspaceId: string
}

export type CasesListFieldsResponse = Array<CaseFieldReadMinimal>

export type CasesCreateFieldData = {
  requestBody: CaseFieldCreate
  workspaceId: string
}

export type CasesCreateFieldResponse = unknown

export type CasesUpdateFieldData = {
  fieldId: string
  requestBody: CaseFieldUpdate
  workspaceId: string
}

export type CasesUpdateFieldResponse = void

export type CasesDeleteFieldData = {
  fieldId: string
  workspaceId: string
}

export type CasesDeleteFieldResponse = void

export type CasesListTagsData = {
  caseId: string
  workspaceId: string
}

export type CasesListTagsResponse = Array<CaseTagRead>

export type CasesAddTagData = {
  caseId: string
  requestBody: CaseTagCreate
  workspaceId: string
}

export type CasesAddTagResponse = CaseTagRead

export type CasesRemoveTagData = {
  caseId: string
  tagIdentifier: string
  workspaceId: string
}

export type CasesRemoveTagResponse = void

export type CaseTagsListCaseTagsData = {
  workspaceId: string
}

export type CaseTagsListCaseTagsResponse = Array<CaseTagRead>

export type CaseTagsCreateCaseTagData = {
  requestBody: TagCreate
  workspaceId: string
}

export type CaseTagsCreateCaseTagResponse = CaseTagRead

export type CaseTagsGetCaseTagData = {
  tagId: string
  workspaceId: string
}

export type CaseTagsGetCaseTagResponse = CaseTagRead

export type CaseTagsUpdateCaseTagData = {
  requestBody: TagUpdate
  tagId: string
  workspaceId: string
}

export type CaseTagsUpdateCaseTagResponse = CaseTagRead

export type CaseTagsDeleteCaseTagData = {
  tagId: string
  workspaceId: string
}

export type CaseTagsDeleteCaseTagResponse = void

export type CaseAttachmentsListAttachmentsData = {
  caseId: string
  workspaceId: string
}

export type CaseAttachmentsListAttachmentsResponse = Array<CaseAttachmentRead>

export type CaseAttachmentsCreateAttachmentData = {
  caseId: string
  formData: Body_case_attachments_create_attachment
  workspaceId: string
}

export type CaseAttachmentsCreateAttachmentResponse = CaseAttachmentRead

export type CaseAttachmentsDownloadAttachmentData = {
  attachmentId: string
  caseId: string
  /**
   * If true, allows inline preview for safe image types
   */
  preview?: boolean
  workspaceId: string
}

export type CaseAttachmentsDownloadAttachmentResponse =
  CaseAttachmentDownloadResponse

export type CaseAttachmentsDeleteAttachmentData = {
  attachmentId: string
  caseId: string
  workspaceId: string
}

export type CaseAttachmentsDeleteAttachmentResponse = void

export type CaseDurationsListCaseDurationDefinitionsData = {
  workspaceId: string
}

export type CaseDurationsListCaseDurationDefinitionsResponse =
  Array<CaseDurationDefinitionRead>

export type CaseDurationsCreateCaseDurationDefinitionData = {
  requestBody: CaseDurationDefinitionCreate
  workspaceId: string
}

export type CaseDurationsCreateCaseDurationDefinitionResponse =
  CaseDurationDefinitionRead

export type CaseDurationsGetCaseDurationDefinitionData = {
  durationId: string
  workspaceId: string
}

export type CaseDurationsGetCaseDurationDefinitionResponse =
  CaseDurationDefinitionRead

export type CaseDurationsUpdateCaseDurationDefinitionData = {
  durationId: string
  requestBody: CaseDurationDefinitionUpdate
  workspaceId: string
}

export type CaseDurationsUpdateCaseDurationDefinitionResponse =
  CaseDurationDefinitionRead

export type CaseDurationsDeleteCaseDurationDefinitionData = {
  durationId: string
  workspaceId: string
}

export type CaseDurationsDeleteCaseDurationDefinitionResponse = void

export type CaseDurationsListCaseDurationsData = {
  caseId: string
  workspaceId: string
}

export type CaseDurationsListCaseDurationsResponse = Array<CaseDurationRead>

export type CaseDurationsCreateCaseDurationData = {
  caseId: string
  requestBody: CaseDurationCreate
  workspaceId: string
}

export type CaseDurationsCreateCaseDurationResponse = CaseDurationRead

export type CaseDurationsGetCaseDurationData = {
  caseId: string
  durationId: string
  workspaceId: string
}

export type CaseDurationsGetCaseDurationResponse = CaseDurationRead

export type CaseDurationsUpdateCaseDurationData = {
  caseId: string
  durationId: string
  requestBody: CaseDurationUpdate
  workspaceId: string
}

export type CaseDurationsUpdateCaseDurationResponse = CaseDurationRead

export type CaseDurationsDeleteCaseDurationData = {
  caseId: string
  durationId: string
  workspaceId: string
}

export type CaseDurationsDeleteCaseDurationResponse = void

export type FoldersGetDirectoryData = {
  /**
   * Folder path
   */
  path?: string
  workspaceId: string
}

export type FoldersGetDirectoryResponse = Array<
  WorkflowDirectoryItem | FolderDirectoryItem
>

export type FoldersListFoldersData = {
  /**
   * Parent folder path
   */
  parentPath?: string
  workspaceId: string
}

export type FoldersListFoldersResponse = Array<WorkflowFolderRead>

export type FoldersCreateFolderData = {
  requestBody: WorkflowFolderCreate
  workspaceId: string
}

export type FoldersCreateFolderResponse = WorkflowFolderRead

export type FoldersGetFolderData = {
  folderId: string
  workspaceId: string
}

export type FoldersGetFolderResponse = WorkflowFolderRead

export type FoldersUpdateFolderData = {
  folderId: string
  requestBody: WorkflowFolderUpdate
  workspaceId: string
}

export type FoldersUpdateFolderResponse = WorkflowFolderRead

export type FoldersDeleteFolderData = {
  folderId: string
  requestBody: WorkflowFolderDelete
  workspaceId: string
}

export type FoldersDeleteFolderResponse = void

export type FoldersMoveFolderData = {
  folderId: string
  requestBody: WorkflowFolderMove
  workspaceId: string
}

export type FoldersMoveFolderResponse = WorkflowFolderRead

export type IntegrationsOauthCallbackData = {
  /**
   * Authorization code from OAuth provider
   */
  code: string
  /**
   * State parameter from authorization request
   */
  state: string
}

export type IntegrationsOauthCallbackResponse = IntegrationOAuthCallback

export type IntegrationsListIntegrationsData = {
  workspaceId: string
}

export type IntegrationsListIntegrationsResponse = Array<IntegrationReadMinimal>

export type IntegrationsGetIntegrationData = {
  grantType?: OAuthGrantType
  providerId: string
  workspaceId: string
}

export type IntegrationsGetIntegrationResponse = IntegrationRead

export type IntegrationsDeleteIntegrationData = {
  grantType?: OAuthGrantType
  providerId: string
  workspaceId: string
}

export type IntegrationsDeleteIntegrationResponse = void

export type IntegrationsUpdateIntegrationData = {
  grantType?: OAuthGrantType
  providerId: string
  requestBody: IntegrationUpdate
  workspaceId: string
}

export type IntegrationsUpdateIntegrationResponse = void

export type IntegrationsConnectProviderData = {
  providerId: string
  workspaceId: string
}

export type IntegrationsConnectProviderResponse = IntegrationOAuthConnect

export type IntegrationsDisconnectIntegrationData = {
  grantType?: OAuthGrantType
  providerId: string
  workspaceId: string
}

export type IntegrationsDisconnectIntegrationResponse = void

export type IntegrationsTestConnectionData = {
  providerId: string
  workspaceId: string
}

export type IntegrationsTestConnectionResponse =
  IntegrationTestConnectionResponse

export type ProvidersCreateCustomProviderData = {
  requestBody: CustomOAuthProviderCreate
  workspaceId: string
}

export type ProvidersCreateCustomProviderResponse = ProviderReadMinimal

export type ProvidersListProvidersData = {
  workspaceId: string
}

export type ProvidersListProvidersResponse = Array<ProviderReadMinimal>

export type ProvidersGetProviderData = {
  grantType?: OAuthGrantType
  providerId: string
  workspaceId: string
}

export type ProvidersGetProviderResponse = ProviderRead

export type McpIntegrationsCreateMcpIntegrationData = {
  requestBody: MCPIntegrationCreate
  workspaceId: string
}

export type McpIntegrationsCreateMcpIntegrationResponse = MCPIntegrationRead

export type McpIntegrationsListMcpIntegrationsData = {
  workspaceId: string
}

export type McpIntegrationsListMcpIntegrationsResponse =
  Array<MCPIntegrationRead>

export type McpIntegrationsGetMcpIntegrationData = {
  mcpIntegrationId: string
  workspaceId: string
}

export type McpIntegrationsGetMcpIntegrationResponse = MCPIntegrationRead

export type McpIntegrationsUpdateMcpIntegrationData = {
  mcpIntegrationId: string
  requestBody: MCPIntegrationUpdate
  workspaceId: string
}

export type McpIntegrationsUpdateMcpIntegrationResponse = MCPIntegrationRead

export type McpIntegrationsDeleteMcpIntegrationData = {
  mcpIntegrationId: string
  workspaceId: string
}

export type McpIntegrationsDeleteMcpIntegrationResponse = void

export type FeatureFlagsGetFeatureFlagsResponse = FeatureFlagsRead

export type VcsGetGithubAppManifestResponse = GitHubAppManifestResponse

export type VcsGithubAppInstallCallbackData = {
  /**
   * Temporary code from GitHub manifest flow
   */
  code: string
}

export type VcsGithubAppInstallCallbackResponse = unknown

export type VcsGithubWebhookData = {
  requestBody: {
    [key: string]: unknown
  }
}

export type VcsGithubWebhookResponse = {
  [key: string]: string
}

export type VcsSaveGithubAppCredentialsData = {
  requestBody: GitHubAppCredentialsRequest
}

export type VcsSaveGithubAppCredentialsResponse = {
  [key: string]: string
}

export type VcsGetGithubAppCredentialsStatusResponse =
  GitHubAppCredentialsStatus

export type UsersUsersCurrentUserResponse = UserRead

export type UsersUsersPatchCurrentUserData = {
  requestBody: UserUpdate
}

export type UsersUsersPatchCurrentUserResponse = UserRead

export type UsersUsersUserData = {
  id: string
}

export type UsersUsersUserResponse = UserRead

export type UsersUsersPatchUserData = {
  id: string
  requestBody: UserUpdate
}

export type UsersUsersPatchUserResponse = UserRead

export type UsersUsersDeleteUserData = {
  id: string
}

export type UsersUsersDeleteUserResponse = void

export type AuthAuthDatabaseLoginData = {
  formData: Body_auth_auth_database_login
}

export type AuthAuthDatabaseLoginResponse = unknown | void

export type AuthAuthDatabaseLogoutResponse = unknown | void

export type AuthRegisterRegisterData = {
  requestBody: UserCreate
}

export type AuthRegisterRegisterResponse = UserRead

export type AuthResetForgotPasswordData = {
  requestBody: Body_auth_reset_forgot_password
}

export type AuthResetForgotPasswordResponse = unknown

export type AuthResetResetPasswordData = {
  requestBody: Body_auth_reset_reset_password
}

export type AuthResetResetPasswordResponse = unknown

export type AuthVerifyRequestTokenData = {
  requestBody: Body_auth_verify_request_token
}

export type AuthVerifyRequestTokenResponse = unknown

export type AuthVerifyVerifyData = {
  requestBody: Body_auth_verify_verify
}

export type AuthVerifyVerifyResponse = UserRead

export type AuthOauthGoogleDatabaseAuthorizeData = {
  scopes?: Array<string>
}

export type AuthOauthGoogleDatabaseAuthorizeResponse = OAuth2AuthorizeResponse

export type AuthOauthGoogleDatabaseCallbackData = {
  code?: string | null
  codeVerifier?: string | null
  error?: string | null
  state?: string | null
}

export type AuthOauthGoogleDatabaseCallbackResponse = unknown

export type AuthSamlDatabaseLoginResponse = SAMLDatabaseLoginResponse

export type AuthSsoAcsData = {
  formData: Body_auth_sso_acs
}

export type AuthSsoAcsResponse = unknown

export type PublicCheckHealthResponse = HealthResponse

export type PublicCheckReadyResponse = ReadinessResponse

export type $OpenApiTs = {
  "/webhooks/{workflow_id}/{secret}": {
    post: {
      req: PublicIncomingWebhookPostData
      res: {
        /**
         * Successful Response
         */
        200: unknown
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    get: {
      req: PublicIncomingWebhookGetData
      res: {
        /**
         * Successful Response
         */
        200: unknown
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/webhooks/{workflow_id}/{secret}/wait": {
    post: {
      req: PublicIncomingWebhookWaitData
      res: {
        /**
         * Successful Response
         */
        200: unknown
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/webhooks/{workflow_id}/{secret}/draft": {
    post: {
      req: PublicIncomingWebhookDraftData
      res: {
        /**
         * Successful Response
         */
        200: unknown
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/webhooks/{workflow_id}/{secret}/interactions/{category}": {
    post: {
      req: PublicReceiveInteractionData
      res: {
        /**
         * Successful Response
         */
        200: ReceiveInteractionResponse
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/workspaces": {
    get: {
      res: {
        /**
         * Successful Response
         */
        200: Array<WorkspaceReadMinimal>
      }
    }
    post: {
      req: WorkspacesCreateWorkspaceData
      res: {
        /**
         * Successful Response
         */
        201: WorkspaceReadMinimal
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/workspaces/search": {
    get: {
      req: WorkspacesSearchWorkspacesData
      res: {
        /**
         * Successful Response
         */
        200: Array<WorkspaceReadMinimal>
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/workspaces/{workspace_id}": {
    get: {
      req: WorkspacesGetWorkspaceData
      res: {
        /**
         * Successful Response
         */
        200: WorkspaceRead
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    patch: {
      req: WorkspacesUpdateWorkspaceData
      res: {
        /**
         * Successful Response
         */
        204: void
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    delete: {
      req: WorkspacesDeleteWorkspaceData
      res: {
        /**
         * Successful Response
         */
        204: void
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/workspaces/{workspace_id}/members": {
    get: {
      req: WorkspacesListWorkspaceMembersData
      res: {
        /**
         * Successful Response
         */
        200: Array<WorkspaceMember>
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/workspaces/{workspace_id}/memberships": {
    get: {
      req: WorkspacesListWorkspaceMembershipsData
      res: {
        /**
         * Successful Response
         */
        200: Array<WorkspaceMembershipRead>
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    post: {
      req: WorkspacesCreateWorkspaceMembershipData
      res: {
        /**
         * Successful Response
         */
        201: unknown
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/workspaces/{workspace_id}/memberships/{user_id}": {
    patch: {
      req: WorkspacesUpdateWorkspaceMembershipData
      res: {
        /**
         * Successful Response
         */
        204: void
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    get: {
      req: WorkspacesGetWorkspaceMembershipData
      res: {
        /**
         * Successful Response
         */
        200: WorkspaceMembershipRead
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    delete: {
      req: WorkspacesDeleteWorkspaceMembershipData
      res: {
        /**
         * Successful Response
         */
        204: void
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/workflows": {
    get: {
      req: WorkflowsListWorkflowsData
      res: {
        /**
         * Successful Response
         */
        200: CursorPaginatedResponse_WorkflowReadMinimal_
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    post: {
      req: WorkflowsCreateWorkflowData
      res: {
        /**
         * Successful Response
         */
        201: WorkflowReadMinimal
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/workflows/validate-entrypoint": {
    post: {
      req: WorkflowsValidateWorkflowEntrypointData
      res: {
        /**
         * Successful Response
         */
        200: WorkflowEntrypointValidationResponse
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/workflows/{workflow_id}": {
    get: {
      req: WorkflowsGetWorkflowData
      res: {
        /**
         * Successful Response
         */
        200: WorkflowRead
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    patch: {
      req: WorkflowsUpdateWorkflowData
      res: {
        /**
         * Successful Response
         */
        204: void
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    delete: {
      req: WorkflowsDeleteWorkflowData
      res: {
        /**
         * Successful Response
         */
        204: void
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/workflows/{workflow_id}/commit": {
    post: {
      req: WorkflowsCommitWorkflowData
      res: {
        /**
         * Successful Response
         */
        200: WorkflowCommitResponse
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/workflows/{workflow_id}/export": {
    get: {
      req: WorkflowsExportWorkflowData
      res: {
        /**
         * Successful Response
         */
        200: unknown
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/workflows/{workflow_id}/definitions": {
    get: {
      req: WorkflowsListWorkflowDefinitionsData
      res: {
        /**
         * Successful Response
         */
        200: Array<WorkflowDefinitionRead>
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/workflows/{workflow_id}/definition": {
    get: {
      req: WorkflowsGetWorkflowDefinitionData
      res: {
        /**
         * Successful Response
         */
        200: WorkflowDefinitionRead
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    post: {
      req: WorkflowsCreateWorkflowDefinitionData
      res: {
        /**
         * Successful Response
         */
        200: WorkflowDefinitionRead
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/workflows/{workflow_id}/webhook": {
    post: {
      req: TriggersCreateWebhookData
      res: {
        /**
         * Successful Response
         */
        201: unknown
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    get: {
      req: TriggersGetWebhookData
      res: {
        /**
         * Successful Response
         */
        200: WebhookRead
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    patch: {
      req: TriggersUpdateWebhookData
      res: {
        /**
         * Successful Response
         */
        204: void
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/workflows/{workflow_id}/webhook/api-key": {
    post: {
      req: TriggersGenerateWebhookApiKeyData
      res: {
        /**
         * Successful Response
         */
        201: WebhookApiKeyGenerateResponse
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    delete: {
      req: TriggersDeleteWebhookApiKeyData
      res: {
        /**
         * Successful Response
         */
        204: void
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/workflows/{workflow_id}/webhook/api-key/revoke": {
    post: {
      req: TriggersRevokeWebhookApiKeyData
      res: {
        /**
         * Successful Response
         */
        204: void
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/workflows/{workflow_id}/move": {
    post: {
      req: WorkflowsMoveWorkflowToFolderData
      res: {
        /**
         * Successful Response
         */
        204: void
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/workflows/{workflow_id}/graph": {
    get: {
      req: GraphGetGraphData
      res: {
        /**
         * Successful Response
         */
        200: GraphResponse
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    patch: {
      req: GraphApplyGraphOperationsData
      res: {
        /**
         * Successful Response
         */
        200: GraphResponse
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/workflow-executions": {
    get: {
      req: WorkflowExecutionsListWorkflowExecutionsData
      res: {
        /**
         * Successful Response
         */
        200: Array<WorkflowExecutionReadMinimal>
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    post: {
      req: WorkflowExecutionsCreateWorkflowExecutionData
      res: {
        /**
         * Successful Response
         */
        200: WorkflowExecutionCreateResponse
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/workflow-executions/{execution_id}": {
    get: {
      req: WorkflowExecutionsGetWorkflowExecutionData
      res: {
        /**
         * Successful Response
         */
        200: WorkflowExecutionRead
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/workflow-executions/{execution_id}/compact": {
    get: {
      req: WorkflowExecutionsGetWorkflowExecutionCompactData
      res: {
        /**
         * Successful Response
         */
        200: WorkflowExecutionReadCompact_Any__Union_AgentOutput__Any___Any_
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/workflow-executions/draft": {
    post: {
      req: WorkflowExecutionsCreateDraftWorkflowExecutionData
      res: {
        /**
         * Successful Response
         */
        200: WorkflowExecutionCreateResponse
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/workflow-executions/{execution_id}/cancel": {
    post: {
      req: WorkflowExecutionsCancelWorkflowExecutionData
      res: {
        /**
         * Successful Response
         */
        204: void
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/workflow-executions/{execution_id}/terminate": {
    post: {
      req: WorkflowExecutionsTerminateWorkflowExecutionData
      res: {
        /**
         * Successful Response
         */
        204: void
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/actions/batch-positions": {
    post: {
      req: ActionsBatchUpdatePositionsData
      res: {
        /**
         * Successful Response
         */
        204: void
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/actions": {
    get: {
      req: ActionsListActionsData
      res: {
        /**
         * Successful Response
         */
        200: Array<ActionReadMinimal>
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    post: {
      req: ActionsCreateActionData
      res: {
        /**
         * Successful Response
         */
        200: ActionReadMinimal
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/actions/{action_id}": {
    get: {
      req: ActionsGetActionData
      res: {
        /**
         * Successful Response
         */
        200: ActionRead
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    post: {
      req: ActionsUpdateActionData
      res: {
        /**
         * Successful Response
         */
        200: ActionRead
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    delete: {
      req: ActionsDeleteActionData
      res: {
        /**
         * Successful Response
         */
        204: void
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/workflows/{workflow_id}/tags": {
    get: {
      req: WorkflowsListTagsData
      res: {
        /**
         * Successful Response
         */
        200: Array<TagRead>
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    post: {
      req: WorkflowsAddTagData
      res: {
        /**
         * Successful Response
         */
        201: unknown
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/workflows/{workflow_id}/tags/{tag_id}": {
    delete: {
      req: WorkflowsRemoveTagData
      res: {
        /**
         * Successful Response
         */
        204: void
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/workflows/{workflow_id}/publish": {
    post: {
      req: WorkflowsPublishWorkflowData
      res: {
        /**
         * Successful Response
         */
        204: void
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/workflows/sync/commits": {
    get: {
      req: WorkflowsListWorkflowCommitsData
      res: {
        /**
         * Successful Response
         */
        200: Array<GitCommitInfo>
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/workflows/sync/pull": {
    post: {
      req: WorkflowsPullWorkflowsData
      res: {
        /**
         * Successful Response
         */
        200: PullResult
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/secrets/search": {
    get: {
      req: SecretsSearchSecretsData
      res: {
        /**
         * Successful Response
         */
        200: Array<SecretRead>
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/secrets": {
    get: {
      req: SecretsListSecretsData
      res: {
        /**
         * Successful Response
         */
        200: Array<SecretReadMinimal>
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    post: {
      req: SecretsCreateSecretData
      res: {
        /**
         * Successful Response
         */
        201: unknown
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/secrets/definitions": {
    get: {
      req: SecretsListSecretDefinitionsData
      res: {
        /**
         * Successful Response
         */
        200: Array<SecretDefinition>
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/secrets/{secret_name}": {
    get: {
      req: SecretsGetSecretByNameData
      res: {
        /**
         * Successful Response
         */
        200: SecretRead
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/secrets/{secret_id}": {
    post: {
      req: SecretsUpdateSecretByIdData
      res: {
        /**
         * Successful Response
         */
        204: void
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    delete: {
      req: SecretsDeleteSecretByIdData
      res: {
        /**
         * Successful Response
         */
        204: void
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/variables/search": {
    get: {
      req: VariablesSearchVariablesData
      res: {
        /**
         * Successful Response
         */
        200: Array<VariableRead>
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/variables": {
    get: {
      req: VariablesListVariablesData
      res: {
        /**
         * Successful Response
         */
        200: Array<VariableReadMinimal>
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    post: {
      req: VariablesCreateVariableData
      res: {
        /**
         * Successful Response
         */
        201: VariableRead
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/variables/{variable_name}": {
    get: {
      req: VariablesGetVariableByNameData
      res: {
        /**
         * Successful Response
         */
        200: VariableRead
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/variables/{variable_id}": {
    post: {
      req: VariablesUpdateVariableByIdData
      res: {
        /**
         * Successful Response
         */
        200: VariableRead
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    delete: {
      req: VariablesDeleteVariableByIdData
      res: {
        /**
         * Successful Response
         */
        204: void
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/schedules": {
    get: {
      req: SchedulesListSchedulesData
      res: {
        /**
         * Successful Response
         */
        200: Array<ScheduleRead>
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    post: {
      req: SchedulesCreateScheduleData
      res: {
        /**
         * Successful Response
         */
        200: ScheduleRead
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/schedules/{schedule_id}": {
    get: {
      req: SchedulesGetScheduleData
      res: {
        /**
         * Successful Response
         */
        200: ScheduleRead
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    post: {
      req: SchedulesUpdateScheduleData
      res: {
        /**
         * Successful Response
         */
        200: ScheduleRead
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    delete: {
      req: SchedulesDeleteScheduleData
      res: {
        /**
         * Successful Response
         */
        204: void
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/schedules/search": {
    get: {
      req: SchedulesSearchSchedulesData
      res: {
        /**
         * Successful Response
         */
        200: Array<ScheduleRead>
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/tags": {
    get: {
      req: TagsListTagsData
      res: {
        /**
         * Successful Response
         */
        200: Array<TagRead>
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    post: {
      req: TagsCreateTagData
      res: {
        /**
         * Successful Response
         */
        200: TagRead
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/tags/{tag_id}": {
    get: {
      req: TagsGetTagData
      res: {
        /**
         * Successful Response
         */
        200: TagRead
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    patch: {
      req: TagsUpdateTagData
      res: {
        /**
         * Successful Response
         */
        200: TagRead
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    delete: {
      req: TagsDeleteTagData
      res: {
        /**
         * Successful Response
         */
        200: unknown
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/users/search": {
    get: {
      req: UsersSearchUserData
      res: {
        /**
         * Successful Response
         */
        200: UserRead
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/organization/members": {
    get: {
      res: {
        /**
         * Successful Response
         */
        200: Array<OrgMemberRead>
      }
    }
  }
  "/organization/members/{user_id}": {
    delete: {
      req: OrganizationDeleteOrgMemberData
      res: {
        /**
         * Successful Response
         */
        204: void
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    patch: {
      req: OrganizationUpdateOrgMemberData
      res: {
        /**
         * Successful Response
         */
        200: OrgMemberRead
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/organization/sessions": {
    get: {
      res: {
        /**
         * Successful Response
         */
        200: Array<SessionRead>
      }
    }
  }
  "/organization/sessions/{session_id}": {
    delete: {
      req: OrganizationDeleteSessionData
      res: {
        /**
         * Successful Response
         */
        204: void
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/organization/invitations": {
    post: {
      req: OrganizationCreateInvitationData
      res: {
        /**
         * Successful Response
         */
        201: OrgInvitationRead
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    get: {
      req: OrganizationListInvitationsData
      res: {
        /**
         * Successful Response
         */
        200: Array<OrgInvitationRead>
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/organization/invitations/{invitation_id}": {
    delete: {
      req: OrganizationRevokeInvitationData
      res: {
        /**
         * Successful Response
         */
        204: void
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/organization/invitations/accept": {
    post: {
      req: OrganizationAcceptInvitationData
      res: {
        /**
         * Successful Response
         */
        200: {
          [key: string]: string
        }
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/organization/invitations/token/{token}": {
    get: {
      req: OrganizationGetInvitationByTokenData
      res: {
        /**
         * Successful Response
         */
        200: OrgInvitationReadMinimal
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/agent/models": {
    get: {
      res: {
        /**
         * Successful Response
         */
        200: {
          [key: string]: ModelConfig
        }
      }
    }
  }
  "/agent/providers": {
    get: {
      res: {
        /**
         * Successful Response
         */
        200: Array<string>
      }
    }
  }
  "/agent/providers/status": {
    get: {
      res: {
        /**
         * Successful Response
         */
        200: {
          [key: string]: boolean
        }
      }
    }
  }
  "/agent/providers/configs": {
    get: {
      res: {
        /**
         * Successful Response
         */
        200: Array<ProviderCredentialConfig>
      }
    }
  }
  "/agent/providers/{provider}/config": {
    get: {
      req: AgentGetProviderCredentialConfigData
      res: {
        /**
         * Successful Response
         */
        200: ProviderCredentialConfig
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/agent/credentials": {
    post: {
      req: AgentCreateProviderCredentialsData
      res: {
        /**
         * Successful Response
         */
        201: {
          [key: string]: string
        }
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/agent/credentials/{provider}": {
    put: {
      req: AgentUpdateProviderCredentialsData
      res: {
        /**
         * Successful Response
         */
        200: {
          [key: string]: string
        }
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    delete: {
      req: AgentDeleteProviderCredentialsData
      res: {
        /**
         * Successful Response
         */
        200: {
          [key: string]: string
        }
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/agent/default-model": {
    get: {
      res: {
        /**
         * Successful Response
         */
        200: string | null
      }
    }
    put: {
      req: AgentSetDefaultModelData
      res: {
        /**
         * Successful Response
         */
        200: {
          [key: string]: string
        }
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/agent/workspace/providers/status": {
    get: {
      req: AgentGetWorkspaceProvidersStatusData
      res: {
        /**
         * Successful Response
         */
        200: {
          [key: string]: boolean
        }
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/agent/presets": {
    get: {
      req: AgentPresetsListAgentPresetsData
      res: {
        /**
         * Successful Response
         */
        200: Array<AgentPresetReadMinimal>
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    post: {
      req: AgentPresetsCreateAgentPresetData
      res: {
        /**
         * Successful Response
         */
        201: AgentPresetRead
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/agent/presets/{preset_id}": {
    get: {
      req: AgentPresetsGetAgentPresetData
      res: {
        /**
         * Successful Response
         */
        200: AgentPresetRead
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    patch: {
      req: AgentPresetsUpdateAgentPresetData
      res: {
        /**
         * Successful Response
         */
        200: AgentPresetRead
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    delete: {
      req: AgentPresetsDeleteAgentPresetData
      res: {
        /**
         * Successful Response
         */
        204: void
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/agent/presets/by-slug/{slug}": {
    get: {
      req: AgentPresetsGetAgentPresetBySlugData
      res: {
        /**
         * Successful Response
         */
        200: AgentPresetRead
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/agent/sessions": {
    post: {
      req: AgentSessionsCreateSessionData
      res: {
        /**
         * Successful Response
         */
        200: AgentSessionRead
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    get: {
      req: AgentSessionsListSessionsData
      res: {
        /**
         * Successful Response
         */
        200: Array<AgentSessionRead | ChatReadMinimal>
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/agent/sessions/{session_id}": {
    get: {
      req: AgentSessionsGetSessionData
      res: {
        /**
         * Successful Response
         */
        200: AgentSessionReadWithMessages | ChatRead
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    patch: {
      req: AgentSessionsUpdateSessionData
      res: {
        /**
         * Successful Response
         */
        200: AgentSessionRead
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    delete: {
      req: AgentSessionsDeleteSessionData
      res: {
        /**
         * Successful Response
         */
        204: void
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/agent/sessions/{session_id}/vercel": {
    get: {
      req: AgentSessionsGetSessionVercelData
      res: {
        /**
         * Successful Response
         */
        200: AgentSessionReadVercel | ChatReadVercel
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/agent/sessions/{session_id}/messages": {
    post: {
      req: AgentSessionsSendMessageData
      res: {
        /**
         * Successful Response
         */
        200: unknown
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/agent/sessions/{session_id}/stream": {
    get: {
      req: AgentSessionsStreamSessionEventsData
      res: {
        /**
         * Successful Response
         */
        200: unknown
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/agent/sessions/{session_id}/fork": {
    post: {
      req: AgentSessionsForkSessionData
      res: {
        /**
         * Successful Response
         */
        200: AgentSessionRead
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/approvals/{session_id}": {
    post: {
      req: ApprovalsSubmitApprovalsData
      res: {
        /**
         * Successful Response
         */
        204: void
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/admin/organizations": {
    get: {
      res: {
        /**
         * Successful Response
         */
        200: Array<OrgRead>
      }
    }
    post: {
      req: AdminCreateOrganizationData
      res: {
        /**
         * Successful Response
         */
        201: OrgRead
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/admin/organizations/{org_id}": {
    get: {
      req: AdminGetOrganizationData
      res: {
        /**
         * Successful Response
         */
        200: OrgRead
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    patch: {
      req: AdminUpdateOrganizationData
      res: {
        /**
         * Successful Response
         */
        200: OrgRead
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    delete: {
      req: AdminDeleteOrganizationData
      res: {
        /**
         * Successful Response
         */
        204: void
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/admin/organizations/{org_id}/registry/repositories": {
    get: {
      req: AdminListOrgRepositoriesData
      res: {
        /**
         * Successful Response
         */
        200: Array<OrgRegistryRepositoryRead>
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/admin/organizations/{org_id}/registry/repositories/{repository_id}/versions": {
    get: {
      req: AdminListOrgRepositoryVersionsData
      res: {
        /**
         * Successful Response
         */
        200: Array<OrgRegistryVersionRead>
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/admin/organizations/{org_id}/registry/repositories/{repository_id}/sync": {
    post: {
      req: AdminSyncOrgRepositoryData
      res: {
        /**
         * Successful Response
         */
        200: OrgRegistrySyncResponse
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/admin/organizations/{org_id}/registry/repositories/{repository_id}/versions/{version_id}/promote": {
    post: {
      req: AdminPromoteOrgRepositoryVersionData
      res: {
        /**
         * Successful Response
         */
        200: OrgRegistryVersionPromoteResponse
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/admin/registry/sync": {
    post: {
      req: AdminSyncAllRepositoriesData
      res: {
        /**
         * Successful Response
         */
        200: tracecat_ee__admin__registry__schemas__RegistrySyncResponse
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/admin/registry/sync/{repository_id}": {
    post: {
      req: AdminSyncRepositoryData
      res: {
        /**
         * Successful Response
         */
        200: tracecat_ee__admin__registry__schemas__RegistrySyncResponse
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/admin/registry/status": {
    get: {
      res: {
        /**
         * Successful Response
         */
        200: RegistryStatusResponse
      }
    }
  }
  "/admin/registry/versions": {
    get: {
      req: AdminListRegistryVersionsData
      res: {
        /**
         * Successful Response
         */
        200: Array<tracecat_ee__admin__registry__schemas__RegistryVersionRead>
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/admin/registry/{repository_id}/versions/{version_id}/promote": {
    post: {
      req: AdminPromoteRegistryVersionData
      res: {
        /**
         * Successful Response
         */
        200: tracecat_ee__admin__registry__schemas__RegistryVersionPromoteResponse
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/admin/settings/registry": {
    get: {
      res: {
        /**
         * Successful Response
         */
        200: PlatformRegistrySettingsRead
      }
    }
    patch: {
      req: AdminUpdateRegistrySettingsData
      res: {
        /**
         * Successful Response
         */
        200: PlatformRegistrySettingsRead
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/admin/tiers": {
    get: {
      req: AdminListTiersData
      res: {
        /**
         * Successful Response
         */
        200: Array<TierRead>
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    post: {
      req: AdminCreateTierData
      res: {
        /**
         * Successful Response
         */
        201: TierRead
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/admin/tiers/{tier_id}": {
    get: {
      req: AdminGetTierData
      res: {
        /**
         * Successful Response
         */
        200: TierRead
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    patch: {
      req: AdminUpdateTierData
      res: {
        /**
         * Successful Response
         */
        200: TierRead
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    delete: {
      req: AdminDeleteTierData
      res: {
        /**
         * Successful Response
         */
        204: void
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/admin/tiers/organizations/{org_id}": {
    get: {
      req: AdminGetOrgTierData
      res: {
        /**
         * Successful Response
         */
        200: OrganizationTierRead
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    patch: {
      req: AdminUpdateOrgTierData
      res: {
        /**
         * Successful Response
         */
        200: OrganizationTierRead
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/admin/users": {
    get: {
      res: {
        /**
         * Successful Response
         */
        200: Array<AdminUserRead>
      }
    }
  }
  "/admin/users/{user_id}": {
    get: {
      req: AdminGetUserData
      res: {
        /**
         * Successful Response
         */
        200: AdminUserRead
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/admin/users/{user_id}/promote": {
    post: {
      req: AdminPromoteToSuperuserData
      res: {
        /**
         * Successful Response
         */
        200: AdminUserRead
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/admin/users/{user_id}/demote": {
    post: {
      req: AdminDemoteFromSuperuserData
      res: {
        /**
         * Successful Response
         */
        200: AdminUserRead
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/inbox": {
    get: {
      req: InboxListItemsData
      res: {
        /**
         * Successful Response
         */
        200: Array<InboxItemRead>
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/inbox/paginated": {
    get: {
      req: InboxListItemsPaginatedData
      res: {
        /**
         * Successful Response
         */
        200: CursorPaginatedResponse_InboxItemRead_
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/editor/functions": {
    get: {
      req: EditorListFunctionsData
      res: {
        /**
         * Successful Response
         */
        200: Array<EditorFunctionRead>
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/editor/actions": {
    get: {
      req: EditorListActionsData
      res: {
        /**
         * Successful Response
         */
        200: Array<EditorActionRead>
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/editor/expressions/validate": {
    post: {
      req: EditorValidateExpressionData
      res: {
        /**
         * Successful Response
         */
        200: ExpressionValidationResponse
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/editor/field-schema": {
    get: {
      res: {
        /**
         * Successful Response
         */
        200: EditorComponent
      }
    }
  }
  "/registry/repos/reload": {
    post: {
      res: {
        /**
         * Successful Response
         */
        204: void
      }
    }
  }
  "/registry/repos/{repository_id}/sync": {
    post: {
      req: RegistryRepositoriesSyncRegistryRepositoryData
      res: {
        /**
         * Successful Response
         */
        200: tracecat__registry__repositories__schemas__RegistrySyncResponse
        /**
         * Cannot sync repository
         */
        400: unknown
        /**
         * Registry repository not found
         */
        404: unknown
        /**
         * Registry sync validation error
         */
        422: RegistryRepositoryErrorDetail
      }
    }
  }
  "/registry/repos/{repository_id}/versions": {
    get: {
      req: RegistryRepositoriesListRepositoryVersionsData
      res: {
        /**
         * Successful Response
         */
        200: Array<tracecat__registry__repositories__schemas__RegistryVersionRead>
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/registry/repos": {
    get: {
      res: {
        /**
         * Successful Response
         */
        200: Array<RegistryRepositoryReadMinimal>
      }
    }
    post: {
      req: RegistryRepositoriesCreateRegistryRepositoryData
      res: {
        /**
         * Successful Response
         */
        201: RegistryRepositoryRead
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/registry/repos/{repository_id}": {
    get: {
      req: RegistryRepositoriesGetRegistryRepositoryData
      res: {
        /**
         * Successful Response
         */
        200: RegistryRepositoryRead
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    patch: {
      req: RegistryRepositoriesUpdateRegistryRepositoryData
      res: {
        /**
         * Successful Response
         */
        200: RegistryRepositoryRead
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    delete: {
      req: RegistryRepositoriesDeleteRegistryRepositoryData
      res: {
        /**
         * Successful Response
         */
        204: void
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/registry/repos/{repository_id}/commits": {
    get: {
      req: RegistryRepositoriesListRepositoryCommitsData
      res: {
        /**
         * Successful Response
         */
        200: Array<GitCommitInfo>
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/registry/repos/{repository_id}/versions/{version_id}/promote": {
    post: {
      req: RegistryRepositoriesPromoteRegistryVersionData
      res: {
        /**
         * Successful Response
         */
        200: tracecat__registry__repositories__schemas__RegistryVersionPromoteResponse
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/registry/actions": {
    get: {
      res: {
        /**
         * Successful Response
         */
        200: Array<RegistryActionReadMinimal>
      }
    }
    post: {
      req: RegistryActionsCreateRegistryActionData
      res: {
        /**
         * Successful Response
         */
        201: RegistryActionRead
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/registry/actions/{action_name}": {
    get: {
      req: RegistryActionsGetRegistryActionData
      res: {
        /**
         * Successful Response
         */
        200: RegistryActionRead
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    patch: {
      req: RegistryActionsUpdateRegistryActionData
      res: {
        /**
         * Successful Response
         */
        204: void
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    delete: {
      req: RegistryActionsDeleteRegistryActionData
      res: {
        /**
         * Successful Response
         */
        204: void
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/settings/git": {
    get: {
      res: {
        /**
         * Successful Response
         */
        200: GitSettingsRead
      }
    }
    patch: {
      req: SettingsUpdateGitSettingsData
      res: {
        /**
         * Successful Response
         */
        204: void
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/settings/saml": {
    get: {
      res: {
        /**
         * Successful Response
         */
        200: SAMLSettingsRead
      }
    }
    patch: {
      req: SettingsUpdateSamlSettingsData
      res: {
        /**
         * Successful Response
         */
        204: void
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/settings/auth": {
    get: {
      res: {
        /**
         * Successful Response
         */
        200: AuthSettingsRead
      }
    }
    patch: {
      req: SettingsUpdateAuthSettingsData
      res: {
        /**
         * Successful Response
         */
        204: void
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/settings/oauth": {
    get: {
      res: {
        /**
         * Successful Response
         */
        200: OAuthSettingsRead
      }
    }
    patch: {
      req: SettingsUpdateOauthSettingsData
      res: {
        /**
         * Successful Response
         */
        204: void
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/settings/app": {
    get: {
      res: {
        /**
         * Successful Response
         */
        200: AppSettingsRead
      }
    }
    patch: {
      req: SettingsUpdateAppSettingsData
      res: {
        /**
         * Successful Response
         */
        204: void
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/settings/audit": {
    get: {
      res: {
        /**
         * Successful Response
         */
        200: AuditSettingsRead
      }
    }
    patch: {
      req: SettingsUpdateAuditSettingsData
      res: {
        /**
         * Successful Response
         */
        204: void
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/settings/agent": {
    get: {
      res: {
        /**
         * Successful Response
         */
        200: AgentSettingsRead
      }
    }
    patch: {
      req: SettingsUpdateAgentSettingsData
      res: {
        /**
         * Successful Response
         */
        204: void
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/organization/secrets": {
    get: {
      req: OrganizationSecretsListOrgSecretsData
      res: {
        /**
         * Successful Response
         */
        200: Array<SecretReadMinimal>
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    post: {
      req: OrganizationSecretsCreateOrgSecretData
      res: {
        /**
         * Successful Response
         */
        201: unknown
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/organization/secrets/{secret_name}": {
    get: {
      req: OrganizationSecretsGetOrgSecretByNameData
      res: {
        /**
         * Successful Response
         */
        200: OrganizationSecretRead
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/organization/secrets/{secret_id}": {
    post: {
      req: OrganizationSecretsUpdateOrgSecretByIdData
      res: {
        /**
         * Successful Response
         */
        204: void
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    delete: {
      req: OrganizationSecretsDeleteOrgSecretByIdData
      res: {
        /**
         * Successful Response
         */
        204: void
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/tables": {
    get: {
      req: TablesListTablesData
      res: {
        /**
         * Successful Response
         */
        200: Array<TableReadMinimal>
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    post: {
      req: TablesCreateTableData
      res: {
        /**
         * Successful Response
         */
        201: unknown
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/tables/{table_id}": {
    get: {
      req: TablesGetTableData
      res: {
        /**
         * Successful Response
         */
        200: TableRead
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    patch: {
      req: TablesUpdateTableData
      res: {
        /**
         * Successful Response
         */
        204: void
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    delete: {
      req: TablesDeleteTableData
      res: {
        /**
         * Successful Response
         */
        204: void
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/tables/{table_id}/columns": {
    post: {
      req: TablesCreateColumnData
      res: {
        /**
         * Successful Response
         */
        201: unknown
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/tables/{table_id}/columns/{column_id}": {
    patch: {
      req: TablesUpdateColumnData
      res: {
        /**
         * Successful Response
         */
        204: void
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    delete: {
      req: TablesDeleteColumnData
      res: {
        /**
         * Successful Response
         */
        204: void
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/tables/{table_id}/rows": {
    get: {
      req: TablesListRowsData
      res: {
        /**
         * Successful Response
         */
        200: CursorPaginatedResponse_TableRowRead_
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    post: {
      req: TablesInsertRowData
      res: {
        /**
         * Successful Response
         */
        201: unknown
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/tables/{table_id}/rows/{row_id}": {
    get: {
      req: TablesGetRowData
      res: {
        /**
         * Successful Response
         */
        200: unknown
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    delete: {
      req: TablesDeleteRowData
      res: {
        /**
         * Successful Response
         */
        204: void
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/tables/{table_id}/rows/batch": {
    post: {
      req: TablesBatchInsertRowsData
      res: {
        /**
         * Successful Response
         */
        201: TableRowInsertBatchResponse
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/tables/import": {
    post: {
      req: TablesImportTableFromCsvData
      res: {
        /**
         * Successful Response
         */
        201: TableImportResponse
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/tables/{table_id}/import": {
    post: {
      req: TablesImportCsvData
      res: {
        /**
         * Successful Response
         */
        201: TableRowInsertBatchResponse
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/cases": {
    get: {
      req: CasesListCasesData
      res: {
        /**
         * Successful Response
         */
        200: CursorPaginatedResponse_CaseReadMinimal_
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    post: {
      req: CasesCreateCaseData
      res: {
        /**
         * Successful Response
         */
        201: unknown
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/cases/search": {
    get: {
      req: CasesSearchCasesData
      res: {
        /**
         * Successful Response
         */
        200: Array<CaseReadMinimal>
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/cases/{case_id}": {
    get: {
      req: CasesGetCaseData
      res: {
        /**
         * Successful Response
         */
        200: CaseRead
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    patch: {
      req: CasesUpdateCaseData
      res: {
        /**
         * Successful Response
         */
        204: void
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    delete: {
      req: CasesDeleteCaseData
      res: {
        /**
         * Successful Response
         */
        204: void
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/cases/{case_id}/comments": {
    get: {
      req: CasesListCommentsData
      res: {
        /**
         * Successful Response
         */
        200: Array<CaseCommentRead>
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    post: {
      req: CasesCreateCommentData
      res: {
        /**
         * Successful Response
         */
        201: unknown
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/cases/{case_id}/comments/{comment_id}": {
    patch: {
      req: CasesUpdateCommentData
      res: {
        /**
         * Successful Response
         */
        204: void
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    delete: {
      req: CasesDeleteCommentData
      res: {
        /**
         * Successful Response
         */
        204: void
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/cases/{case_id}/events": {
    get: {
      req: CasesListEventsWithUsersData
      res: {
        /**
         * Successful Response
         */
        200: CaseEventsWithUsers
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/cases/{case_id}/tasks": {
    get: {
      req: CasesListTasksData
      res: {
        /**
         * Successful Response
         */
        200: Array<CaseTaskRead>
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    post: {
      req: CasesCreateTaskData
      res: {
        /**
         * Successful Response
         */
        201: CaseTaskRead
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/cases/{case_id}/tasks/{task_id}": {
    patch: {
      req: CasesUpdateTaskData
      res: {
        /**
         * Successful Response
         */
        200: CaseTaskRead
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    delete: {
      req: CasesDeleteTaskData
      res: {
        /**
         * Successful Response
         */
        204: void
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/case-fields": {
    get: {
      req: CasesListFieldsData
      res: {
        /**
         * Successful Response
         */
        200: Array<CaseFieldReadMinimal>
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    post: {
      req: CasesCreateFieldData
      res: {
        /**
         * Successful Response
         */
        201: unknown
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/case-fields/{field_id}": {
    patch: {
      req: CasesUpdateFieldData
      res: {
        /**
         * Successful Response
         */
        204: void
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    delete: {
      req: CasesDeleteFieldData
      res: {
        /**
         * Successful Response
         */
        204: void
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/cases/{case_id}/tags": {
    get: {
      req: CasesListTagsData
      res: {
        /**
         * Successful Response
         */
        200: Array<CaseTagRead>
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    post: {
      req: CasesAddTagData
      res: {
        /**
         * Successful Response
         */
        201: CaseTagRead
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/cases/{case_id}/tags/{tag_identifier}": {
    delete: {
      req: CasesRemoveTagData
      res: {
        /**
         * Successful Response
         */
        204: void
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/case-tags": {
    get: {
      req: CaseTagsListCaseTagsData
      res: {
        /**
         * Successful Response
         */
        200: Array<CaseTagRead>
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    post: {
      req: CaseTagsCreateCaseTagData
      res: {
        /**
         * Successful Response
         */
        201: CaseTagRead
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/case-tags/{tag_id}": {
    get: {
      req: CaseTagsGetCaseTagData
      res: {
        /**
         * Successful Response
         */
        200: CaseTagRead
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    patch: {
      req: CaseTagsUpdateCaseTagData
      res: {
        /**
         * Successful Response
         */
        200: CaseTagRead
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    delete: {
      req: CaseTagsDeleteCaseTagData
      res: {
        /**
         * Successful Response
         */
        204: void
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/cases/{case_id}/attachments": {
    get: {
      req: CaseAttachmentsListAttachmentsData
      res: {
        /**
         * Successful Response
         */
        200: Array<CaseAttachmentRead>
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    post: {
      req: CaseAttachmentsCreateAttachmentData
      res: {
        /**
         * Successful Response
         */
        201: CaseAttachmentRead
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/cases/{case_id}/attachments/{attachment_id}": {
    get: {
      req: CaseAttachmentsDownloadAttachmentData
      res: {
        /**
         * Successful Response
         */
        200: CaseAttachmentDownloadResponse
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    delete: {
      req: CaseAttachmentsDeleteAttachmentData
      res: {
        /**
         * Successful Response
         */
        204: void
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/case-durations": {
    get: {
      req: CaseDurationsListCaseDurationDefinitionsData
      res: {
        /**
         * Successful Response
         */
        200: Array<CaseDurationDefinitionRead>
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    post: {
      req: CaseDurationsCreateCaseDurationDefinitionData
      res: {
        /**
         * Successful Response
         */
        201: CaseDurationDefinitionRead
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/case-durations/{duration_id}": {
    get: {
      req: CaseDurationsGetCaseDurationDefinitionData
      res: {
        /**
         * Successful Response
         */
        200: CaseDurationDefinitionRead
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    patch: {
      req: CaseDurationsUpdateCaseDurationDefinitionData
      res: {
        /**
         * Successful Response
         */
        200: CaseDurationDefinitionRead
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    delete: {
      req: CaseDurationsDeleteCaseDurationDefinitionData
      res: {
        /**
         * Successful Response
         */
        204: void
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/cases/{case_id}/durations": {
    get: {
      req: CaseDurationsListCaseDurationsData
      res: {
        /**
         * Successful Response
         */
        200: Array<CaseDurationRead>
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    post: {
      req: CaseDurationsCreateCaseDurationData
      res: {
        /**
         * Successful Response
         */
        201: CaseDurationRead
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/cases/{case_id}/durations/{duration_id}": {
    get: {
      req: CaseDurationsGetCaseDurationData
      res: {
        /**
         * Successful Response
         */
        200: CaseDurationRead
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    patch: {
      req: CaseDurationsUpdateCaseDurationData
      res: {
        /**
         * Successful Response
         */
        200: CaseDurationRead
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    delete: {
      req: CaseDurationsDeleteCaseDurationData
      res: {
        /**
         * Successful Response
         */
        204: void
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/folders/directory": {
    get: {
      req: FoldersGetDirectoryData
      res: {
        /**
         * Successful Response
         */
        200: Array<WorkflowDirectoryItem | FolderDirectoryItem>
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/folders": {
    get: {
      req: FoldersListFoldersData
      res: {
        /**
         * Successful Response
         */
        200: Array<WorkflowFolderRead>
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    post: {
      req: FoldersCreateFolderData
      res: {
        /**
         * Successful Response
         */
        201: WorkflowFolderRead
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/folders/{folder_id}": {
    get: {
      req: FoldersGetFolderData
      res: {
        /**
         * Successful Response
         */
        200: WorkflowFolderRead
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    patch: {
      req: FoldersUpdateFolderData
      res: {
        /**
         * Successful Response
         */
        200: WorkflowFolderRead
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    delete: {
      req: FoldersDeleteFolderData
      res: {
        /**
         * Successful Response
         */
        204: void
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/folders/{folder_id}/move": {
    post: {
      req: FoldersMoveFolderData
      res: {
        /**
         * Successful Response
         */
        200: WorkflowFolderRead
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/integrations/callback": {
    get: {
      req: IntegrationsOauthCallbackData
      res: {
        /**
         * Successful Response
         */
        200: IntegrationOAuthCallback
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/integrations": {
    get: {
      req: IntegrationsListIntegrationsData
      res: {
        /**
         * Successful Response
         */
        200: Array<IntegrationReadMinimal>
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/integrations/{provider_id}": {
    get: {
      req: IntegrationsGetIntegrationData
      res: {
        /**
         * Successful Response
         */
        200: IntegrationRead
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    delete: {
      req: IntegrationsDeleteIntegrationData
      res: {
        /**
         * Successful Response
         */
        204: void
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    put: {
      req: IntegrationsUpdateIntegrationData
      res: {
        /**
         * Successful Response
         */
        204: void
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/integrations/{provider_id}/connect": {
    post: {
      req: IntegrationsConnectProviderData
      res: {
        /**
         * Successful Response
         */
        200: IntegrationOAuthConnect
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/integrations/{provider_id}/disconnect": {
    post: {
      req: IntegrationsDisconnectIntegrationData
      res: {
        /**
         * Successful Response
         */
        204: void
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/integrations/{provider_id}/test": {
    post: {
      req: IntegrationsTestConnectionData
      res: {
        /**
         * Successful Response
         */
        200: IntegrationTestConnectionResponse
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/providers": {
    post: {
      req: ProvidersCreateCustomProviderData
      res: {
        /**
         * Successful Response
         */
        201: ProviderReadMinimal
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    get: {
      req: ProvidersListProvidersData
      res: {
        /**
         * Successful Response
         */
        200: Array<ProviderReadMinimal>
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/providers/{provider_id}": {
    get: {
      req: ProvidersGetProviderData
      res: {
        /**
         * Successful Response
         */
        200: ProviderRead
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/mcp-integrations": {
    post: {
      req: McpIntegrationsCreateMcpIntegrationData
      res: {
        /**
         * Successful Response
         */
        201: MCPIntegrationRead
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    get: {
      req: McpIntegrationsListMcpIntegrationsData
      res: {
        /**
         * Successful Response
         */
        200: Array<MCPIntegrationRead>
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/mcp-integrations/{mcp_integration_id}": {
    get: {
      req: McpIntegrationsGetMcpIntegrationData
      res: {
        /**
         * Successful Response
         */
        200: MCPIntegrationRead
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    put: {
      req: McpIntegrationsUpdateMcpIntegrationData
      res: {
        /**
         * Successful Response
         */
        200: MCPIntegrationRead
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    delete: {
      req: McpIntegrationsDeleteMcpIntegrationData
      res: {
        /**
         * Successful Response
         */
        204: void
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/feature-flags": {
    get: {
      res: {
        /**
         * Successful Response
         */
        200: FeatureFlagsRead
      }
    }
  }
  "/organization/vcs/github/manifest": {
    get: {
      res: {
        /**
         * Successful Response
         */
        200: GitHubAppManifestResponse
      }
    }
  }
  "/organization/vcs/github/install": {
    get: {
      req: VcsGithubAppInstallCallbackData
      res: {
        /**
         * Successful Response
         */
        200: unknown
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/organization/vcs/github/webhook": {
    post: {
      req: VcsGithubWebhookData
      res: {
        /**
         * Successful Response
         */
        200: {
          [key: string]: string
        }
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/organization/vcs/github/credentials": {
    post: {
      req: VcsSaveGithubAppCredentialsData
      res: {
        /**
         * Successful Response
         */
        201: {
          [key: string]: string
        }
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/organization/vcs/github/credentials/status": {
    get: {
      res: {
        /**
         * Successful Response
         */
        200: GitHubAppCredentialsStatus
      }
    }
  }
  "/users/me": {
    get: {
      res: {
        /**
         * Successful Response
         */
        200: UserRead
        /**
         * Missing token or inactive user.
         */
        401: unknown
      }
    }
    patch: {
      req: UsersUsersPatchCurrentUserData
      res: {
        /**
         * Successful Response
         */
        200: UserRead
        /**
         * Bad Request
         */
        400: ErrorModel
        /**
         * Missing token or inactive user.
         */
        401: unknown
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/users/{id}": {
    get: {
      req: UsersUsersUserData
      res: {
        /**
         * Successful Response
         */
        200: UserRead
        /**
         * Missing token or inactive user.
         */
        401: unknown
        /**
         * Not a superuser.
         */
        403: unknown
        /**
         * The user does not exist.
         */
        404: unknown
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    patch: {
      req: UsersUsersPatchUserData
      res: {
        /**
         * Successful Response
         */
        200: UserRead
        /**
         * Bad Request
         */
        400: ErrorModel
        /**
         * Missing token or inactive user.
         */
        401: unknown
        /**
         * Not a superuser.
         */
        403: unknown
        /**
         * The user does not exist.
         */
        404: unknown
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
    delete: {
      req: UsersUsersDeleteUserData
      res: {
        /**
         * Successful Response
         */
        204: void
        /**
         * Missing token or inactive user.
         */
        401: unknown
        /**
         * Not a superuser.
         */
        403: unknown
        /**
         * The user does not exist.
         */
        404: unknown
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/auth/login": {
    post: {
      req: AuthAuthDatabaseLoginData
      res: {
        /**
         * Successful Response
         */
        200: unknown
        /**
         * No Content
         */
        204: void
        /**
         * Bad Request
         */
        400: ErrorModel
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/auth/logout": {
    post: {
      res: {
        /**
         * Successful Response
         */
        200: unknown
        /**
         * No Content
         */
        204: void
        /**
         * Missing token or inactive user.
         */
        401: unknown
      }
    }
  }
  "/auth/register": {
    post: {
      req: AuthRegisterRegisterData
      res: {
        /**
         * Successful Response
         */
        201: UserRead
        /**
         * Bad Request
         */
        400: ErrorModel
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/auth/forgot-password": {
    post: {
      req: AuthResetForgotPasswordData
      res: {
        /**
         * Successful Response
         */
        202: unknown
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/auth/reset-password": {
    post: {
      req: AuthResetResetPasswordData
      res: {
        /**
         * Successful Response
         */
        200: unknown
        /**
         * Bad Request
         */
        400: ErrorModel
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/auth/request-verify-token": {
    post: {
      req: AuthVerifyRequestTokenData
      res: {
        /**
         * Successful Response
         */
        202: unknown
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/auth/verify": {
    post: {
      req: AuthVerifyVerifyData
      res: {
        /**
         * Successful Response
         */
        200: UserRead
        /**
         * Bad Request
         */
        400: ErrorModel
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/auth/oauth/authorize": {
    get: {
      req: AuthOauthGoogleDatabaseAuthorizeData
      res: {
        /**
         * Successful Response
         */
        200: OAuth2AuthorizeResponse
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/auth/oauth/callback": {
    get: {
      req: AuthOauthGoogleDatabaseCallbackData
      res: {
        /**
         * Successful Response
         */
        200: unknown
        /**
         * Bad Request
         */
        400: ErrorModel
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/auth/saml/login": {
    get: {
      res: {
        /**
         * Successful Response
         */
        200: SAMLDatabaseLoginResponse
      }
    }
  }
  "/auth/saml/acs": {
    post: {
      req: AuthSsoAcsData
      res: {
        /**
         * Successful Response
         */
        200: unknown
        /**
         * Validation Error
         */
        422: HTTPValidationError
      }
    }
  }
  "/health": {
    get: {
      res: {
        /**
         * Successful Response
         */
        200: HealthResponse
      }
    }
  }
  "/ready": {
    get: {
      res: {
        /**
         * Successful Response
         */
        200: ReadinessResponse
      }
    }
  }
}
