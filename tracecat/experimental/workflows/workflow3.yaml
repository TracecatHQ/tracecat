# This sample workflow executes 3 steps in sequence.
# 1) activity1, takes arg1 as input, and put result as result1.
# 2) it runs a parallel block which runs below sequence branches in parallel
#  2.1) sequence 1
#    2.1.1) activity2, takes result1 as input, and put result as result2
#    2.1.2) activity3, takes arg2 and result2 as input, and put result as result3
#  2.2) sequence 2
#    2.2.1) activity4, takes result1 as input, and put result as result4
#    2.2.2) activity5, takes arg3 and result4 as input, and put result as result5
# 3) activity6, takes result3 and result5 as input, and put result as result6.

variables:
  url: "http://example.com"
  another_url: "http://other.com/another"
  value: 1

root:
  sequence:
    # let key be unique within a workflow
    # Downstream, we can refer to this action by this key
    - ref: receive_data_from_webhook
      action: run_webhook_action
      args:
        inputs:
          forwarded_url: ${{ INPUTS.url }}
          value: ${{ INPUTS.value }}
    - parallel:
        - sequence:
            - ref: path_a_first
              action: run_http_request_action
              args:
                url: ${{ ACTIONS.receive_data_from_webhook.result.forwarded_url }}
            - parallel:
                - ref: path_a_second
                  action: run_http_request_action
                  args:
                    url: ${{ ACTIONS.path_a_first.result }}
                - ref: path_a_third
                  action: run_print_action
                  args:
                    value: ${{ INPUTS.value -> int }}
        - sequence:
            - ref: path_b_first
              action: run_http_request_action
              args:
                url: ${{ INPUTS.another_url }}
            - ref: path_b_second
              action: run_http_request_action
              args:
                url: ${{ ACTIONS.path_b_first.result }}
            - ref: path_b_third
              action: run_http_request_action
              args:
                url: ${{ INPUTS.value -> str }}
      # The benefit of using parallel branches to express fanout -> join logic is that
      # we don't have to explicitly define the joining and dependency resolution logic.
      # The join logic is implicit upon completing the parallel block.
      # The only drawback is that we can't have further fine grained control over the
      # join logic -- can only express AND and not OR.
    - ref: run_my_custom_function
      action: run_udf
      args:
        inputs:
          path_A: We got ${{ ACTIONS.path_a_second.result }} from path A
          path_B: We got ${{ ACTIONS.path_b_second.result }} from path B
