name: Create release

on:
  workflow_dispatch:
    inputs:
      tag:
        description: >-
          Version to release (e.g. 0.20.0, 0.20.0-beta.0).
          Leave empty to auto-increment the patch version.
        required: false
        type: string

permissions:
  contents: write
  actions: write

concurrency:
  group: create-release
  cancel-in-progress: false

jobs:
  create-release:
    runs-on: blacksmith-4vcpu-ubuntu-2404
    env:
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    steps:
      - name: Ensure workflow runs from main
        env:
          REF_NAME: ${{ github.ref_name }}
        run: |
          if [ "$REF_NAME" != "main" ]; then
            echo "This workflow must be run from the main branch (current: $REF_NAME)" >&2
            exit 1
          fi

      - name: Checkout main
        uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 0

      - name: Sync with latest main
        id: sync
        run: |
          git fetch origin main --tags
          git checkout main
          git reset --hard origin/main

          BASE_SHA=$(git rev-parse HEAD)
          echo "base_sha=$BASE_SHA" >> "$GITHUB_OUTPUT"

      - name: Bump version
        env:
          TAG: ${{ inputs.tag }}
        run: yes | ./scripts/update-version.sh $TAG

      - name: Read version
        id: version
        run: |
          VERSION=$(grep -oP '__version__ = "\K[^"]+' tracecat/__init__.py)
          if [ -z "$VERSION" ]; then
            echo "Failed to read version from tracecat/__init__.py" >&2
            exit 1
          fi
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"

      - name: Ensure version has not already been published
        uses: actions/github-script@v7
        env:
          VERSION: ${{ steps.version.outputs.version }}
        with:
          script: |
            const version = process.env.VERSION
            const { data: releases } = await github.rest.repos.listReleases({
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 100,
            })

            const publishedRelease = releases.find(
              (release) => !release.draft && release.tag_name === version,
            )
            if (publishedRelease) {
              core.setFailed(
                `Release ${version} is already published (release id ${publishedRelease.id}). Bump version before running create-release.`,
              )
              return
            }

      - name: Commit version bump and push
        id: commit
        uses: actions/github-script@v7
        env:
          VERSION: ${{ steps.version.outputs.version }}
          BASE_SHA: ${{ steps.sync.outputs.base_sha }}
        with:
          script: |
            const { execSync } = require('child_process')
            const fs = require('fs')
            const version = process.env.VERSION
            const baseSha = process.env.BASE_SHA

            // Verify there are changes to commit
            const diff = execSync('git diff --name-only', { encoding: 'utf-8' }).trim()
            if (!diff) {
              core.setFailed('No version changes were generated by update-version.sh.')
              return
            }

            // Verify tag doesn't already exist
            try {
              await github.rest.git.getRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: `tags/${version}`,
              })
              core.setFailed(`Tag ${version} already exists.`)
              return
            } catch (e) {
              if (e.status !== 404) throw e
            }

            // Create blobs for each changed file
            const changedFiles = diff.split('\n').filter(Boolean)
            const treeItems = []
            for (const file of changedFiles) {
              const content = fs.readFileSync(file, 'utf-8')
              const { data: blob } = await github.rest.git.createBlob({
                owner: context.repo.owner,
                repo: context.repo.repo,
                content,
                encoding: 'utf-8',
              })
              treeItems.push({ path: file, mode: '100644', type: 'blob', sha: blob.sha })
            }

            // Build tree on top of the base commit's tree
            const { data: baseCommit } = await github.rest.git.getCommit({
              owner: context.repo.owner,
              repo: context.repo.repo,
              commit_sha: baseSha,
            })

            const { data: tree } = await github.rest.git.createTree({
              owner: context.repo.owner,
              repo: context.repo.repo,
              base_tree: baseCommit.tree.sha,
              tree: treeItems,
            })

            // Create a verified commit via the API
            const { data: commit } = await github.rest.git.createCommit({
              owner: context.repo.owner,
              repo: context.repo.repo,
              message: `release: ${version}`,
              tree: tree.sha,
              parents: [baseSha],
            })

            // Fast-forward main (rejects if main has moved, like --force-with-lease)
            await github.rest.git.updateRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: 'heads/main',
              sha: commit.sha,
            })

            core.setOutput('sha', commit.sha)
            core.info(`Pushed verified commit ${commit.sha}`)

      - name: Create and push tag
        uses: actions/github-script@v7
        env:
          VERSION: ${{ steps.version.outputs.version }}
          COMMIT_SHA: ${{ steps.commit.outputs.sha }}
        with:
          script: |
            const version = process.env.VERSION
            const commitSha = process.env.COMMIT_SHA

            const { data: tag } = await github.rest.git.createTag({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag: version,
              message: `Release ${version}`,
              object: commitSha,
              type: 'commit',
            })

            await github.rest.git.createRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: `refs/tags/${version}`,
              sha: tag.sha,
            })

      - name: Wait for publish images and retry up to 3 times
        run: |
          tag="${{ steps.version.outputs.version }}"

          for _ in $(seq 1 30); do
            run_id=$(gh run list \
              --workflow build-push-images.yml \
              --json databaseId,headBranch,event,status \
              --jq "map(select(.headBranch == \"$tag\" and .event == \"push\")) | sort_by(.databaseId) | reverse | .[0].databaseId")

            if [ -n "$run_id" ] && [ "$run_id" != "null" ]; then
              break
            fi
            sleep 10
          done

          if [ -z "$run_id" ] || [ "$run_id" = "null" ]; then
            echo "Timed out waiting for publish-images run for tag $tag" >&2
            exit 1
          fi

          max_retries=3
          attempt=1
          max_attempts=$((max_retries + 1))

          while [ "$attempt" -le "$max_attempts" ]; do
            echo "Watching publish-images run $run_id (attempt $attempt/$max_attempts)"
            if gh run watch "$run_id" --exit-status; then
              echo "publish-images succeeded"
              exit 0
            fi

            if [ "$attempt" -eq "$max_attempts" ]; then
              echo "publish-images failed after $attempt attempts ($max_retries retries)" >&2
              exit 1
            fi

            echo "Retrying failed jobs for publish-images run $run_id"
            gh run rerun "$run_id" --failed
            attempt=$((attempt + 1))
          done

      - name: Publish latest release drafter draft release
        uses: actions/github-script@v7
        env:
          VERSION: ${{ steps.version.outputs.version }}
          RELEASE_SHA: ${{ steps.commit.outputs.sha }}
        with:
          script: |
            const version = process.env.VERSION
            const releaseSha = process.env.RELEASE_SHA
            const { data: releases } = await github.rest.repos.listReleases({
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 100,
            })

            const draft = releases.find((release) => release.draft)

            if (!draft) {
              core.setFailed('No draft release found to publish')
              return
            }

            await github.rest.repos.updateRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: draft.id,
              draft: false,
              tag_name: version,
              target_commitish: releaseSha,
              name: `Tracecat ${version}`,
            })
