title: Extract IoCs from Slack conversation message, tag Slack users, and create thread.
description: |
  Given a Slack conversation message, this playbook extracts URLs and IP addresses from the message,
  tags the users mentioned in the message, and creates a thread with the extracted IOCs.
config:
  # NOTE: Setting `enable_runtime_tests` to `true` here will override all other
  # runtime configuration for this flag i.e. tracecat workflow run --test flag).
  enable_runtime_tests: false
entrypoint:
  ref: pull_slack_conversations
  expects:
    latest: datetime
    oldest: datetime
    message_limit: int

actions:
  - ref: pull_slack_conversations
    action: integrations.chat.slack.list_slack_conversations
    args:
      channel: ${{ SECRETS.slack.SLACK_CHANNEL }}
      latest: ${{ TRIGGER.latest }}
      oldest: ${{ TRIGGER.oldest }}
      limit: ${{ TRIGGER.message_limit }}

  - ref: filter_datadog_messages_only
    action: core.transform.filter
    depends_on:
      - pull_slack_conversations
    run_if: ${{ FN.not_empty(ACTIONS.pull_slack_conversations.result) }}
    args:
      items: ${{ ACTIONS.pull_slack_conversations.result }}
      constraint:
        jsonpath: $.bot_profile.name
        operator: ==
        target: Datadog

  - ref: reshape_conversations
    action: core.transform.forward
    depends_on:
      - filter_datadog_messages_only
    run_if: ${{ FN.not_empty(ACTIONS.filter_datadog_messages_only.result) }}
    for_each: ${{ for var.conversation in ACTIONS.filter_datadog_messages_only.result }}
    args:
      value:
        attachments: ${{ var.conversation.attachments }}
        thread_ts: ${{ var.conversation.ts }}

  - ref: extract_emails_from_conversations
    action: core.extraction.extract_emails
    depends_on:
      - reshape_conversations
    for_each: ${{ for var.conversation in ACTIONS.reshape_conversations.result }}
    args:
      texts: ${{ [FN.serialize_json(var.conversation.attachments)] }}
      normalize: true

  - ref: zip_conversations_and_emails
    action: core.transform.forward
    depends_on:
      - extract_emails_from_conversations
    for_each:
      - ${{ for var.conversation in ACTIONS.reshape_conversations.result }}
      - ${{ for var.emails in ACTIONS.extract_emails_from_conversations.result }}
    args:
      value:
        conversation: ${{ var.conversation }}
        emails: ${{ var.emails }}

  - ref: filter_out_conversations_with_no_emails
    action: core.transform.filter
    depends_on:
      - zip_conversations_and_emails
    args:
      items: ${{ ACTIONS.zip_conversations_and_emails.result }}
      constraint:
        jsonpath: $.emails
        function: not_empty

  - ref: find_slack_users
    action: integrations.chat.slack.list_slack_users
    depends_on:
      - filter_out_conversations_with_no_emails
    run_if: ${{ FN.not_empty(ACTIONS.filter_out_conversations_with_no_emails.result) }}
    args:
      emails: ${{ FN.unique(FN.flatten(ACTIONS.filter_out_conversations_with_no_emails.result[*].emails)) }}

  - ref: slack_user_mapping
    action: core.transform.build_reference_table
    depends_on:
      - find_slack_users
    args:
      items: ${{ ACTIONS.find_slack_users.result }}
      key: $.profile.email

  - ref: add_slack_info_to_conversations
    action: core.transform.forward
    depends_on:
      - filter_out_conversations_with_no_emails
      - slack_user_mapping
    run_if: ${{ FN.not_empty(ACTIONS.filter_out_conversations_with_no_emails.result) }}
    for_each:
      - ${{ for var.conversation in ACTIONS.filter_out_conversations_with_no_emails.result }}
    args:
      value:
        conversation: ${{ var.conversation.conversation }}
        slack_info: ${{ FN.filter(FN.lookup.map(ACTIONS.slack_user_mapping.result, var.conversation.emails), "x != None") }}

  - ref: filter_out_empty_slack_info
    action: core.transform.filter
    depends_on:
      - add_slack_info_to_conversations
    args:
      items: ${{ ACTIONS.add_slack_info_to_conversations.result }}
      constraint:
        jsonpath: $.slack_info
        function: not_empty

  - ref: extract_slack_tags
    action: core.transform.forward
    depends_on:
      - filter_out_empty_slack_info
    run_if: ${{ FN.not_empty(ACTIONS.filter_out_empty_slack_info.result) }}
    for_each: ${{ for var.conversation in ACTIONS.filter_out_empty_slack_info.result }}
    args:
      # Use jsonpath to pull the id fields as a list of ids
      value: ${{ FN.format.map('<@{}>', var.conversation.slack_info[*].id) }}

  - ref: create_thread
    action: integrations.chat.slack.post_slack_message
    depends_on:
      - extract_slack_tags
    run_if: ${{ FN.not_empty(ACTIONS.extract_slack_tags.result) }}
    for_each:
      - ${{ for var.convo_to_slack_info in ACTIONS.add_slack_info_to_conversations.result }}
      - ${{ for var.user_tags in ACTIONS.extract_slack_tags.result }}
    args:
      channel: ${{ SECRETS.slack.SLACK_CHANNEL }}
      thread_ts: ${{ var.convo_to_slack_info.conversation.thread_ts }}
      text: "*Tagged users:* ${{ FN.join(var.user_tags, ', ') }}"

tests:
  - ref: pull_slack_conversations
    success: []
    # success: http://host.docker.internal:8005/dd_slack_tag/some_no_email_multiple.json

  # Could only find 1 user
  - ref: find_slack_users
    success: http://host.docker.internal:8005/dd_slack_tag/email_no_slack_user.json
